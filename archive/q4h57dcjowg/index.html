<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 异步进化史"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript 异步进化史 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/q4h57dcjowg/",
				"appid": "1613049289050283", 
				"title": "JavaScript 异步进化史 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-06T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/7qeo5sv9wre/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/b4212cjcsr5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fq4h57dcjowg%2f&text=JavaScript%20%e5%bc%82%e6%ad%a5%e8%bf%9b%e5%8c%96%e5%8f%b2"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fq4h57dcjowg%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fq4h57dcjowg%2f&text=JavaScript%20%e5%bc%82%e6%ad%a5%e8%bf%9b%e5%8c%96%e5%8f%b2"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fq4h57dcjowg%2f&title=JavaScript%20%e5%bc%82%e6%ad%a5%e8%bf%9b%e5%8c%96%e5%8f%b2"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fq4h57dcjowg%2f&is_video=false&description=JavaScript%20%e5%bc%82%e6%ad%a5%e8%bf%9b%e5%8c%96%e5%8f%b2"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20%e5%bc%82%e6%ad%a5%e8%bf%9b%e5%8c%96%e5%8f%b2&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fq4h57dcjowg%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fq4h57dcjowg%2f&title=JavaScript%20%e5%bc%82%e6%ad%a5%e8%bf%9b%e5%8c%96%e5%8f%b2"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq4h57dcjowg%2f&title=JavaScript%20%e5%bc%82%e6%ad%a5%e8%bf%9b%e5%8c%96%e5%8f%b2"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq4h57dcjowg%2f&title=JavaScript%20%e5%bc%82%e6%ad%a5%e8%bf%9b%e5%8c%96%e5%8f%b2"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq4h57dcjowg%2f&title=JavaScript%20%e5%bc%82%e6%ad%a5%e8%bf%9b%e5%8c%96%e5%8f%b2"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 异步进化史</h1><div class="meta"><div class="postdate"><time datetime="2019-02-06" itemprop="datePublished">2019-02-06</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e同步与异步\x3c\/h2\x3e\n\x3cp\x3e通常，代码是由上往下依次执行的。如果有多个任务，就必需排队，前一个任务完成，后一个任务才会执行。这种执行模式称之为： \x3cstrong\x3e同步（synchronous）\x3c\/strong\x3e 。新手容易把计算机用语中的同步，和日常用语中的同步弄混淆。如，“把文件同步到云端”中的同步，指的是“使...保持一致”。而在计算机中，同步指的是任务从上往下依次执行的模式。比如：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 1 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22A();\nB();\nC();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eA();\nB();\nC();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上述代码中，A、B、C 是三个不同的函数，每个函数都是一个不相关的任务。在同步模式下，计算机会先执行 A 任务，再执行 B 任务，最后执行 C 任务。在大部分情况，同步模式都没问题。但是如果 B 任务是一个耗时很长网络的请求，而 C 任务恰好是展现新页面，B 与 C 没有依赖关系。这就会导致网页卡顿的现象。有一种解决方案，将 B 放在 C 后面去执行，但唯一有些不足的是，B 的网络请求会迟一些再发送。\x3c\/p\x3e\n\x3cp\x3e还有另一种更完美解决方案，将 B 任务分成的两个部分。一部分是，立即执行网络请求的任务；另一部分是，在请求数据回来后执行的任务。这种一部分在立即执行，另一部分在未来执行的模式称为 \x3cstrong\x3e异步（asynchronous）\x3c\/strong\x3e 。伪代码如下：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 2 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22A();\n\/\/ 在现在发送请求\najax(\x27url1\x27,function B() {\n  \/\/ 在未来某个时刻执行\n})\nC();\n\/\/ 执行顺序 A =\x3e C =\x3e B\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eA();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在现在发送请求\x3c\/span\x3e\najax(\x3cspan class=\x22hljs-string\x22\x3e\x27url1\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eB\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在未来某个时刻执行\x3c\/span\x3e\n})\nC();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行顺序 A =\x26gt; C =\x26gt; B\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实际上，JavaScript 引擎先执行了调用了浏览器的网络请求接口的任务（一部分任务），再由浏览器发送网络请求并监听请求返回（这个任务不由 JavaScript 引擎执行，而是浏览器）；等请求放回后，浏览器再通知 JavaScript 引擎，开始执行回调函数中的任务（另一部分）。JavaScript  异步能力的本质是浏览器或 Node 的多线程能力。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3ecallback\x3c\/h2\x3e\n\x3cp\x3e未来执行的函数通常也叫 callback。使用 callback 的异步模式，解决了阻塞的问题，但是也带了一些其他问题。在最开始，我们的函数是从上往下书写的，也是从上往下执行的，这非常符合我们的思维习惯，但是现在却被 callback 打断了！在上面一段代码中，它跳过 B 任务，先执行了 C任务！这种异步“非线性”的代码会比同步“线性”的代码，更难阅读，因此也更容易滋生 BUG。\x3c\/p\x3e\n\x3cp\x3e试着判断下面这段代码的执行顺序，你会对“非线性”代码比“线性”代码更难以阅读，体会更深。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 3 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22A();\najax(\x27url1\x27, function(){\n    B();\n    ajax(\x27url2\x27, function(){\n        C();\n    }\n    D();\n});\nE();\n\n\/\/ 下面是答案，你猜对了吗？\n\/\/ A =\x3e E =\x3e B =\x3e D =\x3e C\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eA();\najax(\x3cspan class=\x22hljs-string\x22\x3e\x27url1\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    B();\n    ajax(\x3cspan class=\x22hljs-string\x22\x3e\x27url2\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        C();\n    }\n    D();\n});\nE();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 下面是答案，你猜对了吗？\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ A =\x26gt; E =\x26gt; B =\x26gt; D =\x26gt; C\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在例 3 中，我们的阅读代码视线是 \x3ccode\x3eA =\x26gt; B =\x26gt; C =\x26gt; D =\x26gt; E\x3c\/code\x3e ，但是执行顺序却是 \x3ccode\x3eA =\x26gt; E =\x26gt; B =\x26gt; D =\x26gt; C\x3c\/code\x3e 。从上往下执行的顺序被 Callback 打乱了，这就是非线性代码带来的糟糕之处。\x3c\/p\x3e\n\x3cp\x3e上面的例子中，我们可以通过将 \x3ccode\x3eajax\x3c\/code\x3e 后面执行的任务 \x3ccode\x3eE\x3c\/code\x3e 和 任务 \x3ccode\x3eD\x3c\/code\x3e 提前，来进行代码优化。这种技巧在写多重嵌套的代码时，是非常有用的。改进后，如下。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 4 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22A();\nE();\najax(\x27url1\x27, function(){\n    B();\n    D();\n    ajax(\x27url2\x27, function(){\n        C();\n    }\n});\n\/\/ 稍作优化，代码更容易看懂\n\/\/ A =\x3e E =\x3e B =\x3e D =\x3e C\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eA();\nE();\najax(\x3cspan class=\x22hljs-string\x22\x3e\x27url1\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    B();\n    D();\n    ajax(\x3cspan class=\x22hljs-string\x22\x3e\x27url2\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        C();\n    }\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 稍作优化，代码更容易看懂\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ A =\x26gt; E =\x26gt; B =\x26gt; D =\x26gt; C\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在例 4 中，只有处理了成功回调，并没处理异常回调。接下来，把异常处理回调加上，再来讨论代码“线性”执行的问题。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 5 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22A();\n\najax(\x27url1\x27, function(){\n    B();\n\n    ajax(\x27url2\x27, function(){\n        C();\n    },function(){\n        D();\n    });\n\n},function(){\n    E();\n\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eA();\n\najax(\x3cspan class=\x22hljs-string\x22\x3e\x27url1\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    B();\n\n    ajax(\x3cspan class=\x22hljs-string\x22\x3e\x27url2\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        C();\n    },\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        D();\n    });\n\n},\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    E();\n\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e例 5 中，加上异常处理回调后，\x3ccode\x3eurl1\x3c\/code\x3e 的成功回调函数 B 和异常回调函数 E，被分开了。这种“非线性”的情况又出现了。\x3c\/p\x3e\n\x3cp\x3e在 node 中，为了解决的异常处理“非线性”的问题，制定了错误优先的策略。node 中 callback 的第一个参数，专门用于判断是否发生异常。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 6 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22A();\n\nget(\x27url1\x27, function(error){\n    if(error){\n        E();\n    }else {\n        B();\n\n        get(\x27url2\x27, function(error){\n            if(error){\n                D();\n            }else{\n                C();\n            }\n        });\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eA();\n\nget(\x3cspan class=\x22hljs-string\x22\x3e\x27url1\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerror\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(error){\n        E();\n    }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        B();\n\n        get(\x3cspan class=\x22hljs-string\x22\x3e\x27url2\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerror\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(error){\n                D();\n            }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n                C();\n            }\n        });\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e到此，callback 引起的“非线性”问题基本得到解决。遗憾的是，一旦嵌套层数多起来，阅读起来还不是很方便。此外，callback 一旦出现异常，只能在当前回调内部处理异常，并没有一个整体的异常触底方案。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3epromise\x3c\/h2\x3e\n\x3cp\x3e在 JavaScript 的异步进化史中，涌现出一系列解决 callback 弊端的库，而 Promise 成为了最终的胜者，并成功地被引入了 ES6 中。它将提供了一个更好的“线性”书写方式，并解决了异步异常只能在当前回调中捕获的问题。\x3c\/p\x3e\n\x3cp\x3ePromise 就像一个中介，它承诺会将一个可信任的异步结果返回。签订协议的两方分别是异步接口和 callback。首先 Promise 和异步接口签订一个协议，成功时，调用 \x3ccode\x3eresolve\x3c\/code\x3e 函数通知 Promise，异常时，调用 \x3ccode\x3ereject\x3c\/code\x3e 通知 Promise。另一方面 Promise 和 callback 也签订一个协议，当异步接口的 \x3ccode\x3eresolve\x3c\/code\x3e 或 \x3ccode\x3ereject\x3c\/code\x3e 被调用时，由 Promise 返回可信任的值给 \x3ccode\x3ethen\x3c\/code\x3e 和 \x3ccode\x3ecatch\x3c\/code\x3e 中注册的 callback。\x3c\/p\x3e\n\x3cp\x3e一个最简单的 promise 示例如下：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 7 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建一个 Promise 实例（异步接口和 Promise 签订协议）\nvar promise = new Promise(function (resolve,reject) {\n  ajax(\x27url\x27,resolve,reject);\n});\n\n\/\/ 调用实例的 then catch 方法 （成功回调、异常回调与 Promise 签订协议）\npromise.then(function(value) {\n  \/\/ success\n}).catch(function (error) {\n  \/\/ error\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个 Promise 实例（异步接口和 Promise 签订协议）\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e promise = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e) \x3c\/span\x3e{\n  ajax(\x3cspan class=\x22hljs-string\x22\x3e\x27url\x27\x3c\/span\x3e,resolve,reject);\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用实例的 then catch 方法 （成功回调、异常回调与 Promise 签订协议）\x3c\/span\x3e\npromise.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ success\x3c\/span\x3e\n}).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerror\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ error\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ePromise 是个非常不错的中介，它只返回可信的信息给 callback。怎么理解可信的概念呢？准确的讲，就是 callback 一定会被\x3cstrong\x3e异步调用\x3c\/strong\x3e，且\x3cstrong\x3e只会调用一次\x3c\/strong\x3e。比如在使用第三方库的时候，由于某些原因，（假的）“异步”接口不可靠，它执行了同步代码，而没有进入异步逻辑，如例 8。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 8 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var promise1 = new Promise(function (resolve) {\n  \/\/ 由于某些原因导致“异步”接口，被同步执行了\n  if (true ){\n    \/\/ 同步代码\n    resolve(\x27B\x27);\n  } else {\n    \/\/ 异步代码\n    setTimeout(function(){\n      resolve(\x27B\x27);\n    },0)\n  }\n\n});\n\n\/\/ promise依旧会异步执行\npromise1.then(function(value){\n    console.log(value)\n});\n\nconsole.log(\x27A\x27);\n\/\/ A =\x3e B （先 A 后 B）\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e promise1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由于某些原因导致“异步”接口，被同步执行了\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e ){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 同步代码\x3c\/span\x3e\n    resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异步代码\x3c\/span\x3e\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n      resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e);\n    },\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n  }\n\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ promise依旧会异步执行\x3c\/span\x3e\npromise1.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value)\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ A =\x26gt; B （先 A 后 B）\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再比如，由于某些原因，异步接口不可靠，\x3ccode\x3eresolve\x3c\/code\x3e 或 \x3ccode\x3ereject\x3c\/code\x3e 被执行了两次。但 Promise 只会通知 callback ，第一次异步接口返回的结果。如例 9：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 9 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nvar promise2 = new Promise(function (resolve) {\n  \/\/ resolve 被执行了 2 次\n  setTimeout(function(){\n    resolve(\x26quot;第一次\x26quot;);\n  },0)\n  setTimeout(function(){\n    resolve(\x26quot;第二次\x26quot;);\n  },0)\n});\n\n\/\/ 但 callback 只会被调用一次，\npromise2.then(function(msg){\n    console.log(msg) \/\/ \x26quot;第一次\x26quot;\n    console.log(\x27A\x27)\n});\n\/\/ A (只有一个)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e promise2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve 被执行了 2 次\x3c\/span\x3e\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    resolve(\x3cspan class=\x22hljs-string\x22\x3e\x22第一次\x22\x3c\/span\x3e);\n  },\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n  setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    resolve(\x3cspan class=\x22hljs-string\x22\x3e\x22第二次\x22\x3c\/span\x3e);\n  },\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但 callback 只会被调用一次，\x3c\/span\x3e\npromise2.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emsg\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(msg) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22第一次\x22\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e)\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ A (只有一个)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e介绍完 Promise 的特性后，来看看它如何利用链式调用，解决 callback 模式下，异步代码可读性的问题。链式调用指的是：函数 \x3ccode\x3ereturn\x3c\/code\x3e 一个可以继续执行的对象，该对象可以继续调用，并且 \x3ccode\x3ereturn\x3c\/code\x3e 另一个可以继续执行的对象，如此反复达到不断调用的结果。如例 10：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 10 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ return 一个可以继续执行的 Promise 对象\nvar fetch = function(url){\n    return new Promise(function (resolve,reject) {\n        ajax(url,resolve,reject);\n    });\n}\n\nA();\nfetch(\x27url1\x27).then(function(){\n    B();\n    \/\/ 返回一个新的 Promise 实例\n    return fetch(\x27url2\x27);\n}).catch(function(){\n    C();\n    \/\/ 异常的时候也可以返回一个新的 Promise 实例\n    return fetch(\x27url2\x27);\n    \/\/ 使用链式写法调用这个新的 Promise 实例的 then 方法\n}).then(function() {\n    \/\/ 可以继续 return，也可以不继续 return，结束链式调用\n    D();\n})\n\/\/ A B C D （顺序执行）\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ return 一个可以继续执行的 Promise 对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fetch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eurl\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e) \x3c\/span\x3e{\n        ajax(url,resolve,reject);\n    });\n}\n\nA();\nfetch(\x3cspan class=\x22hljs-string\x22\x3e\x27url1\x27\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    B();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回一个新的 Promise 实例\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27url2\x27\x3c\/span\x3e);\n}).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    C();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异常的时候也可以返回一个新的 Promise 实例\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27url2\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用链式写法调用这个新的 Promise 实例的 then 方法\x3c\/span\x3e\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可以继续 return，也可以不继续 return，结束链式调用\x3c\/span\x3e\n    D();\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ A B C D （顺序执行）\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如此反复，不断返回一个 Promise 对象，使 Promise 摆脱了 callback 层层嵌套的问题和异步代码“非线性”执行的问题。\x3c\/p\x3e\n\x3cp\x3e另外，Promise 还解决了一个难点，callback 只能捕获当前错误异常。Promise 和 callback 不同，每个 callback 只能知道自己的报错情况，但 Promise 代理着所有的 callback，所有 callback 的报错，都可以由 Promise 统一处理。所以，可以通过在最后设置一个 \x3ccode\x3ecatch\x3c\/code\x3e 来捕获之前未捕获异常。\x3c\/p\x3e\n\x3cp\x3ePromise 解决 callback 的异步调用问题，但 Promise 并没有摆脱 callback，它只是将 callback 放到一个可以信任的中间机构，这个中间机构去链接 callback 和异步接口。此外，链式调用的写法并不是非常优雅。接下来介绍的异步（async）函数方案，会给出一个更好的解决方案。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e异步（async）函数\x3c\/h2\x3e\n\x3cp\x3e异步（async）函数是 ES7 的一个新的特性，它结合了 Promise，让我们摆脱 callback 的束缚，直接用“同步”方式，写异步函数。注意，这里的同步指的是写法同步，但实际依旧是异步执行的。\x3c\/p\x3e\n\x3cp\x3e声明异步函数，只需在普通函数前添加一个关键字 \x3ccode\x3easync\x3c\/code\x3e 即可，如:\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3easync function main(){}\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e在异步函数中，可以使用 \x3ccode\x3eawait\x3c\/code\x3e 关键字，表示等待后面表达式的执行结果，再往下继续执行。表达式一般都是 Promise 实例。如，例 11：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 11 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var  timer = function (delay) {\n  return new Promise(function create(resolve,reject) {\n    if(typeof delay !== \x27number\x27){\n      reject(new Error(\x27type error\x27));\n    }\n    setTimeout(resolve,delay,\x27done\x27);\n  });\n}\n\nasync function main{\n    var value = await timer(100);\n    \/\/ 不会立刻执行，等待 100ms 后才开始执行\n    console.log(value);  \/\/ done\n}\n\nmain();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e  timer = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3edelay\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e delay !== \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e){\n      reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27type error\x27\x3c\/span\x3e));\n    }\n    setTimeout(resolve,delay,\x3cspan class=\x22hljs-string\x22\x3e\x27done\x27\x3c\/span\x3e);\n  });\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e timer(\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不会立刻执行，等待 100ms 后才开始执行\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ done\x3c\/span\x3e\n}\n\nmain();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e异步函数和普通函数的调用方式一样，最先执行 \x3ccode\x3emain()\x3c\/code\x3e 函数。之后，会立即执行 \x3ccode\x3etimer(100)\x3c\/code\x3e 函数。等到（ \x3ccode\x3eawait\x3c\/code\x3e ）后面的 promise 函数（ \x3ccode\x3etimer(100)\x3c\/code\x3e ）返回结果后，程序才会执行下一行代码。\x3c\/p\x3e\n\x3cp\x3e异步函数和普通函数写法基本类似，除了前面提到的声明方式类似和调用方式一样之外，它也可以使用 \x3ccode\x3etry...catch\x3c\/code\x3e 来捕捉异常，也可以传入参数。但在异步函数中使用 \x3ccode\x3ereturn\x3c\/code\x3e 是没有作用的，这和普通的 callback 函数 \x3ccode\x3ereturn\x3c\/code\x3e 没有作用是一样原因。callback 或者异步函数是单独放在 JavaScript 栈（stack）中执行的，这时同步代码已经执行完毕。\x3c\/p\x3e\n\x3cp\x3e在异步函数中，使用 \x3ccode\x3etry...catch\x3c\/code\x3e 异常捕获的方案，代替了 Promise \x3ccode\x3ecatch\x3c\/code\x3e 的异常捕获的方案。示例如下：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 12 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function main(delay){\n  try{\n    \/\/ timer 在例 11 中有过声明\n    var value1 = await timer(delay);\n    var value2 = await timer(\x27\x27);\n    var value3 = await timer(delay);\n  }catch(err){\n    console.error(err);\n      \/\/ Error: type error\n      \/\/   at create (\x3canonymous\x3e:5:14)\n      \/\/   at timer (\x3canonymous\x3e:3:10)\n      \/\/   at A (\x3canonymous\x3e:12:10)\n  }\n}\nmain(0);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edelay\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ timer 在例 11 中有过声明\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value1 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e timer(delay);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value2 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e timer(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value3 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e timer(delay);\n  }\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(err);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Error: type error\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/   at create (\x26lt;anonymous\x26gt;:5:14)\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/   at timer (\x26lt;anonymous\x26gt;:3:10)\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/   at A (\x26lt;anonymous\x26gt;:12:10)\x3c\/span\x3e\n  }\n}\nmain(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e更神奇的是，异步函数也遵循，“函数是第一公民”的准则。也可以当作值，传入普通函数和异步函数中执行。需要注意的是，在异步函数中使异步函数用时要使用 \x3ccode\x3eawait\x3c\/code\x3e，不然异步函会被同步执行。例子如下：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 12 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function doAsync(delay){\n    \/\/ timer 在例 11 中有过声明\n    var value1 = await timer(delay);\n    console.log(\x27A\x27)\n}\n\nasync function main(main){\n  doAsync(0);\n  console.log(\x27B\x27)\n}\n\nmain(main);\n\/\/ B A\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoAsync\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edelay\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ timer 在例 11 中有过声明\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value1 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e timer(delay);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emain\x3c\/span\x3e)\x3c\/span\x3e{\n  doAsync(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e)\n}\n\nmain(main);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ B A\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个时候打印出来的值是 \x3ccode\x3eB A\x3c\/code\x3e。说明 \x3ccode\x3edoAsync\x3c\/code\x3e 函数中的 \x3ccode\x3eawait timer(delay)\x3c\/code\x3e 并被同步执行了。如果要正确异步地执行 \x3ccode\x3edoAsync\x3c\/code\x3e 函数，需要该函数之前添加 \x3ccode\x3eawait\x3c\/code\x3e 关键字，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function main(delay){\n    var value1 = await timer(delay);\n    console.log(\x27A\x27)\n}\n\nasync function doAsync(main){\n    await main(0);\n    console.log(\x27B\x27)\n}\n\ndoAsync(main);\n\/\/ A B\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edelay\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value1 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e timer(delay);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoAsync\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emain\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e main(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e)\n}\n\ndoAsync(main);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ A B\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于异步函数采用类同步的书写方法，所以在处理多个并发请求，新手可能会像下面一样书写：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 例 13 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fetch = function (url) {\n  return new Promise(function (resolve,reject) {\n    ajax(url,resolve,reject);\n  });\n}\n\nasync function main(){\n  try{\n    var value1 = await fetch(\x27url1\x27);\n    var value2 = await fetch(\x27url2\x27);\n    conosle.log(value1,value2);\n  }catch(err){\n    console.error(err)\n  }\n}\n\nmain();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fetch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eurl\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve,reject\x3c\/span\x3e) \x3c\/span\x3e{\n    ajax(url,resolve,reject);\n  });\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value1 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27url1\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value2 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27url2\x27\x3c\/span\x3e);\n    conosle.log(value1,value2);\n  }\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(err)\n  }\n}\n\nmain();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但这样会导致 \x3ccode\x3eurl2\x3c\/code\x3e 的请求必需等到 \x3ccode\x3eurl1\x3c\/code\x3e 的请求回来后才会发送。如果 \x3ccode\x3eurl1\x3c\/code\x3e 与 \x3ccode\x3eurl2\x3c\/code\x3e 没有相互的依赖关系，将这两个请求同时发送实现的效果会更好。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ePromise.all\x3c\/code\x3e 的方法，可以很好的处理并发请求。\x3ccode\x3ePromise.all\x3c\/code\x3e 接受将多个 Promise 实例为参数，并将这些参数包装成一个新的 Promise 实例。这样，\x3ccode\x3ePromise.all\x3c\/code\x3e  中所有的请求会第一时间发送出去；在所有的请求成功回来后才会触发 \x3ccode\x3ePromise.all\x3c\/code\x3e 的 \x3ccode\x3eresolve\x3c\/code\x3e 函数；当有一个请求失败，则立即调用 \x3ccode\x3ePromise.all\x3c\/code\x3e 的 \x3ccode\x3ereject\x3c\/code\x3e 函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fetch = function (url) {\n  return new Promise(function (resolve, reject) {\n    ajax(url, resolve, reject);\n  });\n}\n\nasync function main(){\n  try{\n    var arrValue = await Promise.all[fetch(\x27url1\x27),fetch(\x27url2\x27)];\n    conosle.log(arrValue[0], arrValue[1]);\n  }catch(err){\n    console.error(err)\n  }\n}\n\nmain();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fetch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eurl\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) \x3c\/span\x3e{\n    ajax(url, resolve, reject);\n  });\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arrValue = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all[fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27url1\x27\x3c\/span\x3e),fetch(\x3cspan class=\x22hljs-string\x22\x3e\x27url2\x27\x3c\/span\x3e)];\n    conosle.log(arrValue[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e], arrValue[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n  }\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(err)\n  }\n}\n\nmain();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后对异步函数的内容做个小结：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e声明： \x3ccode\x3easync function main(){}\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e异步函数逻辑：可以使用  \x3ccode\x3eawait\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e调用： \x3ccode\x3emain()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e捕获异常： \x3ccode\x3etry...catch\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e传入参数： \x3ccode\x3emain(\x27第一个参数\x27)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ereturn：不生效\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e异步函数作为参数传入其他函数：可以\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e处理并发逻辑：\x3ccode\x3ePromise.all\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e目前使用最新的 Chrome\/node 已经支持 ES7 异步函数的写法了，另外也可以通过 Babel 以将异步函数转义为 ES5 的语法执行。大家可以自己动手试试，使用异步函数，用类同步的方式，书写异步代码。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript 异步进化史</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006138882">https://segmentfault.com/a/1190000006138882</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/q4h57dcjowg/" target="_blank">https://alili.tech/archive/q4h57dcjowg/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>