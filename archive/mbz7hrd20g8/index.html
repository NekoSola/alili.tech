<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="为 Koa 框架封装 webpack-dev-middleware 中间件"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>为 Koa 框架封装 webpack-dev-middleware 中间件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mbz7hrd20g8/",
				"appid": "1613049289050283", 
				"title": "为 Koa 框架封装 webpack-dev-middleware 中间件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-12T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/26hoe91sisv/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/tl3cwcff3iq/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmbz7hrd20g8%2f&text=%e4%b8%ba%20Koa%20%e6%a1%86%e6%9e%b6%e5%b0%81%e8%a3%85%20webpack-dev-middleware%20%e4%b8%ad%e9%97%b4%e4%bb%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmbz7hrd20g8%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmbz7hrd20g8%2f&text=%e4%b8%ba%20Koa%20%e6%a1%86%e6%9e%b6%e5%b0%81%e8%a3%85%20webpack-dev-middleware%20%e4%b8%ad%e9%97%b4%e4%bb%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmbz7hrd20g8%2f&title=%e4%b8%ba%20Koa%20%e6%a1%86%e6%9e%b6%e5%b0%81%e8%a3%85%20webpack-dev-middleware%20%e4%b8%ad%e9%97%b4%e4%bb%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmbz7hrd20g8%2f&is_video=false&description=%e4%b8%ba%20Koa%20%e6%a1%86%e6%9e%b6%e5%b0%81%e8%a3%85%20webpack-dev-middleware%20%e4%b8%ad%e9%97%b4%e4%bb%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b8%ba%20Koa%20%e6%a1%86%e6%9e%b6%e5%b0%81%e8%a3%85%20webpack-dev-middleware%20%e4%b8%ad%e9%97%b4%e4%bb%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmbz7hrd20g8%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmbz7hrd20g8%2f&title=%e4%b8%ba%20Koa%20%e6%a1%86%e6%9e%b6%e5%b0%81%e8%a3%85%20webpack-dev-middleware%20%e4%b8%ad%e9%97%b4%e4%bb%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmbz7hrd20g8%2f&title=%e4%b8%ba%20Koa%20%e6%a1%86%e6%9e%b6%e5%b0%81%e8%a3%85%20webpack-dev-middleware%20%e4%b8%ad%e9%97%b4%e4%bb%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmbz7hrd20g8%2f&title=%e4%b8%ba%20Koa%20%e6%a1%86%e6%9e%b6%e5%b0%81%e8%a3%85%20webpack-dev-middleware%20%e4%b8%ad%e9%97%b4%e4%bb%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmbz7hrd20g8%2f&title=%e4%b8%ba%20Koa%20%e6%a1%86%e6%9e%b6%e5%b0%81%e8%a3%85%20webpack-dev-middleware%20%e4%b8%ad%e9%97%b4%e4%bb%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">为 Koa 框架封装 webpack-dev-middleware 中间件</h1><div class="meta"><div class="postdate"><time datetime="2019-02-12" itemprop="datePublished">2019-02-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e这篇文章能带给你什么\x3c\/h2\x3e\n\x3cp\x3e我见到有很多朋友在 SegmentFault 上面问一些不太好回答的问题，“JavaScript／Node 学好了能做什么？”，“前端架构师每天都做些什么？”等等。这些问题并非不能回答，但是第一、问题本身太过泛泛，很难回答的既针对又具体；第二、面对这样的问题一时也想不出从何处着手来回答。我自己觉得如果能配合一个实例来说明一下会比泛泛而谈更有价值，所以这篇文章等待了好久，就为了等一个合适的例子。\x3c\/p\x3e\n\x3cp\x3e恰逢最近一个项目应用了 React＋Redux 的同构化应用程序架构，在实施这个项目的过程中也使用了 express＋webpack 的组合，在整个过程中特别是 SSR（服务端渲染）这一块儿解决了不少的技术问题，我觉得值得总结一下经验。项目临近结束，我打算把里面的核心部分抽取出来重构一下做个开源项目，于是这里面就有了一些值得拿出来分享的例子，并且分享的目的不只是问题的解决方法本身，更重要的是一些额外的东西，那些能多多少少回答上述问题的东西。比如思路分析、原理阐释、源代码阅读、编写／调试技巧等等。\x3c\/p\x3e\n\x3cp\x3e如果接下来我能有比较充裕的时间，那就会不止这一篇，我的目标对象是那些初学者和处于进阶门槛的人，希望能对你们的胃口。接下来是第一个例子：为 Koa 框架封装 webpack-dev-middleware 中间件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e关于 Koa\x3c\/h2\x3e\n\x3cp\x3e我并非经验丰富的全栈型工程师，UI 编程方面还可以，服务端则只会些皮毛。前面提到的项目是我第一次用 express 编写真实上线的后端服务，并且也只是做了 SSR 而已。对于 express 我没什么特别的感觉——既没觉得不好，也没觉得出色，因此在重构的时候我打算试试从来没有玩过的 Koa。\x3c\/p\x3e\n\x3cp\x3e很多人都会问“学一个新的框架／工具最好的方法／途径是什么？”，我从来不回答这类的问题，因为我认为这是一个见仁见智的问题，而且我还认为只会听从于别人的规划是学不到东西的，所谓“因材施教”就是这个意思。当然你可以说“我是为了借鉴大家的经验”，然而若是为此的话其实可以问得更巧妙或是具体一些。\x3c\/p\x3e\n\x3cp\x3e在 Koa 这个具体的例子上我的方法其实很简单，就是把一个用 express 写过的项目用 Koa 重构一遍。不过对此我的要求很高，这些要求是方方面面的，其中有一个和本文有关，即：使用到的所有第三方的库都要读懂其原理，若不费事的话就自己造一遍。学习的方法千千万，不过里面总有些通用的法则，我的法则就是\x3cstrong\x3e求稳不求快\x3c\/strong\x3e。事实上这个法则在后面帮了我的大忙，因为熟悉了几个典型的 Koa 中间件后，在处理 webpack-dev-middleware 的封装时就觉得简单很多。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e关于 webpack-dev-middleware\x3c\/h2\x3e\n\x3cp\x3e对于 webpack-dev-middleware，最直观简单的理解就是一个运行于内存中的文件系统。你定义了 webpack.config，webpack 就能据此梳理出所有模块的关系脉络，而 webpack-dev-middleware 就在此基础上形成一个微型的文件映射系统，每当应用程序请求一个文件——比如说你定义的某个 \x3ccode\x3eentry\x3c\/code\x3e，它匹配到了就把内存中缓存的对应结果作为文件内容返回给你，反之则进入到下一个中间件。\x3c\/p\x3e\n\x3cp\x3e因为是内存型的文件系统，所以 rebuilding 的速度非常快，因此特别适合于开发阶段用作静态资源服务器；又因为 webpack 可以把任何一种资源都当作是模块来处理，因此它完全可以取代其他的 HTTP 服务器。事实上，大多数 webpack 用户用过的 webpack-dev-server 就是一个 express＋webpack-dev-middleware 的实现。二者的区别仅在于 webpack-dev-server 是封装好的，除了 webpack.config 和命令行参数之外，你很难去做定制型开发，所以它是适合纯前端项目的辅助工具。而 webpack-dev-middleware 是中间件，你可以编写自己的后端服务然后把它整合进来，相对而言就自由得多了。我们做的是一个前后同构的应用，因此 webpack-dev-server 就不予考虑了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e问题所在\x3c\/h2\x3e\n\x3cp\x3e问题在于 webpack-dev-middleware 是 express 标准的中间件，并不能直接用于 Koa。\x3c\/p\x3e\n\x3cp\x3e一个标准的 express 中间件是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22expressApp.use((req, res, next) =\x3e {\n  if (nextNeeded) {\n    \/\/ do what you want\n    \/\/ until you need down-stream middleware(s)\n    next();\n  } else {  \n    \/\/ anything else, e.g. sending response\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3eexpressApp.use(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ereq, res, next\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextNeeded) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do what you want\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ until you need down-stream middleware(s)\x3c\/span\x3e\n    next();\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {  \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ anything else, e.g. sending response\x3c\/span\x3e\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而一个标准的 Koa（v2.x）中间件是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22server.use((context, next) =\x3e Promise.resolve(() =\x3e doSomething()\n  .then(() =\x3e {\/* before next middleware *\/})\n  .then(() =\x3e next())\n  .then(() =\x3e {\/* ... and more *\/})\n  .then(() =\x3e {\/* after down-stream middleware(s) *\/})\n));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3eserver.use(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3econtext, next\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e doSomething()\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\x3cspan class=\x22hljs-comment\x22\x3e\/* before next middleware *\/\x3c\/span\x3e})\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e next())\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\x3cspan class=\x22hljs-comment\x22\x3e\/* ... and more *\/\x3c\/span\x3e})\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\x3cspan class=\x22hljs-comment\x22\x3e\/* after down-stream middleware(s) *\/\x3c\/span\x3e})\n));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e为什么上面要用 \x3ccode\x3ePromise.resolve\x3c\/code\x3e 包一层？……交给你自己探索了。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e或者是它的姊妹版，基于 \x3ccode\x3easync\x3c\/code\x3e 的函数形式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22koaApp.use(async (context, next) =\x3e {\n  const beforeNextMiddleware = await doSomething();\n  try {\n    await next();\n  } catch (error) {\n    context.body = { message: error.message };\n    context.status = error.status || 500;\n  }\n  return andMore().then(() =\x3e evenAfterDownStreams());\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3ekoaApp.use(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e (context, next) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e beforeNextMiddleware = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e doSomething();\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e next();\n  } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (error) {\n    context.body = { \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: error.message };\n    context.status = error.status || \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e andMore().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e evenAfterDownStreams());\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然以上只是一些最基本的概念，真实的中间件还有很多编写方法与技巧，不过我们已经看到二者最显著的不兼容之处，即它们的参数签名。如果直接把 webpack-dev-middleware 用于 Koa，显然由于 \x3ccode\x3eres\x3c\/code\x3e 不是一个函数是没有办法调用的，因此 Koa 会告诉你：\x3ccode\x3enext is not a function\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e看来要想把 webpack-dev-middleware 用在 Koa 里，需要封装一层中间件来协调两种不同的参数签名。如上所示，我使用的是 Koa v2，在此之前 Koa 的中间件是基于 ES2015 Generator 来编写的，Github 上可以找到适合 Generator 的 webpack-dev-middleware，但是找不到适合 Promise\/Async 的现成中间件，所以我们来自己造轮子吧。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eKoa 中间件的基础骨架\x3c\/h2\x3e\n\x3cp\x3e基本上，定义一个返回 Promise 的函数或是一个 Async 函数都可以直接拿来用作 Koa 中间件。不过大多数中间件都会需要 \x3ccode\x3eoptions\x3c\/code\x3e，所以惯例上都会用高阶函数包一层来传参：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default (compiler, options) =\x3e async (context, next) =\x3e {\n  await next();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e (compiler, options) =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e (context, next) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e next();\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ewebpack-dev-middleware 需要两个参数：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecompiler\x3c\/code\x3e：可以通过 \x3ccode\x3ewebpack(webpackConfig)\x3c\/code\x3e 得到\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eoptions\x3c\/code\x3e：补充 webpack-dev-middleware 需要的特定选项，其中 \x3ccode\x3epublicPath\x3c\/code\x3e 是必须的，并且其值应该等于 \x3ccode\x3ewebpackConfig.output.publicPath\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e因此我们可以帮用户检查 \x3ccode\x3eoptions\x3c\/code\x3e 是否有效，若不传 \x3ccode\x3eoptions\x3c\/code\x3e 就用 \x3ccode\x3ecompiler\x3c\/code\x3e 里的默认构造一份，有的话就沿用。严格一点的话你还可以检查 \x3ccode\x3epublicPath\x3c\/code\x3e 是否正确，否则抛出异常中断处理也可以——这个我就不写了。另外我还添加了一点点个人偏好的 \x3ccode\x3eoptions\x3c\/code\x3e 进去，这个是可选的，可以完全交给用户来传参。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import webpackDevMiddleware from \x27webpack-dev-middleware\x27;\n\n\/\/ personal taste, totally optional\nconst stats = {chunkModules: false, colors: \x27debug\x27 != process.env.NODE_ENV};\n\nexport default (compiler, options = {}) =\x3e {\n  \/\/ this is how we get the original webpack dev middleware, also totally\n  \/\/ optional if you willing to let user pass in everything.\n  const {publicPath} = compiler.options.output;\n  const defaults = options.publicPath ? options : {publicPath, stats};\n  const middleware = webpackDevMiddleware(compiler, Object.assign({}, defaults, options));\n  \n  \/\/ CAUTION: explicitly return middleware here because we don\x27t want to\n  \/\/ initialize webpackDevMiddleware instance through every request.\n  return async (context, next) =\x3e {\n    await next();\n  };\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e webpackDevMiddleware \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27webpack-dev-middleware\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ personal taste, totally optional\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e stats = {\x3cspan class=\x22hljs-attr\x22\x3echunkModules\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ecolors\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27debug\x27\x3c\/span\x3e != process.env.NODE_ENV};\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e (compiler, options = {}) =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this is how we get the original webpack dev middleware, also totally\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ optional if you willing to let user pass in everything.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {publicPath} = compiler.options.output;\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaults = options.publicPath ? options : {publicPath, stats};\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e middleware = webpackDevMiddleware(compiler, \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({}, defaults, options));\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ CAUTION: explicitly return middleware here because we don\x27t want to\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ initialize webpackDevMiddleware instance through every request.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e (context, next) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e next();\n  };\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我补充了比较详细的注释来解释 what \x26amp; how，初学者应该仔细读一下里面的经验之谈，顺便就当练习英文读写了；其实读源码的时候经常能得到这些 tips。另外别忘了看看命令行的输出，此时若无误 webpack 本身应该已经正常工作了。\x3c\/p\x3e\n\x3cp\x3e现在我们手头上拥有了 express 版本的中间件了，接下来就是考虑如何让其既能适合 Koa 对于中间件定义的要求，又能做好自己的本职工作。我们先来看看两方的参数如何匹配：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eexpress 的 \x3ccode\x3ereq\x3c\/code\x3e：等价于 Koa 的 \x3ccode\x3econtext.req\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eexpress 的 \x3ccode\x3eres\x3c\/code\x3e：等价于 Koa 的 \x3ccode\x3econtext.res\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eexpress 的 \x3ccode\x3enext()\x3c\/code\x3e：形式上等价于 Koa 的 \x3ccode\x3enext()\x3c\/code\x3e 但是两者的内涵不同，Koa 的 \x3ccode\x3enext()\x3c\/code\x3e 需要返回 Promise 对象（Async 函数是基于 Promise 的语法糖），但 express 的 \x3ccode\x3enext()\x3c\/code\x3e 只是单纯的回调函数\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e好吧，我们先来试试很天真的做法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...same as above, just pass to async function\n\nreturn async (context, next) =\x3e {\n  middleware(context.req, context.res, next);\n  await next();\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...same as above, just pass to async function\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e (context, next) =\x26gt; {\n  middleware(context.req, context.res, next);\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e next();\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e直接调用会让我们看到这样的错误：\x3ccode\x3eError: next() called multiple times\x3c\/code\x3e，从错误的蛛丝马迹来推断问题的原因是每一位初学者的必修课，接下来我们重温一遍这个过程看看在没什么经验的情况下如何处理这个情况（我不会讲很深的东西，因为我也不懂……）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e调试与源代码阅读\x3c\/h2\x3e\n\x3cp\x3e如果你试图截断抛出的异常然后向回追踪调用栈会发现看不出什么蛛丝马迹，顶多就是找到抛出 \x3ccode\x3eError: next() called multiple times\x3c\/code\x3e 的那一行代码，然而对解决这个问题并没有什么帮助。思考一下 \x3ccode\x3enext()\x3c\/code\x3e 为什么会多次（不正确的）调用？此时我并没有彻底想清楚，但是我得到了两条思路：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e回顾我们的代码，\x3ccode\x3enext()\x3c\/code\x3e 会在 \x3ccode\x3emiddleware\x3c\/code\x3e 里面调用，还会在 \x3ccode\x3emiddleware\x3c\/code\x3e 执行之后由 \x3ccode\x3eawait next()\x3c\/code\x3e，注意这两个 \x3ccode\x3enext\x3c\/code\x3e 的调用场景是不同的，而且在这时我们并不能确定 \x3ccode\x3emiddleware\x3c\/code\x3e 里面到底有没有调用 \x3ccode\x3enext()\x3c\/code\x3e 或者能不能正确处理 \x3ccode\x3enext()\x3c\/code\x3e，这些事情前面分析过。所以去步进一下 \x3ccode\x3emiddleware\x3c\/code\x3e 里的过程应该是比较明显的线索；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e按照中间件的逻辑，它们以栈的方式从上到下（按声明顺序，也就是 \x3ccode\x3eapp.use(middleware)\x3c\/code\x3e）的顺序执行，需要继续的就调用 \x3ccode\x3enext()\x3c\/code\x3e，已经处理完成的话就可以直接返回响应，所以后面的 \x3ccode\x3eawait next()\x3c\/code\x3e 应该是有条件调用的，因为在我写这个中间件的时候它之后就只剩下 SSR 的中间件了（调试时，把确认正常且不相干的中间件注释掉会是一个很好的办法）。如果它不停的 \x3ccode\x3eawait next()\x3c\/code\x3e，而 SSR 又不能全部处理为响应的话，出现前面的错误也不奇怪。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e第二点其实很值得深入说明，不过由于第一点可以立即动手试试，所以我们先动手看看能否带领我们理清第二点的细节。\x3c\/p\x3e\n\x3cp\x3e断点打到这里：\x3ca href=\x22https:\/\/github.com\/webpack\/webpack-dev-middleware\/blob\/master\/middleware.js#L175\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/webpack\/webpack-dev-m...\x3c\/a\x3e，准备步进看看怎么走的（webpack-dev-middleware 的源码我就不贴了，Github 上有现成的，后续指示的断点位置都来自于 Github）。\x3c\/p\x3e\n\x3cp\x3e对于陌生的代码在阅读／调试的时候不要急着钻细节，应该由表及里，先宏观再微观的逐层深入。像这个例子，断点打好之后我压根没看过程，只是不断的步进然后留意两个重点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e有没有大块代码在步进时被跳过。通常这是条件分支／异常处理等情形出现的特征，留意一下这些地方，在后续调试的时候会是节省时间并且帮助你宏观理解代码结构的好帮手；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e跳出的位置，一旦跳出了就回退一步（调用栈）看看是什么情况。正常的方法调用？（留意一下函数名字大致判断一下干什么去了）还是抛出异常？（留意一下错误对象看看什么原因）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e直到步进至前文错误出现的地方为止，我观察到 \x3ccode\x3ewebpackDevMiddleware\x3c\/code\x3e 几乎就没做什么事儿（其实这是很显然的，我刻意写了前面那个天真的代码就为了通过调试引导到这里……），从第二行开始就 \x3ccode\x3enext()\x3c\/code\x3e 出去了，此后直到异常重现都再没有它参与其中。好！我们仔细看看前两行，为什么啥都不干就 \x3ccode\x3enext()\x3c\/code\x3e？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var filename = getFilenameFromUrl(req.url);\nif (filename === false) return next();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e filename = getFilenameFromUrl(req.url);\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (filename === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e next();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很显然，如果从请求的 url 里匹配不到文件，那么就跳出 webpackDevMiddleware 剩下的处理逻辑直接进入到下一个中间件了。问题来了：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e为什么没有 \x3ccode\x3enext()\x3c\/code\x3e 到下一个中间件（SSR）而是抛出异常了呢？\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e什么情况下能匹配到文件而不是跳出呢？\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e第一个问题有兴趣可以步进 \x3ccode\x3enext()\x3c\/code\x3e 一路走下去看看什么情况，这里先告诉大家结论：前面说了 Koa v2.x 的中间件是基于 Promise 的，而此处是直接执行了一个空函数而没有返回 promise 对象，所以没法顺利过渡到后面的中间件。这个问题是不仅限于本文的例子的，只要你在 Koa v2.x 下开发迟早都会意识到这一点。我们在这里不做继续的深入是因为我的环境是使用 \x3ccode\x3ebabel-transform-async-to-module-method\x3c\/code\x3e 将 async 函数转为 bluebird Promise 实现的，而每个项目使用的 Promise 实现都未必一样，不具备通用性，因此这个问题点到为止。\x3c\/p\x3e\n\x3cp\x3e至于第二个问题这里要插播一些背景：我在写这个中间件的时候，用于测试的页面构成如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e一个 SSR 渲染的首页 \x3ccode\x3eindex.html\x3c\/code\x3e，只是最基本的 HTML5 模版，里面渲染了一个 React 组件做测试\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e一个 \x3ccode\x3eclient.js\x3c\/code\x3e，前面的组件在这里调用的，用于接手客户端渲染\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e一个 \x3ccode\x3evendor.js\x3c\/code\x3e, 包含了一些模块，比如 React、fetch、bluebird 之类常用的工具库\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3ccode\x3eindex.html\x3c\/code\x3e 自然是第一个请求了，它的里面引了后两个脚本，这俩脚本是使用 webpack 打包的，因此它们是应该在 webpack-dev-middleware 里被匹配到的，而 \x3ccode\x3eindex.html\x3c\/code\x3e 则应该通过调用 \x3ccode\x3enext()\x3c\/code\x3e 交由 SSR 渲染。\x3c\/p\x3e\n\x3cp\x3e此时此刻，\x3ccode\x3eindex.html\x3c\/code\x3e 第一个到达 webpack-dev-middleware 并走到了调用 \x3ccode\x3enext()\x3c\/code\x3e 这里，又因为前面提到的非 promise 的 \x3ccode\x3enext()\x3c\/code\x3e 问题导致了异常的抛出，于是下面就……木有了。\x3c\/p\x3e\n\x3cp\x3e行文为了流畅，以上的阐述自然省却了一些分析源码和调试的过程，不过不用担心，所谓“眼过千遍不如手过一遍”，要学会给自己找合适的机会亲身尝试一下。不用多，类似的事情做个两三次就会找到感觉，用不了多久就能把貌似一团乱麻的问题梳理的清清楚楚。这里顺便提个小故事，《实用主义程序员》提到的橡胶小黄鸭调试法，建议大家去读一读，个人觉得它非常有效。其精髓很简单：分析问题的时候要一句一句，一点一点的说出来，说给小黄鸭、奥特曼、恐龙特级克塞号……都无所谓，哪怕只是自言自语，但是一定要说出来，要出声！信不信一试便知。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e分而治之，逐个攻破\x3c\/h3\x3e\n\x3cp\x3e现在，我们尝试一步一步让 webpack-dev-middleware 和 Koa 和谐共处吧。\x3c\/p\x3e\n\x3cp\x3e首先，如果我们让 \x3ccode\x3enext()\x3c\/code\x3e 返回 Promise 的话会如何？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...same as above, just pass to async function\n\nreturn async (context, next) =\x3e {\n  middleware(context.req, context.res, () =\x3e Promise.resolve())\n  await next();\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...same as above, just pass to async function\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e (context, next) =\x26gt; {\n  middleware(context.req, context.res, () =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve())\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e next();\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们把传入的 \x3ccode\x3enext\x3c\/code\x3e 替换为一个返回 promise 的匿名函数再试试看？啊哈～ SSR 成功渲染！\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e如果你没有后续的 SSR 中间件也无妨，随便返回点 \x3ccode\x3eHello World\x3c\/code\x3e 的简单中间件也是一样的：\x3cbr\x3e\x3ccode\x3eapp.use(function(context, next) { context.body = \x22Hello World\x22 })\x3c\/code\x3e\x3cbr\x3e放在后面就行。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e但是 \x3ccode\x3eclient.js\x3c\/code\x3e 和 \x3ccode\x3evendor.js\x3c\/code\x3e 的请求返回的都是 404，这又是为啥嘞？像这样的问题下意识的都会以为 webpack-dev-middleware 是不是有问题？不过请等，像这种知名的开源项目出现这么“明显”问题的概率是很低的，不确信的话可以扫一下 issues 说不定也能找到答案。不过既然都已经读了一些源码了，索性咱继续往后走看看到底如何吧。\x3c\/p\x3e\n\x3cp\x3e当请求走到两个脚本文件的时候，前面的 \x3ccode\x3efilename\x3c\/code\x3e 检查就会跳过 \x3ccode\x3enext()\x3c\/code\x3e 调用了。\x3ca href=\x22https:\/\/github.com\/webpack\/webpack-dev-middleware\/blob\/master\/middleware.js#L177-L189\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eLine 177-189\x3c\/a\x3e 之间是一些选项检查和缓存处理，不用细究。\x3c\/p\x3e\n\x3cp\x3e要注意 \x3ca href=\x22https:\/\/github.com\/webpack\/webpack-dev-middleware\/blob\/master\/middleware.js#L191\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eLine 191\x3c\/a\x3e 开始的逻辑，L192 的 \x3ccode\x3eprocessRequest()\x3c\/code\x3e 是对匹配成功的请求的主要逻辑，由于首次请求要等待 building 完成才能返回完整的内容，所以 L191 又一个 \x3ccode\x3eready()\x3c\/code\x3e 做延迟处理（源代码有注释），因此断点要提前打到函数内部，否则眼一闭一睁——没了～\x3c\/p\x3e\n\x3cp\x3e在这之后我陷入了一段长时间的困惑，因为根据调试的结果，我们有了代表文件内容的 \x3ccode\x3econtent\x3c\/code\x3e，也执行了必要的 \x3ccode\x3eres.setHeader()\x3c\/code\x3e，最后尽管 \x3ccode\x3eres.send()\x3c\/code\x3e 方法不存在，但 webpack-dev-middleware 也 fallback 到了 \x3ccode\x3eres.end(content)\x3c\/code\x3e。按理来说应该是成功走完了才对，为什么会是 404 呢？\x3c\/p\x3e\n\x3cp\x3e其实早前我曾经提到过，\x3ccode\x3eawait next()\x3c\/code\x3e 这句应该是有条件调用的，具体来说：如果 \x3ccode\x3eres.end(content)\x3c\/code\x3e 正确执行了，那么我们就应该终止下一个中间件的继续调用。但目前我们在 \x3ccode\x3emiddleware()\x3c\/code\x3e 执行过后无论如何都会继续 \x3ccode\x3eawait next()\x3c\/code\x3e，于是我的 SSR 又接手了这些请求。鉴于 SSR 的设计是不去处理脚本等外链静态资源请求的，所以返回 404 也就不难理解了。（涉及 SSR 的部分以后有时间再分享）\x3c\/p\x3e\n\x3cp\x3e讨厌的是 webpack-dev-middleware 处理到最后并不会返回什么，所以我们拿不到可靠的条件来跳过 \x3ccode\x3eawait next()\x3c\/code\x3e 这一句。不过想想我们前面处理 \x3ccode\x3enext()\x3c\/code\x3e 的方式吧，我们不是让它顺利返回了 promise 对象吗？那么是不是也可以让 \x3ccode\x3emiddleware()\x3c\/code\x3e 也返回些什么东西呢？我们需要如下的结构：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...same as above, just pass to async function\n\nreturn async (context, next) =\x3e {\n  const hasNext = await middleware(context.req, context.res, () =\x3e Promise.resolve(true));\n  if (hasNext === true) { await next(); }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...same as above, just pass to async function\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e (context, next) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e hasNext = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e middleware(context.req, context.res, () =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e));\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hasNext === \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e) { \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e next(); }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意：这一点改动并不能解决前面 404 的问题，因为它只能保证在 \x3ccode\x3enext()\x3c\/code\x3e 被调用时让我们通过 await promise 拿到 \x3ccode\x3etrue\x3c\/code\x3e 而已。但是这一改动暗示着，如果我们能让 \x3ccode\x3emiddleware()\x3c\/code\x3e 在不走 \x3ccode\x3enext()\x3c\/code\x3e 的时候最终返回 \x3ccode\x3ePromise.resolve(false)\x3c\/code\x3e，那么就可以跳过不需要的 \x3ccode\x3eawait next()\x3c\/code\x3e 了。也就是说，我们需要包装 \x3ccode\x3eres.send()\x3c\/code\x3e 和 \x3ccode\x3eres.setHeader()\x3c\/code\x3e 方法让它们代理 webpack-dev-middleware 里的同名方法，同时让 \x3ccode\x3eres.send()\x3c\/code\x3e 返回 \x3ccode\x3ePromise.resolve(false)\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default (compiler, options = {}) =\x3e {\n  \/\/ omit options processing...\n  \n  return async (context, next) =\x3e {\n    const hasNext = await applyMiddleware(middleware, context.req, {\n      send: content =\x3e context.body = content,\n      setHeader: function() {context.set.apply(context, arguments)}\n    });\n    hasNext \x26amp;\x26amp; await next();\n  };\n};\n\nfunction applyMiddleware(middleware, req, res) {\n  const _send = res.send;\n  return new Promise((resolve, reject) =\x3e {\n    try {\n      res.send = function() {_send.apply(res, arguments) \x26amp;\x26amp; resolve(false)};\n      middleware(req, res, resolve.bind(null, true));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e (compiler, options = {}) =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ omit options processing...\x3c\/span\x3e\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e (context, next) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e hasNext = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e applyMiddleware(middleware, context.req, {\n      \x3cspan class=\x22hljs-attr\x22\x3esend\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3econtent\x3c\/span\x3e =\x26gt;\x3c\/span\x3e context.body = content,\n      \x3cspan class=\x22hljs-attr\x22\x3esetHeader\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{context.set.apply(context, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e)}\n    });\n    hasNext \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e next();\n  };\n};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eapplyMiddleware\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emiddleware, req, res\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e _send = res.send;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      res.send = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{_send.apply(res, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e) \x26amp;\x26amp; resolve(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)};\n      middleware(req, res, resolve.bind(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e));\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (error) {\n      reject(error);\n    }\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这一段变化较大同时又有点烧脑，且容我一一道来：\x3c\/p\x3e\n\x3cp\x3e首先我们需要单独写一个 \x3ccode\x3eapplyMiddleware\x3c\/code\x3e 函数用于返回可包含两种情形的 promise（而且更容易处理异常），且由于 promise 分离出去处理了，也就不需要单独封装 \x3ccode\x3enext()\x3c\/code\x3e 了。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3econtext.res\x3c\/code\x3e 不能原封不动的传进去了，否则又走回了 webpack-dev-middleware 的老路数，因此我们“伪造”了一个刚好够用的对象，仅实现了 \x3ccode\x3esend()\x3c\/code\x3e 和 \x3ccode\x3esetHeader()\x3c\/code\x3e 这俩方法。前文说过，这是 webpack-dev-middleware 唯二调用的两个属于 \x3ccode\x3eres\x3c\/code\x3e 对象的成员。这两个方法作用不变，但是内部使用的是 Koa 的对等 API，也就是说，当 webpack-dev-middleware 调用它们的时候，我们将会代理给 Koa 来进行等价处理。\x3c\/p\x3e\n\x3cp\x3e状态符 \x3ccode\x3ehasNext\x3c\/code\x3e 或真或假，将会由 \x3ccode\x3eapplyMiddleware\x3c\/code\x3e 返回，于是 \x3ccode\x3emiddleware\x3c\/code\x3e 的调用转入其中执行。\x3c\/p\x3e\n\x3cp\x3e再看 \x3ccode\x3eapplyMiddleware\x3c\/code\x3e 里面。首先我们拷贝了一份代理的 \x3ccode\x3eres.send\x3c\/code\x3e，这是因为该方法需要的 \x3ccode\x3econtent\x3c\/code\x3e 参数我们是无法直接获取到的，需要由 webpack-dev-middleware 调用时帮我们传进来，然后我们重写它并在其中 \x3ccode\x3eapply\x3c\/code\x3e 调用。注意，Koa 等价的 \x3ccode\x3esend()\x3c\/code\x3e 其实是针对 \x3ccode\x3econtext.body\x3c\/code\x3e 的直接赋值，因此 \x3ccode\x3eapply(null)\x3c\/code\x3e 是没有问题的，但是 \x3ccode\x3esetHeader\x3c\/code\x3e 需要 \x3ccode\x3eapply(context)\x3c\/code\x3e，否则 \x3ccode\x3ethis\x3c\/code\x3e 的指向会出问题。\x3c\/p\x3e\n\x3cp\x3e在这之后，我们才真正调用 \x3ccode\x3emiddleware()\x3c\/code\x3e，此时 \x3ccode\x3eres\x3c\/code\x3e 已经是经过处理的代理对象了，但 webpack-dev-middleware 再次走到 \x3ccode\x3esetHeader\x3c\/code\x3e 和 \x3ccode\x3esend\x3c\/code\x3e 那里的时候，这俩方法已经“叛变”成了 Koa 的等价处理逻辑，于是真正发挥作用的是 \x3ccode\x3econtext.body=\x3c\/code\x3e 和 \x3ccode\x3econtext.set\x3c\/code\x3e，最后 \x3ccode\x3econtext.body=\x3c\/code\x3e 其实是一个 setter，它最终返回的是实际的 \x3ccode\x3econtent\x3c\/code\x3e，我们知道它是一个真值，所以直接短路至 \x3ccode\x3eresolve(false)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eTips: \x3ccode\x3eresolve.bind(null, true)\x3c\/code\x3e 等价于 \x3ccode\x3efunction() { resolve(true) }\x3c\/code\x3e——如果你还不清楚这一点的话，它的作用就是帮助 \x3ccode\x3enext()\x3c\/code\x3e 返回结果为真的 promise\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e再次返回 \x3ccode\x3eawait applyMiddleware(...)\x3c\/code\x3e 那里，这一次 \x3ccode\x3ehasNext\x3c\/code\x3e 会在需要后续中间件介入时为真，前面 404 的问题迎刃而解。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eBonus\x3c\/h2\x3e\n\x3cp\x3e希望这篇文章絮絮叨叨的风格多少能带给初学者一些帮助或引导，Github 上还没有完成我们这个例子的开源项目，而我也不打算去做这件事情。我想把这个机会留给读完本文并且还没有在 npm 上发布过模块软件包的新手朋友们，如果你有这个热情和精力来维护它那就干吧，在这里我就权当开源了。等你发布后如果有问题我也乐意给予力所能及的帮助，衷心希望各位能在编程的道路上越走越远。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>为 Koa 框架封装 webpack-dev-middleware 中间件</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000004883199">https://segmentfault.com/a/1190000004883199</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mbz7hrd20g8/" target="_blank">https://alili.tech/archive/mbz7hrd20g8/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>