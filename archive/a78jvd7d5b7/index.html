<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="常见react面试题汇总（适合中级前端）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>常见react面试题汇总（适合中级前端） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/a78jvd7d5b7/",
				"appid": "1613049289050283", 
				"title": "常见react面试题汇总（适合中级前端） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-14T02:30:37"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/yccjn4r5m5t/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7jcgfbk2fwj/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fa78jvd7d5b7%2f&text=%e5%b8%b8%e8%a7%81react%e9%9d%a2%e8%af%95%e9%a2%98%e6%b1%87%e6%80%bb%ef%bc%88%e9%80%82%e5%90%88%e4%b8%ad%e7%ba%a7%e5%89%8d%e7%ab%af%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fa78jvd7d5b7%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fa78jvd7d5b7%2f&text=%e5%b8%b8%e8%a7%81react%e9%9d%a2%e8%af%95%e9%a2%98%e6%b1%87%e6%80%bb%ef%bc%88%e9%80%82%e5%90%88%e4%b8%ad%e7%ba%a7%e5%89%8d%e7%ab%af%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fa78jvd7d5b7%2f&title=%e5%b8%b8%e8%a7%81react%e9%9d%a2%e8%af%95%e9%a2%98%e6%b1%87%e6%80%bb%ef%bc%88%e9%80%82%e5%90%88%e4%b8%ad%e7%ba%a7%e5%89%8d%e7%ab%af%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fa78jvd7d5b7%2f&is_video=false&description=%e5%b8%b8%e8%a7%81react%e9%9d%a2%e8%af%95%e9%a2%98%e6%b1%87%e6%80%bb%ef%bc%88%e9%80%82%e5%90%88%e4%b8%ad%e7%ba%a7%e5%89%8d%e7%ab%af%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%b8%b8%e8%a7%81react%e9%9d%a2%e8%af%95%e9%a2%98%e6%b1%87%e6%80%bb%ef%bc%88%e9%80%82%e5%90%88%e4%b8%ad%e7%ba%a7%e5%89%8d%e7%ab%af%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fa78jvd7d5b7%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fa78jvd7d5b7%2f&title=%e5%b8%b8%e8%a7%81react%e9%9d%a2%e8%af%95%e9%a2%98%e6%b1%87%e6%80%bb%ef%bc%88%e9%80%82%e5%90%88%e4%b8%ad%e7%ba%a7%e5%89%8d%e7%ab%af%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fa78jvd7d5b7%2f&title=%e5%b8%b8%e8%a7%81react%e9%9d%a2%e8%af%95%e9%a2%98%e6%b1%87%e6%80%bb%ef%bc%88%e9%80%82%e5%90%88%e4%b8%ad%e7%ba%a7%e5%89%8d%e7%ab%af%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fa78jvd7d5b7%2f&title=%e5%b8%b8%e8%a7%81react%e9%9d%a2%e8%af%95%e9%a2%98%e6%b1%87%e6%80%bb%ef%bc%88%e9%80%82%e5%90%88%e4%b8%ad%e7%ba%a7%e5%89%8d%e7%ab%af%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fa78jvd7d5b7%2f&title=%e5%b8%b8%e8%a7%81react%e9%9d%a2%e8%af%95%e9%a2%98%e6%b1%87%e6%80%bb%ef%bc%88%e9%80%82%e5%90%88%e4%b8%ad%e7%ba%a7%e5%89%8d%e7%ab%af%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">常见react面试题汇总（适合中级前端）</h1><div class="meta"><div class="postdate"><time datetime="2019-02-14" itemprop="datePublished">2019-02-14</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3e已经开源\x3c\/h3\x3e\n\x3cp\x3e地址：\x3ca href=\x22https:\/\/github.com\/nanhupatar\/FEGuide\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/nanhupatar...\x3c\/a\x3e\x3cbr\x3e关注我们团队：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbi0VU?w=2800\x26amp;h=800\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbi0VU?w=2800\x26amp;h=800\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eReact 中 keys 的作用是什么？\x3c\/h3\x3e\n\x3cp\x3eKeys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22render () {\n  return (\n    \x3cul\x3e\n      {this.state.todoItems.map(({item, key}) =\x3e {\n        return \x3cli key={key}\x3e{item}\x3c\/li\x3e\n      })}\n    \x3c\/ul\x3e\n  )\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3erender () {\n  \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e (\n    \x26lt;ul\x26gt;\n      {this.state.todoItems.\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e(({item, \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e}) =\x26gt; {\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e={\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e}\x26gt;{item}\x26lt;\/\x3cspan class=\x22hljs-built_in\x22\x3eli\x3c\/span\x3e\x26gt;\n      })}\n    \x26lt;\/ul\x26gt;\n  )\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e调用 setState 之后发生了什么？\x3c\/h3\x3e\n\x3cp\x3e在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3ereact 生命周期函数\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e初始化阶段：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3egetDefaultProps:获取实例的默认属性\x3c\/li\x3e\n\x3cli\x3egetInitialState:获取每个实例的初始化状态\x3c\/li\x3e\n\x3cli\x3ecomponentWillMount：组件即将被装载、渲染到页面上\x3c\/li\x3e\n\x3cli\x3erender:组件在这里生成虚拟的 DOM 节点\x3c\/li\x3e\n\x3cli\x3ecomponentDidMount:组件真正在被装载之后\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e运行中状态：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ecomponentWillReceiveProps:组件将要接收到属性的时候调用\x3c\/li\x3e\n\x3cli\x3eshouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）\x3c\/li\x3e\n\x3cli\x3ecomponentWillUpdate:组件即将更新不能修改属性和状态\x3c\/li\x3e\n\x3cli\x3erender:组件重新描绘\x3c\/li\x3e\n\x3cli\x3ecomponentDidUpdate:组件已经更新\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e销毁阶段：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3ecomponentWillUnmount:组件即将销毁\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eshouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）\x3c\/h3\x3e\n\x3cp\x3eshouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。\x3c\/p\x3e\n\x3cp\x3e参考\x3ca\x3ereact 性能优化-sf\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e为什么虚拟 dom 会提高性能?(必考)\x3c\/h3\x3e\n\x3cp\x3e虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。\x3c\/p\x3e\n\x3cp\x3e用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。\x3c\/p\x3e\n\x3cp\x3e参考 \x3ca href=\x22https:\/\/www.zhihu.com\/question\/29504639?sort=created\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e如何理解虚拟 DOM?-zhihu\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3ereact diff 原理（常考，大厂必考）\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e把树形结构按照层级分解，只比较同级元素。\x3c\/li\x3e\n\x3cli\x3e给列表结构的每个单元添加唯一的 key 属性，方便比较。\x3c\/li\x3e\n\x3cli\x3eReact 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）\x3c\/li\x3e\n\x3cli\x3e合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\x3c\/li\x3e\n\x3cli\x3e选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e参考：\x3ca\x3eReact 的 diff 算法\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eReact 中 refs 的作用是什么？\x3c\/h3\x3e\n\x3cp\x3eRefs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class CustomForm extends Component {\n  handleSubmit = () =\x3e {\n    console.log(\x26quot;Input Value: \x26quot;, this.input.value)\n  }\n  render () {\n    return (\n      \x3cform onSubmit={this.handleSubmit}\x3e\n        \x3cinput\n          type=\x27text\x27\n          ref={(input) =\x3e this.input = input} \/\x3e\n        \x3cbutton type=\x27submit\x27\x3eSubmit\x3c\/button\x3e\n      \x3c\/form\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCustomForm\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  handleSubmit = () =\x26gt; {\n    console.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Input Value: \x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.value)\n  }\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;form onSubmit={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleSubmit}\x26gt;\n        \x26lt;input\n          \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-symbol\x22\x3e\x27tex\x3c\/span\x3et\x27\n          ref={(input) =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input = input} \/\x26gt;\n        \x26lt;button \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-symbol\x22\x3e\x27submi\x3c\/span\x3et\x27\x26gt;\x3cspan class=\x22hljs-type\x22\x3eSubmit\x3c\/span\x3e\x26lt;\/button\x26gt;\n      \x26lt;\/form\x26gt;\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function CustomForm ({handleSubmit}) {\n  let inputElement\n  return (\n    \x3cform onSubmit={() =\x3e handleSubmit(inputElement.value)}\x3e\n      \x3cinput\n        type=\x27text\x27\n        ref={(input) =\x3e inputElement = input} \/\x3e\n      \x3cbutton type=\x27submit\x27\x3eSubmit\x3c\/button\x3e\n    \x3c\/form\x3e\n  )\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCustomForm\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e{handleSubmit}\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e inputElement\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eform\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonSubmit\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e handleSubmit(inputElement.value)}\x26gt;\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e\n        \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27text\x27\x3c\/span\x3e\n        \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{(input)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e inputElement = input} \/\x26gt;\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27submit\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3eSubmit\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eform\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  )\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cTwitter username=\x27tylermcginnis33\x27\x3e\n  {(user) =\x3e user === null\n    ? \x3cLoading \/\x3e\n    : \x3cBadge info={user} \/\x3e}\n\x3c\/Twitter\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eTwitter\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eusername\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27tylermcginnis33\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  {(user) =\x26gt; user === null\n    ? \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eLoading\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    : \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eBadge\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3einfo\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{user}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e}\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eTwitter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component, PropTypes } from \x27react\x27\nimport fetchUser from \x27twitter\x27\n\/\/ fetchUser take in a username returns a promise\n\/\/ which will resolve with that username\x27s data.\nclass Twitter extends Component {\n  \/\/ finish this\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e, \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e fetchUser from \x3cspan class=\x22hljs-symbol\x22\x3e\x27twitte\x3c\/span\x3er\x27\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ fetchUser take in a username returns a promise\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ which will resolve with that username\x27s data.\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTwitter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ finish this\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children 进行调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component, PropTypes } from \x27react\x27\nimport fetchUser from \x27twitter\x27\nclass Twitter extends Component {\n  state = {\n    user: null,\n  }\n  static propTypes = {\n    username: PropTypes.string.isRequired,\n  }\n  componentDidMount () {\n    fetchUser(this.props.username)\n      .then((user) =\x3e this.setState({user}))\n  }\n  render () {\n    return this.props.children(this.state.user)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e, \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e fetchUser from \x3cspan class=\x22hljs-symbol\x22\x3e\x27twitte\x3c\/span\x3er\x27\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTwitter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {\n    user: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n  }\n  static propTypes = {\n    username: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.string.isRequired,\n  }\n  componentDidMount () {\n    fetchUser(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.username)\n      .then((user) =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({user}))\n  }\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.user)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过 Props 传递，这样父组件能够更为方便地控制子组件展示的 UI 界面。譬如产品经理让我们将原本展示的 Badge 替换为 Profile，我们可以轻易地修改下回调函数即可：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cTwitter username=\x27tylermcginnis33\x27\x3e\n  {(user) =\x3e user === null\n    ? \x3cLoading \/\x3e\n    : \x3cProfile info={user} \/\x3e}\n\x3c\/Twitter\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eTwitter\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eusername\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27tylermcginnis33\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  {(user) =\x26gt; user === null\n    ? \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eLoading\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    : \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eProfile\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3einfo\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{user}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e}\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eTwitter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e展示组件(Presentational component)和容器组件(Container component)之间有何不同\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。\x3c\/li\x3e\n\x3cli\x3e容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e类组件(Class component)和函数式组件(Functional component)之间有何不同\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态\x3c\/li\x3e\n\x3cli\x3e当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 \x27无状态组件(stateless component)\x27，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e(组件的)状态(state)和属性(props)之间有何不同\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3eState 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。\x3c\/li\x3e\n\x3cli\x3eProps(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e何为受控组件(controlled component)\x3c\/h3\x3e\n\x3cp\x3e在 HTML 中，类似 \x3ccode\x3e\x26lt;input\x26gt;\x3c\/code\x3e, \x3ccode\x3e\x26lt;textarea\x26gt;\x3c\/code\x3e 和 \x3ccode\x3e\x26lt;select\x26gt;\x3c\/code\x3e 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\x22受控元素\x22。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e何为高阶组件(higher order component)\x3c\/h3\x3e\n\x3cp\x3e高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e为什么建议传递给 setState 的参数是一个 callback 而不是一个对象\x3c\/h3\x3e\n\x3cp\x3e因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e除了在构造函数中绑定 this，还有其它方式吗\x3c\/h3\x3e\n\x3cp\x3e你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e(在构造函数中)调用 super(props) 的目的是什么\x3c\/h3\x3e\n\x3cp\x3e在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e应该在 React 组件的何处发起 Ajax 请求\x3c\/h3\x3e\n\x3cp\x3e在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3e描述事件在 React 中的处理方式。\x3c\/h3\x3e\n\x3cp\x3e为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。\x3c\/p\x3e\n\x3cp\x3e这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3ecreateElement 和 cloneElement 有什么区别？\x3c\/h3\x3e\n\x3cp\x3eReact.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React.createElement(\n    type,\n    [props],\n    [...children]\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eReact\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.createElement\x3c\/span\x3e(\n    \x3cspan class=\x22hljs-selector-tag\x22\x3etype\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-selector-attr\x22\x3e[props]\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-selector-attr\x22\x3e[...children]\x3c\/span\x3e\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React.cloneElement(\n  element,\n  [props],\n  [...children]\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eReact\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.cloneElement\x3c\/span\x3e(\n  \x3cspan class=\x22hljs-selector-tag\x22\x3eelement\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-selector-attr\x22\x3e[props]\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-selector-attr\x22\x3e[...children]\x3c\/span\x3e\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader20\x22\x3eReact 中有三种构建组件的方式\x3c\/h3\x3e\n\x3cp\x3eReact.createClass()、ES6 class 和无状态函数。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader21\x22\x3ereact 组件的划分业务组件技术组件？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e根据组件的职责通常把组件分为 UI 组件和容器组件。\x3c\/li\x3e\n\x3cli\x3eUI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。\x3c\/li\x3e\n\x3cli\x3e两者通过 React-Redux 提供 connect 方法联系起来。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader22\x22\x3e简述 flux 思想\x3c\/h3\x3e\n\x3cp\x3eFlux 的最大特点，就是数据的\x22单向流动\x22。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e用户访问 View\x3c\/li\x3e\n\x3cli\x3eView 发出用户的 Action\x3c\/li\x3e\n\x3cli\x3eDispatcher 收到 Action，要求 Store 进行相应的更新\x3c\/li\x3e\n\x3cli\x3eStore 更新后，发出一个\x22change\x22事件\x3c\/li\x3e\n\x3cli\x3eView 收到\x22change\x22事件后，更新页面\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader23\x22\x3eReact 项目用过什么脚手架（本题是开放性题目）\x3c\/h3\x3e\n\x3cp\x3ecreat-react-app Yeoman 等\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader24\x22\x3e了解 redux 么，说一下 redux 把\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3eredux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰\x3c\/li\x3e\n\x3cli\x3e新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader25\x22\x3eredux 有什么缺点\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。\x3c\/li\x3e\n\x3cli\x3e当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>常见react面试题汇总（适合中级前端）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016885832">https://segmentfault.com/a/1190000016885832</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/a78jvd7d5b7/" target="_blank">https://alili.tech/archive/a78jvd7d5b7/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>