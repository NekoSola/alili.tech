<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="动静分离的数据并发加载策略"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>动静分离的数据并发加载策略 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ltxutbyj8c/",
				"appid": "1613049289050283", 
				"title": "动静分离的数据并发加载策略 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-07T02:30:15"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/c2ekhqxwtcj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/tg3jc1r5aqi/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fltxutbyj8c%2f&text=%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b9%b6%e5%8f%91%e5%8a%a0%e8%bd%bd%e7%ad%96%e7%95%a5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fltxutbyj8c%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fltxutbyj8c%2f&text=%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b9%b6%e5%8f%91%e5%8a%a0%e8%bd%bd%e7%ad%96%e7%95%a5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fltxutbyj8c%2f&title=%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b9%b6%e5%8f%91%e5%8a%a0%e8%bd%bd%e7%ad%96%e7%95%a5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fltxutbyj8c%2f&is_video=false&description=%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b9%b6%e5%8f%91%e5%8a%a0%e8%bd%bd%e7%ad%96%e7%95%a5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b9%b6%e5%8f%91%e5%8a%a0%e8%bd%bd%e7%ad%96%e7%95%a5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fltxutbyj8c%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fltxutbyj8c%2f&title=%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b9%b6%e5%8f%91%e5%8a%a0%e8%bd%bd%e7%ad%96%e7%95%a5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fltxutbyj8c%2f&title=%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b9%b6%e5%8f%91%e5%8a%a0%e8%bd%bd%e7%ad%96%e7%95%a5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fltxutbyj8c%2f&title=%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b9%b6%e5%8f%91%e5%8a%a0%e8%bd%bd%e7%ad%96%e7%95%a5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fltxutbyj8c%2f&title=%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b9%b6%e5%8f%91%e5%8a%a0%e8%bd%bd%e7%ad%96%e7%95%a5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">动静分离的数据并发加载策略</h1><div class="meta"><div class="postdate"><time datetime="2019-02-07" itemprop="datePublished">2019-02-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cstrong\x3e作者：莫冠钊\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e转载请注明出处，保留原文链接和作者信息\x3c\/strong\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e当今许多大型网页应用尤其是\x3ccode\x3eSPA\x3c\/code\x3e均采用了\x3ccode\x3e动静分离\x3c\/code\x3e的策略。关于动静分离的描述，这里推荐一篇不错的博文 \x3ca href=\x22http:\/\/www.cnblogs.com\/sharpxiajun\/p\/4287011.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e网站静态化处理—动静分离策略\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e本人是做前端的，之前有幸与一位对性能追求极致的后端同学一起开发这种动静分离的web项目，以下将从\x3ccode\x3e传统顺序模式\x3c\/code\x3e、\x3ccode\x3e单路数据并发模式（以下简称单并发模式）\x3c\/code\x3e、\x3ccode\x3e多路数据并发模式（以下简称多路并发模式）\x3c\/code\x3e来谈谈自己对这类应用关于前端\x3ccode\x3e加载\x3c\/code\x3e方面的心得。本文中的例子均来自该项目中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e1. 传统顺序模式\x3c\/h2\x3e\n\x3cp\x3e一般情况下，浏览器首先会接收到一张静态的页面，这张页面会包含样式文件和脚本文件引用的标签（图片什么的不在这里讨论）。至于\x3ccode\x3e数据\x3c\/code\x3e哪里来，下面介绍两种方式：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3cstrong\x3e脚本请求获取\x3c\/strong\x3e  \x3cbr\x3e通常，在脚本加载完毕后，脚本会执行一段向服务端发送请求数据的代码，然后通过回调函数取出数据并做初始化工作。这一个过程为：\x3ccode\x3e请求页面\x3c\/code\x3e =\x26gt; \x3ccode\x3e渲染页面\x3c\/code\x3e =\x26gt; \x3ccode\x3e加载脚本\x3c\/code\x3e =\x26gt; \x3ccode\x3e请求数据\x3c\/code\x3e =\x26gt; \x3ccode\x3e数据与脚本一起初始化\x3c\/code\x3e =\x26gt; \x3ccode\x3e初始化完毕\x3c\/code\x3e，也就是从加载应用到启动应用是以顺序任务的形式执行。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3cstrong\x3e直接填充于隐藏标签中\x3c\/strong\x3e\x3cbr\x3e服务端也可以直接将数据填充到网页中的一个隐藏标签中再传回给客户端，也就是上面顺序中把\x3ccode\x3e获取数据\x3c\/code\x3e放在\x3ccode\x3e页面请求\x3c\/code\x3e之前。之后在脚本中直接去获取相应的\x3ccode\x3eDOM\x3c\/code\x3e中的内容也就是数据，来进行初始化工作。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e这两种方法各有优劣，因为不是本文重点，在此就直接带过。不过笔者更倾向于前者。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e1.1 工作流图\x3c\/h3\x3e\n\x3cp\x3e如果用工作流的思想去理解，大概可以为下图（第一种方式）：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzq7t\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzq7t\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e1.2 结果分析\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzorM\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzorM\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e\x3cem\x3e在这里我们只研究数据以及main.js的加载情况。\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e\x3cem\x3ebase64.css是用来存储一些小图片的base64字符串并且是允许延后加载，可以将其归为图片资源一类。\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e总体情况还是可以接受的，毕竟后端同学对缓存这一块下了很大的功夫，用户会在\x3cstrong\x3e500ms\x3c\/strong\x3e左右看到页面的内容，到了\x3cstrong\x3e600ms\x3c\/strong\x3e之后程序就可以正式启动。\x3c\/p\x3e\n\x3cp\x3e这种模式的优点是显而易见的，这种顺序加载启动模式易用性、可维护性都比较好，也能很好地发挥动静分离的特长。  \x3cbr\x3e然而，我们认为，如果将上图中数据的请求放在前面和脚本一起并发请求，也许会减少整个页面的加载和启动所需时间，而且后端同学还觉得这样的加载效果会更加\x3cstrong\x3e直观\x3c\/strong\x3e、\x3cstrong\x3e整齐\x3c\/strong\x3e……  \x3c\/p\x3e\n\x3cp\x3e于是便有了下面的研究。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e2. 单并发模式\x3c\/h2\x3e\n\x3cp\x3e要实现数据与脚本并发加载，最核心的就是要让数据不依赖于脚本进行加载，笔者所能想到的有两种：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e在头部添加一个\x3ccode\x3escript\x3c\/code\x3e，插入一段发送\x3ccode\x3eajax\x3c\/code\x3e请求的代码，向服务端发送数据请求。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e同样是添加一个\x3ccode\x3escript\x3c\/code\x3e，将其src设为数据请求的\x3ccode\x3eurl\x3c\/code\x3e来引用外部数据资源。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e单从执行效率来说，1比2还多了一步，故本文中选择2进行讨论。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e2.1难点与解决方案\x3c\/h3\x3e\n\x3ch4\x3e如何保证script标签进行外部下载时不阻塞其他资源的下载？\x3c\/h4\x3e\n\x3cp\x3e把script在head标签内。在下载script引入的外部脚本时，浏览器处于阻塞状态，网络不好或者script文件过大时，页面处于空白停顿状态，这样的体验是很不好的。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e我们一般会将脚本文件放在页面底部来降低脚本下载与运行所带来的阻塞影响，而且这样可以保证脚本中所引用的页面元素已经渲染完毕。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e而数据请求是与页面元素无关，在这里我们希望它能放在头部确保可以尽早地开始加载来达到与其它资源一起请求，但又不阻塞其他资源的下载。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e浏览器对标记有async属性的scripts会立即加载并解析，该script相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这里的解决办法则是采用\x3ccode\x3eHTML5\x3c\/code\x3e的\x3ccode\x3easync\x3c\/code\x3e属性，将其应用于数据请求相关的script上，就可以达到脚本与数据并发加载的效果。如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22script(src=\x26quot;\/Table\/Data\x26quot; type=\x26quot;text\/javascript\x26quot; async=\x26quot;async\x26quot;)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3escript\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(src=\x3cspan class=\x22hljs-string\x22\x3e\x22\/Table\/Data\x22\x3c\/span\x3e type=\x3cspan class=\x22hljs-string\x22\x3e\x22text\/javascript\x22\x3c\/span\x3e async=\x3cspan class=\x22hljs-string\x22\x3e\x22async\x22\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e在数据与脚本加载的顺序未知的情况下，如何保证正确的页面启动？\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3ejavascript\x3c\/code\x3e是一门解析性语言，当它加载完毕之后就会执行。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e此时的数据请求变成了一个script标签，也就是说，它可以变成一段与赋值相关的\x3ccode\x3ejavascript\x3c\/code\x3e代码，直接把得到的结果放在公共环境中。如果不把它变成赋值代码，基于\x3cstrong\x3e上面的引言\x3c\/strong\x3e，可能得到的数据就会变成环境中的一个\x3ccode\x3e匿名对象\x3c\/code\x3e而在之后无法再次被访问。这样一来，在脚本记载完毕就可以直接去引用这个结果进行启动页面。那么问题来了……\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e基于上面\x3ccode\x3easync\x3c\/code\x3e中阐述的方案，在实际中更多时候我们可能无法100%保证数据与脚本加载的先后顺序。资源大小的确一定程度决定了加载时间，但是网络传输也有着许多不稳定的因素。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e我们也不可能直接在任何一个\x3ccode\x3escript\x3c\/code\x3e中直接引用对方的资源（如果未加载完毕，会返回\x3ccode\x3eundefined\x3c\/code\x3e的错误）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不到万不得已，不应该使用轮询检查的方法去解决并发问题，这样的应用性能太低，和我们的初衷相违背。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e既然它们是相互依赖的关系，而且我们只需要其中一方引用另一方的资源即可完成我们所需要的启动。在这里，我们只需要让先加载完成前的把资源暴露到公共环境\x3ccode\x3ewindow\x3c\/code\x3e中，让后加载的那一方察觉到之后直接引用进行启动即可。\x3c\/p\x3e\n\x3cp\x3e对于数据与脚本，我们把它们的资源分别定为：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22left\x22\x3e名称\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e资源\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e数据\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eallData(Object)\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e存储所有的动态数据\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e脚本\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3emainInitByData(Function)\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e主引导函数\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e在数据请求里，代码为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var allData = window.allData = \x27{\x26quot;name\x26quot;:\x26quot;data\x26quot;}\x27;\n\n\/\/检查脚本的资源是否存在\nif (typeof window.mainInitByData !== \x27undefined\x27) {\n    mainInitByData(JSON.parse(allData));\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e allData = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.allData = \x3cspan class=\x22hljs-string\x22\x3e\x27{\x22name\x22:\x22data\x22}\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/检查脚本的资源是否存在\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.mainInitByData !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n    mainInitByData(\x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(allData));\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e脚本里相关的片段则为:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var mainInitByData = window.mainInitByData = function(data) {\n    \/\/TODO...\n}\n\nif (typeof window.allData !== \x27undefined\x27) {\n    mainInitByData(JSON.parse(allData));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mainInitByData = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.mainInitByData = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.allData !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n    mainInitByData(\x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(allData));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e2.2 工作流图\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzq7L\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzq7L\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e2.3 结果分析\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzpSO\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzpSO\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e不难发现，经过并行化处理之后，加载页面的效率相比于之前的顺序模式大大增加了。且页面程序也能顺利启动(这里大家可以自行尝试)。\x3c\/p\x3e\n\x3cp\x3e不料后端同学在一两个月后，又提出了希望作\x3cstrong\x3e多路数据\x3c\/strong\x3e并发请求，因为动态数据中也有部分数据\x3cstrong\x3e相对一段时间内\x3c\/strong\x3e为静态的，这部分数据可以用缓存处理，其他数据则直接从其它服务器中获取，可以进一步提高并发效率。事情变得越来越有趣，也有了下面的研究。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e3. 多路并发模式\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e3.1 “继承”单并发\x3c\/h3\x3e\n\x3cp\x3e此时，假设我们所需请求的数据共有三条A、B、C，其中A为相对静态数据，可以做出以下定义：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22left\x22\x3e名称\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e资源\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e子数据A\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eAData(Object)\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e存储A的相对静态数据\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e子数据B\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eBData(Object)\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e存储B的动态数据\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e子数据C\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3eCData(Object)\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e存储C的动态数据\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e脚本\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3emainInitByData(Function)\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e主引导函数\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e如果继续沿用单并发中的策略，脚本的相关片段代码则为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var mainInitByData = window.mainInitByData = function(dataA, dataB, dataC) {\n    \/\/TODO...\n}\n\nif (typeof window.dataA !== \x27undefined\x27 \x26amp;\x26amp; window.dataB !== \x27undefined\x27 \x26amp;\x26amp; window.dataC !== \x27undefined\x27) {\n    var dataA = JSON.parse(dataA),\n        dataB = JSON.parse(dataB),\n        dataC = JSON.parse(dataC);\n    mainInitByData(dataA, dataB, dataC);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mainInitByData = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.mainInitByData = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edataA, dataB, dataC\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.dataA !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.dataB !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.dataC !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dataA = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(dataA),\n        dataB = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(dataB),\n        dataC = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(dataC);\n    mainInitByData(dataA, dataB, dataC);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e以上数据只是一个例子，并不代表这样就可以解决这类的问题。假如有一天后端突然要求一次并发加载10条数据，代码就会变得十分冗余。\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e既然要处理并发，那么单并发的思想是可以沿用的，只是这里的方向不对。\x3c\/p\x3e\n\x3cp\x3e不妨我们换个角度思考，脚本仍然和数据进行互相检查，但是这个数据包含了所有子数据，在这里我直接将其称为父数据。那子数据之间怎么办？\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e3.2 以信号量的思想处理数据整合\x3c\/h3\x3e\n\x3cp\x3e之所以说是信号量的思想而不是信号量，因为信号量本身是\x3cstrong\x3e多线程多任务同步\x3c\/strong\x3e，而对于带有async标签里的javascript是\x3cstrong\x3e单线程异步\x3c\/strong\x3e，但不代表javascript不能利用信号量的思想，信号量的思想就是在解决处理并发问题。具体的信号量定义，请读者自行查阅。\x3c\/p\x3e\n\x3cp\x3e为了更好的描述这个借用思想的过程，先做以下定义：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e父数据与子数据之间共用一种信号量，子数据运用这种信号量进行数据的整合，而父数据应用这种信号量进行与脚本初始化启动。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e每次子数据加载完毕后，释放信号量，并把自己的数据整合到父数据中。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e假设子数据之间申请信号量的顺序未知，但必定在父数据之前。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e整合的数据以及信号量都放在一个js对象\x3ccode\x3eintegrateData\x3c\/code\x3e中，分别命名为\x3ccode\x3edata\x3c\/code\x3e、\x3ccode\x3esem\x3c\/code\x3e（其值为1-子数据数量），即\x3ccode\x3eintegrateData = {data: {}, sem: －2}\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这里可能需要对子数据的格式做一定的调整。变成以下类型，方便做整合\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\x26quot;message\x26quot;:\x26quot;success\x26quot;, \x26quot;data\x26quot;: {....\x22}}\x22\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e{\x3cspan class=\x22hljs-string\x22\x3e\x22message\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22success\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22data\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-meta\x22\x3e{....}\x3c\/span\x3e}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么对于所有子数据的处理代码为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var result = \x27JSON\x27;\nvar integrateData = window.integrateData || (window.integrateData = { data: {}, sem: 1 - 3 });\nvar onDataCallback = window.onDataCallback || (window.onDataCallback = function(result_, integrateData) {\n    function dataIsReady(integrateData) {\n        return integrateData.sem \x3e 0;\n    }\n\n    function dataReadyCallback(integrateData) {\n        integrateData.sem--;\n        \/\/父数据与脚本启动\n        var mainInitBydata = window.mainInitBydata;\n        if (typeof mainInitBydata === \x26quot;function\x26quot;) {\n            mainInitBydata(integrateData);\n        }\n        integrateData.sem\x2b\x2b;\n    }\n\n    if (dataIsReady(integrateData)) {\n        alert(\x26quot;非法请求\x26quot;);\n        return;\n    }\n    var result = result_;\n    if (typeof result_ === \x26quot;string\x26quot;) {\n        result = JSON.parse(result_);\n    }\n\n    \/\/数据整合\n    if (result.message === \x26quot;success\x26quot;) {\n        var data = result.data;\n        for (var key in data) {\n            integrateData.data[key] = data[key];\n        }\n    }\n    \/\/释放信号量\n    integrateData.sem\x2b\x2b;\n    \/\/检查信号量\n    if (dataIsReady(integrateData)) {\n        dataReadyCallback(integrateData);\n    }\n});\nonDataCallback(result, integrateData);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = \x3cspan class=\x22hljs-string\x22\x3e\x27JSON\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e integrateData = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.integrateData || (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.integrateData = { \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: {}, \x3cspan class=\x22hljs-attr\x22\x3esem\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e });\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e onDataCallback = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onDataCallback || (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onDataCallback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult_, integrateData\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edataIsReady\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eintegrateData\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e integrateData.sem \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edataReadyCallback\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eintegrateData\x3c\/span\x3e) \x3c\/span\x3e{\n        integrateData.sem--;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/父数据与脚本启动\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mainInitBydata = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.mainInitBydata;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e mainInitBydata === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e) {\n            mainInitBydata(integrateData);\n        }\n        integrateData.sem\x2b\x2b;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (dataIsReady(integrateData)) {\n        alert(\x3cspan class=\x22hljs-string\x22\x3e\x22非法请求\x22\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = result_;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e result_ === \x3cspan class=\x22hljs-string\x22\x3e\x22string\x22\x3c\/span\x3e) {\n        result = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(result_);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/数据整合\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (result.message === \x3cspan class=\x22hljs-string\x22\x3e\x22success\x22\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e data = result.data;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e data) {\n            integrateData.data[key] = data[key];\n        }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/释放信号量\x3c\/span\x3e\n    integrateData.sem\x2b\x2b;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/检查信号量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (dataIsReady(integrateData)) {\n        dataReadyCallback(integrateData);\n    }\n});\nonDataCallback(result, integrateData);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时，脚本里的相关代码则为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var mainInitByData = window.mainInitByData = function(integrateData) {\n    \/\/TODO...\n}\n\nvar integrateData = window.integrateData;\n\n\/\/这里无需担心冲突问题，因为js是单线程执行，子数据整合完毕后会直接执行父数据检查脚本资源的行为，所以sem\x3e0时，父数据处于就绪状态。\nif (integrateData \x26amp;\x26amp; integrateData.sem \x3e 0) {\n    mainInitBydata(integrateData)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mainInitByData = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.mainInitByData = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eintegrateData\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e integrateData = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.integrateData;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/这里无需担心冲突问题，因为js是单线程执行，子数据整合完毕后会直接执行父数据检查脚本资源的行为，所以sem\x26gt;0时，父数据处于就绪状态。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (integrateData \x26amp;\x26amp; integrateData.sem \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    mainInitBydata(integrateData)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e3.3 工作流图\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzq7Y\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzq7Y\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e3.4 结果分析\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzorI\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzorI\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其实效率相比单并发提高不多，主要是涉及的动态数据规模不大，而且每次发送的请求报文和响应报文都会有一定大小的报头，造成不必要的开销。但假如动态数据足够大的话，这种策略是可以起到很大的作用。同时，单并发模式中的双向检查也可以用信号量的思想实现。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e总结以上的模式，我们可以得出以下的结论：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22left\x22\x3e模式\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e效率\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e易用性\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e性能主要影响因素\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e适用场景\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e顺序\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e普通\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e容易\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e数据与程序的大小总和\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e一般的小项目\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e单并发\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e比顺序模式高\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e普通\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e数据与程序大小比例\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e大多数动静分离的网站应用\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22left\x22\x3e多路并发\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e一般比单并发高，当数据太小时效率会比单并发低\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e复杂\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e划分数据的比例\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e数据比较庞大的网站应用，尤其是数据之间按相对均匀的比例归类\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e除此以外，上述中，单并发与多路并发的一大缺陷就是代码的\x3cstrong\x3e耦合性\x3c\/strong\x3e会相对地提高，对于多路并发而言，如果子数据请求之间有\x3cstrong\x3e依赖关系\x3c\/strong\x3e，可能还要定义多种不同的信号量，不利于管理。  \x3c\/p\x3e\n\x3cp\x3e利用现有的工具比如\x3ccode\x3eEventProxy\x3c\/code\x3e，可以很好管理这些并发请求，包括任务之间的依赖关系。通过事件\x3cstrong\x3e订阅\x3c\/strong\x3e与\x3cstrong\x3e触发\x3c\/strong\x3e的形式可以让程序更好地知道当前\x3cstrong\x3e所完成的任务\x3c\/strong\x3e以触发相应的回调函数进行处理。\x3c\/p\x3e\n\x3cp\x3e希望本文可以给读者带来一定的帮助。\x3c\/p\x3e\n\x3cp\x3e最后打个小广告，欢迎follow我的github：\x3ca href=\x22https:\/\/github.com\/zero-mo\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/zero-mo\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>动静分离的数据并发加载策略</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006021626">https://segmentfault.com/a/1190000006021626</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ltxutbyj8c/" target="_blank">https://alili.tech/archive/ltxutbyj8c/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>