<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="浅谈DOMContentLoaded事件及其封装方法"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>浅谈DOMContentLoaded事件及其封装方法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/24mb5tawox4/",
				"appid": "1613049289050283", 
				"title": "浅谈DOMContentLoaded事件及其封装方法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-07T02:30:16"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jci399h5mx/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/c4j7xpt0p5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f24mb5tawox4%2f&text=%e6%b5%85%e8%b0%88DOMContentLoaded%e4%ba%8b%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%b0%81%e8%a3%85%e6%96%b9%e6%b3%95"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f24mb5tawox4%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f24mb5tawox4%2f&text=%e6%b5%85%e8%b0%88DOMContentLoaded%e4%ba%8b%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%b0%81%e8%a3%85%e6%96%b9%e6%b3%95"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f24mb5tawox4%2f&title=%e6%b5%85%e8%b0%88DOMContentLoaded%e4%ba%8b%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%b0%81%e8%a3%85%e6%96%b9%e6%b3%95"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f24mb5tawox4%2f&is_video=false&description=%e6%b5%85%e8%b0%88DOMContentLoaded%e4%ba%8b%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%b0%81%e8%a3%85%e6%96%b9%e6%b3%95"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b5%85%e8%b0%88DOMContentLoaded%e4%ba%8b%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%b0%81%e8%a3%85%e6%96%b9%e6%b3%95&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f24mb5tawox4%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f24mb5tawox4%2f&title=%e6%b5%85%e8%b0%88DOMContentLoaded%e4%ba%8b%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%b0%81%e8%a3%85%e6%96%b9%e6%b3%95"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f24mb5tawox4%2f&title=%e6%b5%85%e8%b0%88DOMContentLoaded%e4%ba%8b%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%b0%81%e8%a3%85%e6%96%b9%e6%b3%95"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f24mb5tawox4%2f&title=%e6%b5%85%e8%b0%88DOMContentLoaded%e4%ba%8b%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%b0%81%e8%a3%85%e6%96%b9%e6%b3%95"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f24mb5tawox4%2f&title=%e6%b5%85%e8%b0%88DOMContentLoaded%e4%ba%8b%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%b0%81%e8%a3%85%e6%96%b9%e6%b3%95"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">浅谈DOMContentLoaded事件及其封装方法</h1><div class="meta"><div class="postdate"><time datetime="2019-02-07" itemprop="datePublished">2019-02-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e我们在开发时，经常需要检测页面是否加载完毕，以确保脚本安全运行，下面我们就来浅谈一下检测页面是否加载完毕的那些事件们。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e1. onload 事件\x3c\/h2\x3e\n\x3cp\x3e在页面的所有资源加载完成时，window对象上会触发一个\x3ccode\x3eonload\x3c\/code\x3e事件。该事件通常被用以执行一些逻辑代码。比如，你需要通过JS去访问一个DOM。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript\x3e\n    console.log(document.getElementById(\x27name\x27).innerHTML);\n\x3c\/script\x3e\n\x3cdiv id=\x26quot;name\x26quot;\x3echengxuyuan\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e).innerHTML);\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22name\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3echengxuyuan\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码运行时肯定会报错，因为脚本执行时，id为name的\x3ccode\x3ediv\x3c\/code\x3e还没有加载完成。那么什么时机才是我们获取DOM文档的可靠时机呢？正是我们上面说道的\x3ccode\x3eonload\x3c\/code\x3e，页面的\x3ccode\x3eonload\x3c\/code\x3e触发时，证明页面文档流及资源已经完全加载完毕，此时，获取在文档流中的DOM是最“安全”的时机。我们将上述代码加以改造，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript\x3e\n    window.onload = function () {\n        console.log(document.getElementById(\x27myname\x27).innerHTML);\n    }\n\x3c\/script\x3e\n\x3cdiv id=\x26quot;myname\x26quot;\x3echengxuyuan\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27myname\x27\x3c\/span\x3e).innerHTML);\n    }\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22myname\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3echengxuyuan\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再次运行时，代码便不会报错了。因此，\x3ccode\x3eonload\x3c\/code\x3e事件的实际效果是当页面解析完DOM树，并且完成了所有图片、样式表、脚本等资源的加载后才被触发。那么问题来了，当资源过多过大时，\x3ccode\x3eonload\x3c\/code\x3e会出现比较严重的延迟问题，严重影响用户体验。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2. DOMContentLoaded 事件\x3c\/h2\x3e\n\x3cp\x3e对比上述情况，Firefox的\x3ccode\x3eDOMContentLoaded\x3c\/code\x3e事件就更加合理，该方法触发的时间更早，它在DOM内容加载完后就触发，无需等待其他资源的加载完成。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript\x3e\n    window.onload = function () {\n        console.log(\x27页面资源全部加载完毕\x27);\n    }\n    document.addEventListener(\x26quot;DOMContentLoaded\x26quot;, function(event) {\n        console.log(\x27DOM已被完全加载和解析\x27);\n    });\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27页面资源全部加载完毕\x27\x3c\/span\x3e);\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22DOMContentLoaded\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27DOM已被完全加载和解析\x27\x3c\/span\x3e);\n    });\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码的执行结果为依次打印出：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eDOM已被完全加载和解析 \x3cbr\x3e页面资源全部加载完毕\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e由此可见，\x3ccode\x3eDOMContentLoaded\x3c\/code\x3e事件能更早地捕获到DOM加载完成。\x3c\/p\x3e\n\x3cp\x3e目前，Webkit 525以上版本和Opera也包含该方法。此外，它目前已在HTML5中被标准化。但IE仍不支持\x3ccode\x3eDOMContentLoaded\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e另外，很多JavaScript框架都有document.ready功能，例如jQuery的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$(document).ready(function(){});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e$(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e).ready(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e它的核心就是\x3ccode\x3eDOMContentLoaded\x3c\/code\x3e事件，可以使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22document.addEventListener(\x26quot;DOMContentLoaded\x26quot;,function(){...},false);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3edocument.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22DOMContentLoaded\x22\x3c\/span\x3e,function()\x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e,\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e进行事件绑定，但还是需要针对IE做兼容性处理。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e3. onreadystatechange 事件\x3c\/h2\x3e\n\x3cp\x3e虽然IE不支持\x3ccode\x3eDOMContentLoaded\x3c\/code\x3e，但它支持\x3ccode\x3eonreadystatechange\x3c\/code\x3e事件，该事件的目的是提供与文档或元素的加载状态有关的信息。支持\x3ccode\x3eonreadystatechange\x3c\/code\x3e事件的每个对象都有一个\x3ccode\x3ereadyState\x3c\/code\x3e属性，可能包含下列5个值中的一个。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3euninitialized\x3c\/code\x3e(为初始化)：对象存在但尚未初始化。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eloading\x3c\/code\x3e(正在加载)：对象正在加载数据。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eloaded\x3c\/code\x3e(加载完毕)：对象加载数据完成。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3einteractive\x3c\/code\x3e(交互)：可以操作对象了，但还没有完全加载。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomplete\x3c\/code\x3e(完成)：对象已经加载完毕。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3eonreadystatechange\x3c\/code\x3e事件可以用于检测DOM是否加载完毕，当\x3ccode\x3edocument.readyState == \x27complete\x27\x3c\/code\x3e时，表示DOM加载完成。但是如果页面中有\x3ccode\x3eiframe\x3c\/code\x3e的话，会等到\x3ccode\x3eiframe\x3c\/code\x3e中的所有资源加载完才会变成\x3ccode\x3ecomplete\x3c\/code\x3e。 此时也造成了主页面的延迟。并且，经测试，即使页面中没有\x3ccode\x3eiframe\x3c\/code\x3e， 该方式也与\x3ccode\x3eonload\x3c\/code\x3e相当，依然会等到所有资源下载完毕后才触发。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e4. doScroll方法\x3c\/h2\x3e\n\x3cp\x3e不过，IE还有个特有的方法\x3ccode\x3edoScroll\x3c\/code\x3e， 通过间隔调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22document.documentElement.doScroll(\x26quot;left\x26quot;);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs abnf\x22\x3e\x3ccode\x3edocument.documentElement.doScroll(\x3cspan class=\x22hljs-string\x22\x3e\x22left\x22\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以检测DOM是否加载完成。 当页面未加载完成时，该方法会报错，直到\x3ccode\x3edoScroll\x3c\/code\x3e不再报错时，就代表DOM加载完成了。该方法更接近\x3ccode\x3eDOMContentLoaded\x3c\/code\x3e的实现。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e5. Javascript封装DOMContentLoaded事件\x3c\/h2\x3e\n\x3cp\x3e以下，是JS封装\x3ccode\x3eDOMContentLoaded\x3c\/code\x3e事件从而达到良好的兼容性的一个简单的代码实现。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function ready(fn){\n\n    \/\/ 目前Mozilla、Opera和webkit 525\x2b内核支持DOMContentLoaded事件\n    if(document.addEventListener) {\n        document.addEventListener(\x27DOMContentLoaded\x27, function() {\n            document.removeEventListener(\x27DOMContentLoaded\x27,arguments.callee, false);\n            fn();\n        }, false);\n    } \n\n    \/\/ 如果IE\n    else if(document.attachEvent) {\n        \/\/ 确保当页面是在iframe中加载时，事件依旧会被安全触发\n        document.attachEvent(\x27onreadystatechange\x27, function() {\n            if(document.readyState == \x27complete\x27) {\n                document.detachEvent(\x27onreadystatechange\x27, arguments.callee);\n                fn();\n            }\n        });\n\n        \/\/ 如果是IE且页面不在iframe中时，轮询调用doScroll 方法检测DOM是否加载完毕\n        if(document.documentElement.doScroll \x26amp;\x26amp; typeof window.frameElement === \x26quot;undefined\x26quot;) {\n            try{\n                document.documentElement.doScroll(\x27left\x27);\n            }\n            catch(error){\n                return setTimeout(arguments.callee, 20);\n            };\n            fn();\n        }\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eready\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e)\x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 目前Mozilla、Opera和webkit 525\x2b内核支持DOMContentLoaded事件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener) {\n        \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27DOMContentLoaded\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.removeEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27DOMContentLoaded\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.callee, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n            fn();\n        }, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n    } \n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果IE\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.attachEvent) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 确保当页面是在iframe中加载时，事件依旧会被安全触发\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.attachEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27onreadystatechange\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.readyState == \x3cspan class=\x22hljs-string\x22\x3e\x27complete\x27\x3c\/span\x3e) {\n                \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.detachEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27onreadystatechange\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.callee);\n                fn();\n            }\n        });\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是IE且页面不在iframe中时，轮询调用doScroll 方法检测DOM是否加载完毕\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.doScroll \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.frameElement === \x3cspan class=\x22hljs-string\x22\x3e\x22undefined\x22\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n                \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.doScroll(\x3cspan class=\x22hljs-string\x22\x3e\x27left\x27\x3c\/span\x3e);\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(error){\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setTimeout(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.callee, \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\n            };\n            fn();\n        }\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于IE，首先注册\x3ccode\x3edocument\x3c\/code\x3e的\x3ccode\x3eonreadystatechange\x3c\/code\x3e事件，这是为了避免当页面处于\x3ccode\x3eiframe\x3c\/code\x3e中时，\x3ccode\x3edoScroll\x3c\/code\x3e方法会失效，因此在实现代码中做了判断。之后，判断如果是IE并且页面不在\x3ccode\x3eiframe\x3c\/code\x3e当中， 则通过\x3ccode\x3esetTimeout\x3c\/code\x3e来不断的调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22document.documentElement.doScroll(\x27left\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.doScroll(\x3cspan class=\x22hljs-string\x22\x3e\x27left\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e直到调用成功，代表DOM加载完成。\x3c\/p\x3e\n\x3cp\x3e总结一下，开发时我们可以通过封装\x3ccode\x3eDOMContentLoaded\x3c\/code\x3e事件来检测页面DOM是否加载完毕，然后执行逻辑代码，提升用户体验。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>浅谈DOMContentLoaded事件及其封装方法</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005869515">https://segmentfault.com/a/1190000005869515</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/24mb5tawox4/" target="_blank">https://alili.tech/archive/24mb5tawox4/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>