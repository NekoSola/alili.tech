<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="精益 React 学习指南 （Lean React）- 1.6 Flux"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>精益 React 学习指南 （Lean React）- 1.6 Flux | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ublky4ul8t/",
				"appid": "1613049289050283", 
				"title": "精益 React 学习指南 （Lean React）- 1.6 Flux | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-09T02:30:59"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jgdrcc6s0p/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/g8u3ncqjfgc/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fublky4ul8t%2f&text=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.6%20Flux"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fublky4ul8t%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fublky4ul8t%2f&text=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.6%20Flux"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fublky4ul8t%2f&title=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.6%20Flux"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fublky4ul8t%2f&is_video=false&description=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.6%20Flux"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.6%20Flux&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fublky4ul8t%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fublky4ul8t%2f&title=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.6%20Flux"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fublky4ul8t%2f&title=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.6%20Flux"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fublky4ul8t%2f&title=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.6%20Flux"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fublky4ul8t%2f&title=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.6%20Flux"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">精益 React 学习指南 （Lean React）- 1.6 Flux</h1><div class="meta"><div class="postdate"><time datetime="2019-02-09" itemprop="datePublished">2019-02-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000005136764\x22\x3e书籍完整目录\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e1.6 flux\x3c\/h1\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVwBD2\x22 src=\x22https:\/\/static.alili.tech\/img\/bVwBD2\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这一节将介绍 React 的核心应用架构模式 Flux，包括内容：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eFlux 介绍\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eMVC 架构之痛\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eFlux 的理解\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eFlux 相关库和工具介绍\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eFlux 与 React 实例\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e最后我们将会把之前的 TODOMVC 改为 Flux 的架构。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e1.6.1 Flux 介绍\x3c\/h2\x3e\n\x3cp\x3e简单来讲，Flux 是 Facebook 引入到 React 中的一种前端架构，通过定义其核心单向数据流的方式，让 React 应用更加健壮。同时，这种应用架构也具有普适性，可以应用到其他任意前端项目中，甚至可以应用到客户端应用开发中，也就是说 Flux 更应该叫做一种架构模式（Pattern）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e1.6.2 MVC 架构之痛\x3c\/h2\x3e\n\x3cp\x3e在详细介绍 Flux 之前，我们先来看看传统的前端 MVC 架构以及其带来的问题。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eMVC 的实现可能有很多种方式，比较灵活，但基本本质不会改变，只是三者间的数据传递方向可能会改变，即便是 MVP 模式也只是 MVC 的变种，所以为了统一我们且以下图的 MVC 方式来讨论。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVwCjE\x22 src=\x22https:\/\/static.alili.tech\/img\/bVwCjE\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e概念\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eModel：\x3c\/strong\x3e 负责保存应用数据，和后端交互同步应用数据\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eView：\x3c\/strong\x3e 负责渲染页面 HTML DOM\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eController：\x3c\/strong\x3e 负责连接 View 和 Model ， Model 的任何改变会应用到 View 中，View 的操作会通过 Controller 应用到 Model 中\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e关系\x3c\/strong\x3e：Model, View, Controller 都是多对多关系。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e流程\x3c\/h3\x3e\n\x3cp\x3e以 TODOMVC 为例子用户添加一个 todo 的交互流程：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eView -\x26gt; Action -\x26gt; Controller -\x26gt; Model -\x26gt; View\x3c\/code\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eView -\x26gt; Action:\x3c\/strong\x3e 添加按钮事件或者 input 输入的提交事件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eAction -\x26gt; Controller:\x3c\/strong\x3e 控制器响应 View 事件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eController -\x26gt; Model:\x3c\/strong\x3e 控制器依赖 Model, 调用 Model 添加 todo\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eModel -\x26gt; View:\x3c\/strong\x3e View 监听 Model 的改变添加 todo 事件，在 HTML 中添加一个新的 Todo 视图\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e问题\x3c\/h3\x3e\n\x3cp\x3e对于新增一个 todo ，需要编写一个视图渲染处理函数，函数内添加新项目到列表中。同理对于删除一个 todo，也会有一个处理函数。当业务逻辑变多过后，可能有很多模型需要做增删改的功能，与之对应的就是我们需要精心构建这么多的渲染处理函数。 这种局部更新模式是高性能的关键所在，但问题是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e更新逻辑复杂，需要编写大量的局部渲染函数\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e问题定位困难，页面的当前状态是有数据和这些局部更新函数确定的\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e如何解决\x3c\/h3\x3e\n\x3cp\x3e如果渲染函数只有一个，统一放在 App 控制器中，每次更新\x3cstrong\x3e重渲染\x3c\/strong\x3e页面，这样的话：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e任何数据的更新都只用调用重渲染就行\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e数据和当前页面的状态是唯一确定的\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e重渲染也有弊端，会带来严重的性能问题，重渲染和局部渲染各有好坏，对 MVC 来说这是一个两难的选择，无法做到鱼和熊掌兼得。\x3c\/p\x3e\n\x3cp\x3e那如何才能兼顾两种模式的优点？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e1.6.3 Flux 架构\x3c\/h2\x3e\n\x3cp\x3e通过 \x3ccode\x3eReact \x2b Flux\x3c\/code\x3e 就可以完美解决 MVC 的问题。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e重渲染：\x3c\/strong\x3e 在 React 中每次渲染都是重渲染，且不影响页面性能，是因为重渲染的是 Virtual Dom。这就意味着完全不用去关系重渲染问题，增删改的渲染都和初始化渲染相同入口\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e数据和状态一致性：\x3c\/strong\x3e Store 的数据确定应用唯一的状态\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e简单来说在 Flux 架构中直接剥离了控制器层，\x3ccode\x3eMVC\x3c\/code\x3e 架构变成了 \x3ccode\x3eMV \x2b Flux\x3c\/code\x3e 架构。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e概念\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e单向数据流\x3c\/strong\x3e \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVwBoo\x22 src=\x22https:\/\/static.alili.tech\/img\/bVwBoo\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这是 Flux 架构的核心思想，重上面的图中可以看到，数据的流向从action 到 view 的一个单向流。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eAction\x3c\/strong\x3e \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVwBZs\x22 src=\x22https:\/\/static.alili.tech\/img\/bVwBZs\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eAction 可以理解为对应用数据修改的指令，任何修改应用数据的行为都必须需通过触发 action 来修改。Action 可以来自于 View，也可以来自服务端的数据更新。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eAction Creator\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVwB0R\x22 src=\x22https:\/\/static.alili.tech\/img\/bVwB0R\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e为了抽象 Action ，提供一些辅助的语义化的方法来创建 Action，这些辅助方法叫做 Action Creator。 \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eStores\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVwB3b\x22 src=\x22https:\/\/static.alili.tech\/img\/bVwB3b\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e应用的数据中心，所有应用数据都存放在这里控制，同时包含数据的控制行为，可能包含多个 store\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eDispatcher\x3c\/strong\x3e \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVwB3B\x22 src=\x22https:\/\/static.alili.tech\/img\/bVwB3B\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eaction 的控制者，所有 action 都会通过 dispatcher，由 dispatcher 控制 action 是否应该传入到 store 中，Dispatcher 是一个单例。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eView\x3c\/strong\x3e \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVwB3L\x22 src=\x22https:\/\/static.alili.tech\/img\/bVwB3L\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e页面的视图，对应 React 的 Component, 视图可以触发 action 到 dispatcher。\x3c\/p\x3e\n\x3cp\x3e需要区别出一种叫控制器 View（Controller View）的类型，这种 View 可以知晓 store 数据，把 store 数据转化为自身的状态，在将数据传递给其他 view 。 并且可以监听 store 数据的改变，当 store 数据改变过后重新设置状态触发重渲染。 可以将控制器 View 对应 MVC 中的控制器，但是差别很大，控制器 View 唯一多做的事情就是监听 store 数据改变，没有其他任何业务处理逻辑。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e流程\x3c\/h3\x3e\n\x3cp\x3e同样以 TODOMVC 的添加 todo 为例，Flux 中的流程为：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eView -\x26gt; Action(Action Creator -\x26gt; Action) -\x26gt; Dispatcher -\x26gt; Store -\x26gt; Controller View -\x26gt; View\x3c\/code\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eView -\x26gt; Action\x3c\/strong\x3e: 添加按钮事件或者 input 输入的提交事件，View 中将事件转化为 action, action 由 Action Creator 创建。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eAction -\x26gt; Dispatcher\x3c\/strong\x3e: action 统一由 Dispatcher 分配\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eDispatcher -\x26gt; Store\x3c\/strong\x3e: Dispatcher 分配 action 到 Store\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eStore -\x26gt; Controller View\x3c\/strong\x3e: 控制器 View 监听 store 的数据改变，将数据转化为自身属性\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eController View -\x26gt; View\x3c\/strong\x3e: 数据改变自动重渲染所有视图\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e对比\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e渲染策略：\x3c\/strong\x3e 数据改变 Flux 自动渲染，MVC 手动编写更新函数\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e事件触发策略：\x3c\/strong\x3e Flux 中所有 action 交给 dispather  分配，MVC 中交给对应的控制器分配\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eFlux 在核心策略上的不同是解决 MVC 架构问题的关键\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e1.6.4 理解 Flux 架构\x3c\/h2\x3e\n\x3cp\x3eFlux 架构是非常优雅简洁的，合理利用了一些优秀的架构思维\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e分而治之（Divide And Conquer）\x3c\/h3\x3e\n\x3cp\x3e数据的处理过程是 \x3ccode\x3eStore -\x26gt; Controller View -\x26gt; View\x3c\/code\x3e。 所有数据来自于 Store，页面的渲染层级为 Store 将数据传入 Controller View, 再由 Controller View 传入子 View , 一直到 View 的叶子节点。\x3c\/p\x3e\n\x3cp\x3e这个是一个典型的分而治之策略，将大的页面拆分为小的模块，再由小的模块拆分为小的组件，具体组件负者组件自身的问题，所有子组件都是自私的，不用关心“大家”，只用关心“小家”。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e合而治之 - 中心化控制\x3c\/h3\x3e\n\x3cp\x3eFlux 把所有的 View 都视作愚民，Store 视作资源的拥有者为统治者，统治者需要提供资源（数据）给平民，但是如果平民企图对资源修改（Mutation），必须得先通知给统治者，让统治者决定是否做处理。 \x3c\/p\x3e\n\x3cp\x3e我们为 Flux 中的概念分配角色\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eView: 平民\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eAction: 资源修改操作\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eDispatcher: 审核官\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eStore: 统治者\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e一个企图修改资源的操作可以描述为： \x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eView Require Mutation -\x26gt; Action -\x26gt; Dispatcher -\x26gt; Store -\x26gt; Mutate Handler\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e平民提交 Mutation 请求，由审核官控制，审核通过后递交给统治者，统治者再分配给亲信做资源 Mutation\x3c\/p\x3e\n\x3cp\x3e合而治之的策略也等于中心化控制策略， 作为统治者既要懂得放权利（资源的分配），也要懂得控制权利（资源的修改），这种收缩自如的合理性是 Flux 简洁的根本。\x3c\/p\x3e\n\x3cp\x3e同时这种思维带来的优点如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eView 的独立性和简单性：View 自身的逻辑简单，不需要知道太多事情，只关心上级传来的数据，这种模式使得 View 是低耦合的，简洁的。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e高可维护性：中心化控制知道所有对资源的操作，如果发生 bug, 可以很快定位问题\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e函数式编程思想\x3c\/h3\x3e\n\x3cp\x3e在 Flux 中数据的单向流动依赖于 View 的确定性，相同的数据传入相同的组件，得到的结果必然要相同，这是函数式编程的思想。\x3c\/p\x3e\n\x3cp\x3e函数式编程中的纯函数（Pure Function）定义如下：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n\/\/ 纯函数，相同的输入必定有相同的输出\nfunction pure(a, b, c) {\n    return a \x2b b \x2b c;\n}\n\n\/\/ 非纯函数，我们永远无法确定 this.a 会变成什么\nfunction notPure(b, c) {\n    return this.a \x2b b \x2b c;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 纯函数，相同的输入必定有相同的输出\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epure\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea, b, c\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a \x2b b \x2b c;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 非纯函数，我们永远无法确定 this.a 会变成什么\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enotPure\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eb, c\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a \x2b b \x2b c;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了保证组件也能做到 “纯函数” 的特性，相同的属性会得到相同的渲染结果。 在写 React 组件的时候尽量准守一下约定：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e尽量使用无状态组件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e除了控制类组件以外其他组件避免使用组件状态\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e可以通过属性计算出来的状态不要用状态来表示\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件的渲染避免外部依赖，按照纯函数的方式写\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e函数式的优点也是无副作用组件的优点:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e无耦合，可移植性强: 组件可重用性高\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e可测试性高：组件无依赖，可以很容易的单独测试组件\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e1.6.5 Flux 生态\x3c\/h2\x3e\n\x3cp\x3e上面已经讲过 Flux 更应该算是 Facebook 提出的一种前端架构模式，而根据这种理念的 Flux 实现有很多，以下是 github star 数较高的一些实现：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/facebook\/flux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFacebook 官方实现\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/redux.js.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRedux\x3c\/a\x3e 目前认可度最高的实现\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/reflux\/refluxjs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erefluxjs\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/goatslacker\/alt\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ealt\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/fluxxor.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3efluxxor\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e后面我们会在第四章中专门讲解 Redux 与 React 的应用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3e1.6.6 Flux 与 React 实例\x3c\/h2\x3e\n\x3cp\x3e@todo\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>精益 React 学习指南 （Lean React）- 1.6 Flux</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005348206">https://segmentfault.com/a/1190000005348206</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ublky4ul8t/" target="_blank">https://alili.tech/archive/ublky4ul8t/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>