<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="一个浏览器和NodeJS通用的RPC框架"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>一个浏览器和NodeJS通用的RPC框架 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/chet2fs7ml5/",
				"appid": "1613049289050283", 
				"title": "一个浏览器和NodeJS通用的RPC框架 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-10T02:30:42"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/6xskr0p1brp/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/tzdcntkt56m/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fchet2fs7ml5%2f&text=%e4%b8%80%e4%b8%aa%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNodeJS%e9%80%9a%e7%94%a8%e7%9a%84RPC%e6%a1%86%e6%9e%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fchet2fs7ml5%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fchet2fs7ml5%2f&text=%e4%b8%80%e4%b8%aa%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNodeJS%e9%80%9a%e7%94%a8%e7%9a%84RPC%e6%a1%86%e6%9e%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fchet2fs7ml5%2f&title=%e4%b8%80%e4%b8%aa%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNodeJS%e9%80%9a%e7%94%a8%e7%9a%84RPC%e6%a1%86%e6%9e%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fchet2fs7ml5%2f&is_video=false&description=%e4%b8%80%e4%b8%aa%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNodeJS%e9%80%9a%e7%94%a8%e7%9a%84RPC%e6%a1%86%e6%9e%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b8%80%e4%b8%aa%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNodeJS%e9%80%9a%e7%94%a8%e7%9a%84RPC%e6%a1%86%e6%9e%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fchet2fs7ml5%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fchet2fs7ml5%2f&title=%e4%b8%80%e4%b8%aa%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNodeJS%e9%80%9a%e7%94%a8%e7%9a%84RPC%e6%a1%86%e6%9e%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fchet2fs7ml5%2f&title=%e4%b8%80%e4%b8%aa%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNodeJS%e9%80%9a%e7%94%a8%e7%9a%84RPC%e6%a1%86%e6%9e%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fchet2fs7ml5%2f&title=%e4%b8%80%e4%b8%aa%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNodeJS%e9%80%9a%e7%94%a8%e7%9a%84RPC%e6%a1%86%e6%9e%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fchet2fs7ml5%2f&title=%e4%b8%80%e4%b8%aa%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8cNodeJS%e9%80%9a%e7%94%a8%e7%9a%84RPC%e6%a1%86%e6%9e%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">一个浏览器和NodeJS通用的RPC框架</h1><div class="meta"><div class="postdate"><time datetime="2019-02-10" itemprop="datePublished">2019-02-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e欢迎关注我的知乎专栏： \x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/starkwang\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/zhuanlan.zhihu.com\/starkwang\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/starkwang\/Maus\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3estarkwang\/Maus: A Simple JSON-RPC Framework running in NodeJS or Browser, based on websocket.\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e这几天写了个小型的RPC框架，最初只是想用 TCP-JSON 写个纯 NodeJS 平台的东西，后来无意中开了个脑洞，如果基于 Websocket 把浏览器当做 RPC Server ，那岂不是只要是能运行浏览器（或者nodejs）的设备，都可以作为分布式计算中的一个 Worker 了吗？\x3c\/p\x3e\n\x3cp\x3e打开一张网页，就能成为分布式计算的一个节点，看起来还是挺酷炫的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e一、什么是RPC\x3c\/h2\x3e\n\x3cp\x3e可以参考：\x3ca href=\x22https:\/\/www.zhihu.com\/question\/25536695\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e谁能用通俗的语言解释一下什么是RPC框架？ - 知乎\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e简单地说就是你可以这样注册一个任意数量的\x3ccode\x3eworker\x3c\/code\x3e（姑且叫这个名字好了），它里面声明了具体的方法实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var rpcWorker = require(\x27maus\x27).worker;\nrpcWorker.create({\n    add: (x, y) =\x3e x \x2b y\n}, \x27http:\/\/192.168.1.100:8124\x27);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rpcWorker = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27maus\x27\x3c\/span\x3e).worker;\nrpcWorker.create({\n    \x3cspan class=\x22hljs-attr\x22\x3eadd\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ex, y\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e x \x2b y\n}, \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/192.168.1.100:8124\x27\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后你可以在另一个node进程里这样调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var rpcManager = require(\x27maus\x27).manager;\nrpcManager.create(workers =\x3e {\n    workers.add(1, 2, result =\x3e console.log(result));\n}, 8124)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rpcManager = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27maus\x27\x3c\/span\x3e).manager;\nrpcManager.create(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eworkers\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    workers.add(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, result =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result));\n}, \x3cspan class=\x22hljs-number\x22\x3e8124\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们封装了底层的通信细节（可以是tcp、http、websocket等等）和任务分配，只需要用异步的方式去调用\x3ccode\x3eworker\x3c\/code\x3e提供的方法即可，通过这个我们可以轻而易举地做到分布式计算的\x3ccode\x3emap\x3c\/code\x3e和\x3ccode\x3ereduce\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22rpcManager.create(workers =\x3e {\n    \/\/首先定义一个promise化的add\n    var add = function(x, y){\n        return new Promise((resolve, reject)=\x3e{\n            workers.add(x, y, result =\x3e resolve(result));\n        })\n    }\n    \/\/map\x26amp;reduce\n    Promise.all([add(1,2), add(3,4), add(4,5)])\n        .then(result =\x3e result.reduce((x, y) =\x3e x \x2b y))\n        .then(sum =\x3e console.log(sum)) \/\/19\n}, 8124)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3erpcManager.create(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eworkers\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/首先定义一个promise化的add\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e add = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex, y\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n            workers.add(x, y, result =\x26gt; resolve(result));\n        })\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/map\x26amp;reduce\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([add(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), add(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e), add(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e)])\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e =\x26gt;\x3c\/span\x3e result.reduce(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ex, y\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e x \x2b y))\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3esum\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sum)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/19\x3c\/span\x3e\n}, \x3cspan class=\x22hljs-number\x22\x3e8124\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们有三个已经注册的\x3ccode\x3eWorker\x3c\/code\x3e（可能是本地的另一个nodejs进程、某个设备上的浏览器、另一个机器上的nodejs），那么我们这里会分别在这三个机器上分别计算三个\x3ccode\x3eadd\x3c\/code\x3e，并且将三个结果在本地相加，得到最后的值，这就是分布式计算的基础。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e二、Manager的实现\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e0、通信标准\x3c\/h3\x3e\n\x3cp\x3e要实现双向的通信，我们首先要定义这样一个“远程调用”的通信标准，在我的实现中比较简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    [id]: uuid          \/\/在某些通信中需要唯一标识码\n    message: \x27......\x27   \/\/消息类别\n    body: ......        \/\/携带的数据\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n    [id]: uuid          \x3cspan class=\x22hljs-comment\x22\x3e\/\/在某些通信中需要唯一标识码\x3c\/span\x3e\n    message: \x3cspan class=\x22hljs-string\x22\x3e\x27......\x27\x3c\/span\x3e   \x3cspan class=\x22hljs-comment\x22\x3e\/\/消息类别\x3c\/span\x3e\n    body: ......        \x3cspan class=\x22hljs-comment\x22\x3e\/\/携带的数据\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e1、初始化\x3c\/h3\x3e\n\x3cp\x3e首先我们要解决的问题是，如何让\x3ccode\x3eManager\x3c\/code\x3e知道\x3ccode\x3eWorker\x3c\/code\x3e提供了哪些方法可供调用？\x3c\/p\x3e\n\x3cp\x3e这个问题其实很简单，只要在 websocket 建立的时刻发送一个\x3ccode\x3einit\x3c\/code\x3e消息就可以了，\x3ccode\x3einit\x3c\/code\x3e消息大概长这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    message: \x27init\x27,\n    body: [\x27add\x27, \x27multiply\x27] \/\/body是方法名组成的数组\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27init\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ebody\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27add\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27multiply\x27\x3c\/span\x3e] \x3cspan class=\x22hljs-comment\x22\x3e\/\/body是方法名组成的数组\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同时，我们要将\x3ccode\x3eManager\x3c\/code\x3e传入的回调函数，记录到\x3ccode\x3eManager.__workersStaticCallback\x3c\/code\x3e中，以便延迟调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22manager.create(callback, port) \/\/记录下这个callback\n\n\/\/一段时间后。。。。。。\n\nmanager.start() \/\/任务开始\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3emanager.create(callback, port) \x3cspan class=\x22hljs-comment\x22\x3e\/\/记录下这个callback\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/一段时间后。。。。。。\x3c\/span\x3e\n\nmanager.start() \x3cspan class=\x22hljs-comment\x22\x3e\/\/任务开始\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e2、生成workers实例\x3c\/h3\x3e\n\x3cp\x3e现在我们的\x3ccode\x3eManager\x3c\/code\x3e收到了一个远程可调用的方法名组成的数组，我们接下来需要在\x3ccode\x3eManager\x3c\/code\x3e中生成一个\x3ccode\x3eworkers\x3c\/code\x3e实例，它应该包含所有这些方法名，但底层依然是调用一个webpack通信。这里我们可以用类似元编程的奇技淫巧，下面的是部分代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/收到worker发来的init消息之后\nvar workers = {\n    __send: this.__send.bind(this), \/\/这个this指向Manager，而不是自己\n    __functionCall: this.__functionCall.bind(this) \/\/同上\n};\nvar funcNames = data.body; \/\/比如[\x27add\x27, \x27multiply\x27]\nfuncNames.forEach(funcName =\x3e {\n    \/\/使用new Function的奇技淫巧\n    rpc[funcName] = new Function(`\n        \/\/截取参数\n        var params = Array.prototype.slice.call(arguments,0,arguments.length-1);\n        var callback = arguments[arguments.length-1];\n        \n        \/\/这个__functionCall调用了Manager底层的通信，具体在后面解释\n        this.__functionCall(\x27${funcName}\x27,params,callback);\n    `)\n})\n\/\/将workers注册到Manager内部\nthis.__workers = workers;\n\/\/如果此时Manager已经在等待开始了，那么开始任务\nif (this.__waitingForInit) {\n    this.start();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/收到worker发来的init消息之后\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e workers = {\n    \x3cspan class=\x22hljs-attr\x22\x3e__send\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__send.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e), \x3cspan class=\x22hljs-comment\x22\x3e\/\/这个this指向Manager，而不是自己\x3c\/span\x3e\n    __functionCall: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__functionCall.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/同上\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e funcNames = data.body; \x3cspan class=\x22hljs-comment\x22\x3e\/\/比如[\x27add\x27, \x27multiply\x27]\x3c\/span\x3e\nfuncNames.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3efuncName\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/使用new Function的奇技淫巧\x3c\/span\x3e\n    rpc[funcName] = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e`\n        \/\/截取参数\n        var params = Array.prototype.slice.call(arguments,0,arguments.length-1);\n        var callback = arguments[arguments.length-1];\n        \n        \/\/这个__functionCall调用了Manager底层的通信，具体在后面解释\n        this.__functionCall(\x27\x3cspan class=\x22hljs-subst\x22\x3e${funcName}\x3c\/span\x3e\x27,params,callback);\n    `\x3c\/span\x3e)\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/将workers注册到Manager内部\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__workers = workers;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/如果此时Manager已经在等待开始了，那么开始任务\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__waitingForInit) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.start();\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还记得上面我们有个\x3ccode\x3estart\x3c\/code\x3e方法么？它是这样写的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22start: function() {\n    if (this.__workers != undefined) {\n        \/\/如果初始化完毕，workers实例存在\n        this.__workersStaticCallback(this.__workers);\n        this.__waitingForInit = false;\n    } else {\n        \/\/否则将等待初始化完毕\n        this.__waitingForInit = true;\n    }\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3estart: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__workers != \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果初始化完毕，workers实例存在\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__workersStaticCallback(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__workers);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__waitingForInit = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/否则将等待初始化完毕\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__waitingForInit = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    }\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e3、序列化\x3c\/h3\x3e\n\x3cp\x3e如果只是单个\x3ccode\x3eWorker\x3c\/code\x3e和单个\x3ccode\x3eManager\x3c\/code\x3e，并且远程方法都是同步而非异步的，那么我们显然不需要考虑返回值顺序的问题：\x3c\/p\x3e\n\x3cp\x3e比如我们的\x3ccode\x3eManager\x3c\/code\x3e调用了下面一堆方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22workers.add(1, 1, callback);\nworkers.add(2, 2, callback);\nworkers.add(3, 3, callback);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3eworkers.add(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, callback);\nworkers.add(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, callback);\nworkers.add(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, callback);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于\x3ccode\x3eWorker\x3c\/code\x3e中\x3ccode\x3eadd\x3c\/code\x3e的是同步的方法，那么显然我们收到返回值的顺序是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x222\n4\n6\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但如果\x3ccode\x3eWorker\x3c\/code\x3e中存在一个异步调用，那么这个顺序就会被打乱：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22workers.readFile(\x27xxx\x27, callback);\nworkers.add(1, 1, callback);\nworkers.add(2, 2, callback);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3eworkers.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27xxx\x27\x3c\/span\x3e, callback)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nworkers.\x3cspan class=\x22hljs-keyword\x22\x3eadd(1, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, callback)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nworkers.\x3cspan class=\x22hljs-keyword\x22\x3eadd(2, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, callback)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e显然我们收到的返回值顺序是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x222\n4\ncontent of xxx\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\ncontent of xxx\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以这里就需要对发出的函数调用做一个序列化，具体的方法就是对于每一个调用都给一个uuid（唯一标识码）。\x3c\/p\x3e\n\x3cp\x3e比如我们调用了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22workers.add(1, 1, stupid_callback);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eworkers.add(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, stupid_callback);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么首先\x3ccode\x3eManager\x3c\/code\x3e会对这个调用生成一个 uuid ：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x229557881b-25d7-4c94-84c8-2463c53b67f4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-number\x22\x3e9557881\x3c\/span\x3eb\x3cspan class=\x22hljs-number\x22\x3e-25\x3c\/span\x3ed7\x3cspan class=\x22hljs-number\x22\x3e-4\x3c\/span\x3ec94\x3cspan class=\x22hljs-number\x22\x3e-84\x3c\/span\x3ec8\x3cspan class=\x22hljs-number\x22\x3e-2463\x3c\/span\x3ec53b67f4\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后在\x3ccode\x3e__callbackStore\x3c\/code\x3e中将这个 uuid 和\x3ccode\x3estupid_callback \x3c\/code\x3e绑定，然后向选中的某个\x3ccode\x3eWorker\x3c\/code\x3e发送函数调用信息（具体怎么选\x3ccode\x3eWorker\x3c\/code\x3e我们后面再说）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    id: \x279557881b-25d7-4c94-84c8-2463c53b67f4\x27,\n    message: \x27function call\x27,\n    body: { \n        funcName: \x27add\x27, \n        params: [1, 1] \n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x279557881b-25d7-4c94-84c8-2463c53b67f4\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27function call\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ebody\x3c\/span\x3e: { \n        \x3cspan class=\x22hljs-attr\x22\x3efuncName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27add\x27\x3c\/span\x3e, \n        \x3cspan class=\x22hljs-attr\x22\x3eparams\x3c\/span\x3e: [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] \n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eWorker\x3c\/code\x3e执行这个函数之后，发送回来一个函数返回值的信息体，大概是这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    id: \x279557881b-25d7-4c94-84c8-2463c53b67f4\x27,\n    message: \x27function call\x27,\n    body: { \n        result: 2 \n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x279557881b-25d7-4c94-84c8-2463c53b67f4\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27function call\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ebody\x3c\/span\x3e: { \n        \x3cspan class=\x22hljs-attr\x22\x3eresult\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后我们就可以在\x3ccode\x3e__callbackStore\x3c\/code\x3e中找到这个 uuid 对应的 callback ，并且执行它：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.__callbackStore[id](result);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__callbackStore[id](result);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这就是\x3ccode\x3eworkers.add(1, 1, stupid_callback)\x3c\/code\x3e这行代码背后的原理。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e4、任务分配\x3c\/h3\x3e\n\x3cp\x3e如果存在多个\x3ccode\x3eWorker\x3c\/code\x3e，显然我们不能把所有的调用都傻傻地发送到第一个\x3ccode\x3eWorker\x3c\/code\x3e身上，所以这里就需要有一个任务分配机制，我的机制比较简单，大概说就是在一张表里对每个\x3ccode\x3eWorker\x3c\/code\x3e记录下它是否繁忙的状态，每次当有调用需求的时候，先遍历这张表，\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e如果找到有空闲的\x3ccode\x3eWorker\x3c\/code\x3e，那么就将对它发送调用；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果所有\x3ccode\x3eWorker\x3c\/code\x3e都繁忙，那么先把这个调用暂存在一个队列之中；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当收到某个\x3ccode\x3eWorker\x3c\/code\x3e的返回值后，会检查队列中是否有任务，有的话，那么就对这个\x3ccode\x3eWorker\x3c\/code\x3e发送最前的函数调用，若没有，就把这个\x3ccode\x3eWorker\x3c\/code\x3e设为空闲状态。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e具体任务分配的代码比较冗余，分散在各个方法内，所以只介绍方法，就不贴上来了\/w\\\x3c\/p\x3e\n\x3cp\x3e全部的Manager代码在这里（抱歉还没时间补注释）：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/starkwang\/Maus\/blob\/master\/src\/manager.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMaus\/manager.js at master · starkwang\/Maus\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e三、Worker的实现\x3c\/h2\x3e\n\x3cp\x3e这里要再说一遍，我们的RPC框架是基于websocket的，所以\x3ccode\x3eWorker\x3c\/code\x3e可以是一个PC浏览器！！！可以是一个手机浏览器！！！可以是一个平板浏览器！！！\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eWorker\x3c\/code\x3e的实现远比\x3ccode\x3eManager\x3c\/code\x3e简单，因为它只需要对唯一一个\x3ccode\x3eManager\x3c\/code\x3e通信，它的逻辑只有：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e接收\x3ccode\x3eManager\x3c\/code\x3e发来的数据；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e根据数据做出相应的反应（函数调用、初始化等等）；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e发送返回值\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e所以我们也不放代码了，有兴趣的可以看这里：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/starkwang\/Maus\/blob\/master\/src\/worker.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMaus\/worker.js at master · starkwang\/Maus\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e四、写一个分布式算法\x3c\/h2\x3e\n\x3cp\x3e假设我们的加法是通过这个框架异步调用的，那么我们该怎么写算法呢？\x3c\/p\x3e\n\x3cp\x3e在单机情况下，写个斐波拉契数列简直跟喝水一样简单（事实上这种暴力递归的写法非常非常傻逼且性能低下，只是作为范例演示用）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fib = x =\x3e x\x3e1 ? fib(x-1)\x2bfib(x-2) : x\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fib = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e =\x26gt;\x3c\/span\x3e x\x26gt;\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ? fib(x\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e)\x2bfib(x\x3cspan class=\x22hljs-number\x22\x3e-2\x3c\/span\x3e) : x\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是在分布式环境下，我们要将\x3ccode\x3eworkers.add\x3c\/code\x3e方法封装成一个Promise化的\x3ccode\x3eadd\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/这里的x, y可能是数字，也可能是个Promise，所以要先调用Promise.all\nvar add = function(x, y){\n    return Promise.all([x, y])\n        .then(arr =\x3e new Promise((resolve, reject) =\x3e {\n            workers.add(arr[0], arr[1], result =\x3e resolve(result));\n        }))\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/这里的x, y可能是数字，也可能是个Promise，所以要先调用Promise.all\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e add = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex, y\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([x, y])\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n            workers.add(arr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e], arr[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], result =\x26gt; resolve(result));\n        }))\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后我们就可以用类似同步的递归方法这样写一个分布式的\x3ccode\x3efib\x3c\/code\x3e算法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fib = x =\x3e x\x3e1 ? add(fib(x-1), fib(x-2)) : x;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fib = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e =\x26gt;\x3c\/span\x3e x\x26gt;\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ? add(fib(x\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e), fib(x\x3cspan class=\x22hljs-number\x22\x3e-2\x3c\/span\x3e)) : x;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后你可以尝试用你的电脑里、树莓派里、服务器里的nodejs、手机平板上的浏览器作为一个\x3ccode\x3eWorker\x3c\/code\x3e，总之集合所有的计算能力，一起来计算这个傻傻的算法（事实上相比于单机算法会慢很多很多，因为通信上的延迟远大于单机的加法计算，但只是为了演示啦）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/分布式计算fib(40)\nfib(40).then(result =\x3e console.log(result));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/分布式计算fib(40)\x3c\/span\x3e\nfib(\x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result));\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>一个浏览器和NodeJS通用的RPC框架</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005102984">https://segmentfault.com/a/1190000005102984</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/chet2fs7ml5/" target="_blank">https://alili.tech/archive/chet2fs7ml5/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>