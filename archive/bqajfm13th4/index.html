<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="深入 JavaScript 原型继承原理——babel 编译码解读"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>深入 JavaScript 原型继承原理——babel 编译码解读 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bqajfm13th4/",
				"appid": "1613049289050283", 
				"title": "深入 JavaScript 原型继承原理——babel 编译码解读 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-15T02:30:44"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/q1igixrc10l/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/rewq4piamzm/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbqajfm13th4%2f&text=%e6%b7%b1%e5%85%a5%20JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e5%8e%9f%e7%90%86%e2%80%94%e2%80%94babel%20%e7%bc%96%e8%af%91%e7%a0%81%e8%a7%a3%e8%af%bb"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbqajfm13th4%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbqajfm13th4%2f&text=%e6%b7%b1%e5%85%a5%20JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e5%8e%9f%e7%90%86%e2%80%94%e2%80%94babel%20%e7%bc%96%e8%af%91%e7%a0%81%e8%a7%a3%e8%af%bb"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbqajfm13th4%2f&title=%e6%b7%b1%e5%85%a5%20JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e5%8e%9f%e7%90%86%e2%80%94%e2%80%94babel%20%e7%bc%96%e8%af%91%e7%a0%81%e8%a7%a3%e8%af%bb"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbqajfm13th4%2f&is_video=false&description=%e6%b7%b1%e5%85%a5%20JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e5%8e%9f%e7%90%86%e2%80%94%e2%80%94babel%20%e7%bc%96%e8%af%91%e7%a0%81%e8%a7%a3%e8%af%bb"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b7%b1%e5%85%a5%20JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e5%8e%9f%e7%90%86%e2%80%94%e2%80%94babel%20%e7%bc%96%e8%af%91%e7%a0%81%e8%a7%a3%e8%af%bb&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbqajfm13th4%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbqajfm13th4%2f&title=%e6%b7%b1%e5%85%a5%20JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e5%8e%9f%e7%90%86%e2%80%94%e2%80%94babel%20%e7%bc%96%e8%af%91%e7%a0%81%e8%a7%a3%e8%af%bb"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbqajfm13th4%2f&title=%e6%b7%b1%e5%85%a5%20JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e5%8e%9f%e7%90%86%e2%80%94%e2%80%94babel%20%e7%bc%96%e8%af%91%e7%a0%81%e8%a7%a3%e8%af%bb"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbqajfm13th4%2f&title=%e6%b7%b1%e5%85%a5%20JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e5%8e%9f%e7%90%86%e2%80%94%e2%80%94babel%20%e7%bc%96%e8%af%91%e7%a0%81%e8%a7%a3%e8%af%bb"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbqajfm13th4%2f&title=%e6%b7%b1%e5%85%a5%20JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e5%8e%9f%e7%90%86%e2%80%94%e2%80%94babel%20%e7%bc%96%e8%af%91%e7%a0%81%e8%a7%a3%e8%af%bb"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">深入 JavaScript 原型继承原理——babel 编译码解读</h1><div class="meta"><div class="postdate"><time datetime="2019-02-15" itemprop="datePublished">2019-02-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e在[上一篇文章][]中，我们提到 ES6 的 \x3ccode\x3eclass\x3c\/code\x3e 语法糖是个近乎完美的方案，并且讲解了实现继承的许多内部机制，如 \x3ccode\x3eprototype\x3c\/code\x3e\/\x3ccode\x3e__proto__\x3c\/code\x3e\/\x3ccode\x3econstructor\x3c\/code\x3e 等等。这篇，我们就以实际的 babel 代码为例子，来验证上节所言不虚。此外，本文还解释了 React 组件中你需要 \x3ccode\x3ebind\x3c\/code\x3e 一下类方法的原理所在。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e目录\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e无继承——简单的 \x3ccode\x3eclass\x3c\/code\x3e \x2b 字段声明\x3c\/li\x3e\n\x3cli\x3e无继承——简单的 \x3ccode\x3eclass\x3c\/code\x3e \x2b 方法声明\x3c\/li\x3e\n\x3cli\x3e简单继承——一层继承 \x2b 字段覆盖\x3c\/li\x3e\n\x3cli\x3e无继承——静态函数\x3c\/li\x3e\n\x3cli\x3e无继承——静态变量\x3c\/li\x3e\n\x3cli\x3e神秘的类 arrow function\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e无继承——简单的 \x3ccode\x3eclass\x3c\/code\x3e \x2b 字段声明\x3c\/h2\x3e\n\x3cp\x3e先来看个最简单的例子，我们仅仅使用了 \x3ccode\x3eclass\x3c\/code\x3e 关键字并定义了一个变量：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Animal {\n  constructor(name) {\n    this.name = name || \x27Kat\x27\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name || \x3cspan class=\x22hljs-string\x22\x3e\x27Kat\x27\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后 \x3ca href=\x22https:\/\/babeljs.io\/repl\/#?babili=false\x26amp;browsers=\x26amp;build=\x26amp;builtIns=false\x26amp;spec=false\x26amp;loose=false\x26amp;code_lz=Q\x26amp;debug=false\x26amp;forceAllTransforms=false\x26amp;shippedProposals=false\x26amp;circleciRepo=\x26amp;evaluate=true\x26amp;fileSize=false\x26amp;timeTravel=false\x26amp;sourceType=module\x26amp;lineWrap=true\x26amp;presets=es2015%2Ces2017%2Creact%2Cstage-0%2Cstage-3\x26amp;prettier=false\x26amp;targets=\x26amp;version=6.26.0\x26amp;envVersion=\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ebabel 编译出来\x3c\/a\x3e的代码如下。这里笔者用的是 Babel 6 的稳定版 6.26，不同版本编译出来可能有差异，但不至于有大的结构变动。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\x27Cannot call a class as a function\x27)\n  }\n}\n\nvar Animal = function Animal(name) {\n  _classCallCheck(this, Animal)\n\n  this.name = name || \x27Kat\x27\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_classCallCheck\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einstance, Constructor\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(instance \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Constructor)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Cannot call a class as a function\x27\x3c\/span\x3e)\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Animal = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  _classCallCheck(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, Animal)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name || \x3cspan class=\x22hljs-string\x22\x3e\x27Kat\x27\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e确实十分简单，对吧。这段代码值得留意的点有两个：\x3c\/p\x3e\n\x3cp\x3e一个是，使用 \x3ccode\x3eclass\x3c\/code\x3e 声明的 \x3ccode\x3eAnimal\x3c\/code\x3e 最后其实是被编译为一个函数。证明 \x3ccode\x3eclass\x3c\/code\x3e 跟类没关系，只是个语法糖。\x3c\/p\x3e\n\x3cp\x3e另一个地方是，编译器帮我们插入了一个 \x3ccode\x3e_classCallCheck\x3c\/code\x3e 函数调用，它会检查你有没有用 \x3ccode\x3enew Animal()\x3c\/code\x3e 操作符来初始化这个函数。若有，则 \x3ccode\x3ethis\x3c\/code\x3e 会是被实例化的 \x3ccode\x3eAnimal\x3c\/code\x3e 对象，自然能通过 \x3ccode\x3eanimal instanceof Animal\x3c\/code\x3e 检查；若是直接调用函数，\x3ccode\x3ethis\x3c\/code\x3e 会被初始化为全局对象，自然不会是 \x3ccode\x3eAnimal\x3c\/code\x3e 实例，从而抛出运行时错误。这个检查，正解决了[上一篇文章][]提到的问题：如果忘记使用 \x3ccode\x3enew\x3c\/code\x3e 去调用一个被设计构造函数的函数，没有任何运行时错误的毛病。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e无继承——简单的 \x3ccode\x3eclass\x3c\/code\x3e \x2b 方法声明\x3c\/h2\x3e\n\x3cp\x3e让我们再扩展一下例子，给它加两个方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Animal {\n  constructor(name) {\n    this.name = name || \x27Kat\x27\n  }\n\n  move() {}\n  getName() {\n    return this.name\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name || \x3cspan class=\x22hljs-string\x22\x3e\x27Kat\x27\x3c\/span\x3e\n  }\n\n  move() {}\n  getName() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\nvar _createClass = (function() {\n  function defineProperties(target, props) {\n    for (var i = 0; i \x3c props.length; i\x2b\x2b) {\n      var descriptor = props[i]\n      descriptor.enumerable = descriptor.enumerable || false\n      descriptor.configurable = true\n      if (\x27value\x27 in descriptor) descriptor.writable = true\n      Object.defineProperty(target, descriptor.key, descriptor)\n    }\n  }\n  return function(Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps)\n    if (staticProps) defineProperties(Constructor, staticProps)\n    return Constructor\n  }\n})()\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\x27Cannot call a class as a function\x27)\n  }\n}\n\nvar Animal = (function() {\n  function Animal(name) {\n    _classCallCheck(this, Animal)\n\n    this.name = name || \x27Kat\x27\n  }\n\n  _createClass(Animal, [\n    {\n      key: \x27move\x27,\n      value: function move() {},\n    },\n    {\n      key: \x27getName\x27,\n      value: function getName() {\n        return this.name\n      },\n    },\n  ])\n\n  return Animal\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _createClass = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineProperties\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget, props\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; props.length; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e descriptor = props[i]\n      descriptor.enumerable = descriptor.enumerable || \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      descriptor.configurable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e descriptor) descriptor.writable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(target, descriptor.key, descriptor)\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eConstructor, protoProps, staticProps\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (protoProps) defineProperties(Constructor.prototype, protoProps)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (staticProps) defineProperties(Constructor, staticProps)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Constructor\n  }\n})()\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_classCallCheck\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einstance, Constructor\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(instance \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Constructor)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Cannot call a class as a function\x27\x3c\/span\x3e)\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Animal = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n    _classCallCheck(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, Animal)\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name || \x3cspan class=\x22hljs-string\x22\x3e\x27Kat\x27\x3c\/span\x3e\n  }\n\n  _createClass(Animal, [\n    {\n      \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27move\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emove\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{},\n    },\n    {\n      \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27getName\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetName\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\n      },\n    },\n  ])\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Animal\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e例子长了不少，但其实主要的变化只有两个：一是 \x3ccode\x3eAnimal\x3c\/code\x3e 被包了一层而不是直接返回；二是新增的方法 \x3ccode\x3emove\x3c\/code\x3e 和 \x3ccode\x3egetName\x3c\/code\x3e 是通过一个 \x3ccode\x3e_createClass()\x3c\/code\x3e 方法来实现的。它将两个方法以 \x3ccode\x3ekey\x3c\/code\x3e\/\x3ccode\x3evalue\x3c\/code\x3e 的形式作为数组传入，看起来，是要把它们设置到 \x3ccode\x3eAnimal\x3c\/code\x3e 的原型链上面，以便后续继承之用。\x3c\/p\x3e\n\x3cp\x3e为啥 \x3ccode\x3eAnimal\x3c\/code\x3e 被包了一层呢，这是个好问题，但答案我们将留到后文揭晓。现在，我们先看一下这个长长的 \x3ccode\x3e_createClass\x3c\/code\x3e 实现是什么：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var _createClass = (function() {\n  function defineProperties(target, props) {\n    for (var i = 0; i \x3c props.length; i\x2b\x2b) {\n      var descriptor = props[i]\n      descriptor.enumerable = descriptor.enumerable || false\n      descriptor.configurable = true\n      if (\x27value\x27 in descriptor) descriptor.writable = true\n      Object.defineProperty(target, descriptor.key, descriptor)\n    }\n  }\n\n  return function(Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps)\n    if (staticProps) defineProperties(Constructor, staticProps)\n    return Constructor\n  }\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _createClass = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineProperties\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget, props\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; props.length; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e descriptor = props[i]\n      descriptor.enumerable = descriptor.enumerable || \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      descriptor.configurable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e descriptor) descriptor.writable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(target, descriptor.key, descriptor)\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eConstructor, protoProps, staticProps\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (protoProps) defineProperties(Constructor.prototype, protoProps)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (staticProps) defineProperties(Constructor, staticProps)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Constructor\n  }\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e它是个立即执行函数，执行又返回了另一个函数。说明啥，一定用了闭包，说明里面要封装些「私有」变量，那就是 \x3ccode\x3edefineProperties\x3c\/code\x3e 这个函数。这很好，一是这个函数只会生成一次，二是明确了这个函数只与 \x3ccode\x3e_createClass\x3c\/code\x3e 这个事情相关。\x3c\/p\x3e\n\x3cp\x3e再细看这个返回的函数，接受 \x3ccode\x3eConstructor\x3c\/code\x3e、\x3ccode\x3eprotoProps\x3c\/code\x3e 和 \x3ccode\x3estaticProps\x3c\/code\x3e 三个参数。\x3ccode\x3estaticProps\x3c\/code\x3e 我们暂时不会用到，回头再讲；我们传入的数组是通过 \x3ccode\x3eprotoProps\x3c\/code\x3e 接受的。接下来，看一下 \x3ccode\x3edefineProperties\x3c\/code\x3e 做了啥事。\x3c\/p\x3e\n\x3cp\x3e它将每一个传进来的 props 做了如下处理：分别设置了他们的 \x3ccode\x3eenumerable\x3c\/code\x3e、\x3ccode\x3econfigurable\x3c\/code\x3e、\x3ccode\x3ewritable\x3c\/code\x3e 属性。而传进来的 \x3ccode\x3etarget\x3c\/code\x3e 是 \x3ccode\x3eAnimal.prototype\x3c\/code\x3e，相当于，这个函数最后的执行效果会是这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function defineProperties(target, props) {\n  for (var i = 0; i \x3c props.length; i\x2b\x2b) {\n    \/\/ 前面处理其实得到这样这个 descriptor 对象：\n    var descriptor = {\n      ...props[i],\n      enumerable: false,\n      configurable: true,\n      writable: true,\n    }\n    Object.defineProperty(target, descriptor.key, descriptor)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineProperties\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget, props\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; props.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 前面处理其实得到这样这个 descriptor 对象：\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e descriptor = {\n      ...props[i],\n      \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(target, descriptor.key, descriptor)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看到这里就很明白了，它就是把你定义的 \x3ccode\x3emove\x3c\/code\x3e、\x3ccode\x3egetName\x3c\/code\x3e 方法通过 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e 方法设置到 \x3ccode\x3eAnimal.prototype\x3c\/code\x3e 上去。\x3ca href=\x22https:\/\/blog.linesh.tw\/#\/post\/2018-10-18-javascript-prototypal-inheritance\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前面\x3c\/a\x3e我们说过，\x3ccode\x3eprototype\x3c\/code\x3e 是用来存储公共属性的。也就是说，这两个方法在你使用继承的时候，可以被子对象通过原型链上溯访问到。也就是说，我们这个小小的例子里，声明的两个方法已经具备了继承能力了。\x3c\/p\x3e\n\x3cp\x3e至于 \x3ccode\x3eenumerable\x3c\/code\x3e、\x3ccode\x3econfigurable\x3c\/code\x3e、\x3ccode\x3ewritable\x3c\/code\x3e 属性是什么东西呢，查一下\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-property-attributes\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e语言规范\x3c\/a\x3e就知道了。简单来说，\x3ccode\x3ewritable\x3c\/code\x3e 为 \x3ccode\x3efalse\x3c\/code\x3e 时，其值不能通过 \x3ccode\x3esetter\x3c\/code\x3e 改变；\x3ccode\x3eenumerable\x3c\/code\x3e 为 \x3ccode\x3efalse\x3c\/code\x3e 时，不能出现在 \x3ccode\x3efor-in\x3c\/code\x3e 循环中。当然，这里是粗浅的理解，暂时不是这篇文章的重点。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e简单继承——一层继承 \x2b 字段覆盖\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Animal {\n  constructor(name) {\n    this.name = name || \x27Kat\x27\n  }\n}\n\nclass Tiger extends Animal {\n  constructor(name, type) {\n    super(name)\n    this.type = type || \x27Paper\x27\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name || \x3cspan class=\x22hljs-string\x22\x3e\x27Kat\x27\x3c\/span\x3e\n  }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTiger\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name, type) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(name)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = type || \x3cspan class=\x22hljs-string\x22\x3e\x27Paper\x27\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e加一层继承和字段覆盖能看到啥东西呢？能看到继承底下的实现机制是怎么样的，以及它的 \x3ccode\x3econstructor\x3c\/code\x3e 和 \x3ccode\x3e__proto__\x3c\/code\x3e 属性将如何被正确设置。带着这两个问题，我们一起来看下编译后的源码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\n      \x26quot;this hasn\x27t been initialised - super() hasn\x27t been called\x26quot;\n    )\n  }\n  return call \x26amp;\x26amp; (typeof call === \x27object\x27 || typeof call === \x27function\x27)\n    ? call\n    : self\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \x27function\x27 \x26amp;\x26amp; superClass !== null) {\n    throw new TypeError(\n      \x27Super expression must either be null or a function, not \x27 \x2b\n        typeof superClass\n    )\n  }\n  subClass.prototype = Object.create(superClass \x26amp;\x26amp; superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true,\n    },\n  })\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass)\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\x27Cannot call a class as a function\x27)\n  }\n}\n\nvar Animal = function Animal(name) {\n  _classCallCheck(this, Animal)\n\n  this.name = name || \x27Kat\x27\n}\n\nvar Tiger = (function(_Animal) {\n  _inherits(Tiger, _Animal)\n\n  function Tiger(name, type) {\n    _classCallCheck(this, Tiger)\n\n    var _this = _possibleConstructorReturn(\n      this,\n      (Tiger.__proto__ || Object.getPrototypeOf(Tiger)).call(this, name)\n    )\n\n    _this.type = type || \x27Paper\x27\n    return _this\n  }\n\n  return Tiger\n})(Animal)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_possibleConstructorReturn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eself, call\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!self) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eReferenceError\x3c\/span\x3e(\n      \x3cspan class=\x22hljs-string\x22\x3e\x22this hasn\x27t been initialised - super() hasn\x27t been called\x22\x3c\/span\x3e\n    )\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e call \x26amp;\x26amp; (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e call === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e call === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e)\n    ? call\n    : self\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_inherits\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esubClass, superClass\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e superClass !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e \x26amp;\x26amp; superClass !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\n      \x3cspan class=\x22hljs-string\x22\x3e\x27Super expression must either be null or a function, not \x27\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e superClass\n    )\n  }\n  subClass.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(superClass \x26amp;\x26amp; superClass.prototype, {\n    \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: subClass,\n      \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    },\n  })\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (superClass)\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf\n      ? \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass)\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_classCallCheck\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einstance, Constructor\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(instance \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Constructor)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Cannot call a class as a function\x27\x3c\/span\x3e)\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Animal = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  _classCallCheck(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, Animal)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name || \x3cspan class=\x22hljs-string\x22\x3e\x27Kat\x27\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Tiger = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e_Animal\x3c\/span\x3e) \x3c\/span\x3e{\n  _inherits(Tiger, _Animal)\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTiger\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, type\x3c\/span\x3e) \x3c\/span\x3e{\n    _classCallCheck(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, Tiger)\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = _possibleConstructorReturn(\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,\n      (Tiger.__proto__ || \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(Tiger)).call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name)\n    )\n\n    _this.type = type || \x3cspan class=\x22hljs-string\x22\x3e\x27Paper\x27\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Tiger\n})(Animal)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相比无继承的代码，这里主要增加了几个函数。\x3ccode\x3e_possibleConstructorReturn\x3c\/code\x3e 顾名思义，可能不是很重要，回头再读。精华在 \x3ccode\x3e_inherits(Tiger, Animal)\x3c\/code\x3e 这个函数，我们按顺序来读一下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function _inherits(subClass, superClass) {\n  if (typeof superClass !== \x27function\x27 \x26amp;\x26amp; superClass !== null) {\n    throw new TypeError(\n      \x27Super expression must either be null or a function, not \x27 \x2b\n        typeof superClass\n    )\n  }\n  subClass.prototype = Object.create(superClass \x26amp;\x26amp; superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true,\n    },\n  })\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_inherits\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esubClass, superClass\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e superClass !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e \x26amp;\x26amp; superClass !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\n      \x3cspan class=\x22hljs-string\x22\x3e\x27Super expression must either be null or a function, not \x27\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e superClass\n    )\n  }\n  subClass.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(superClass \x26amp;\x26amp; superClass.prototype, {\n    \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: subClass,\n      \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    },\n  })\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (superClass)\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf\n      ? \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先是一段异常处理，简单地检查了 \x3ccode\x3esuperClass\x3c\/code\x3e 要么是个函数，要么得是个 null。也就是说，如果你这样写那是不行的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Something = \x27not-a-function\x27\nclass Animal extends Something {}\n\/\/ Error: Super expression must either be null or a function, not string\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Something = \x3cspan class=\x22hljs-string\x22\x3e\x27not-a-function\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSomething\x3c\/span\x3e \x3c\/span\x3e{}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Error: Super expression must either be null or a function, not string\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来这句代码将 \x3ccode\x3eprototype\x3c\/code\x3e 和 \x3ccode\x3econstructor\x3c\/code\x3e 一并设置到位，是精华。注意，这个地方留个问题：为什么要用 \x3ccode\x3eObject.create(superClass.prototype)\x3c\/code\x3e，而不是直接这么写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function _inherits(subClass, superClass) {\n  subClass.prototype = superClass \x26amp;\x26amp; superClass.prototype\n  subClass.prototype.constructor = { ... }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_inherits\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esubClass, superClass\x3c\/span\x3e) \x3c\/span\x3e{\n  subClass.prototype = superClass \x26amp;\x26amp; superClass.prototype\n  subClass.prototype.constructor = { ... }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很明显，是为了避免任何对 \x3ccode\x3esubClass.prototype\x3c\/code\x3e 的修改影响到 \x3ccode\x3esuperClass.prototype\x3c\/code\x3e。使用 \x3ccode\x3eObject.create(asPrototype)\x3c\/code\x3e 出来的对象，其实上是将 \x3ccode\x3esubClass.prototype.__proto__ = superClass.prototype\x3c\/code\x3e，这样 \x3ccode\x3esubClass\x3c\/code\x3e 也就继承了 \x3ccode\x3esuperClass\x3c\/code\x3e，可以达到这样两个目的：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3esuperClass.prototype\x3c\/code\x3e 原型上发生的修改都能实时反映到 \x3ccode\x3esubClass\x3c\/code\x3e 的实例上\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3esubClass.prototype\x3c\/code\x3e 上的任何修改不会影响到 \x3ccode\x3esuperClass.prototype\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e最后，如果 \x3ccode\x3esuperClass\x3c\/code\x3e 不为空，那么将 \x3ccode\x3esubClass.__proto__\x3c\/code\x3e 设置为 \x3ccode\x3esuperClass\x3c\/code\x3e。这是为了继承 \x3ccode\x3esuperClass\x3c\/code\x3e 的静态方法和属性。如以下的例子中，\x3ccode\x3eCat.TYPE\x3c\/code\x3e 能获取到 \x3ccode\x3eAnimal.TYPE\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Animal {\n  static TYPE = \x27PAPER\x27\n  static createTyping() {\n    return Animal.TYPE\n  }\n}\n\nclass Cat extends Animal {}\n\nconsole.log(Cat.TYPE)           \/\/ PAPER\nconsole.log(Cat.createTyping()) \/\/ PAPER\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e TYPE = \x3cspan class=\x22hljs-string\x22\x3e\x27PAPER\x27\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e createTyping() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Animal.TYPE\n  }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e \x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(Cat.TYPE)           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ PAPER\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(Cat.createTyping()) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ PAPER\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至此，一个简单的继承就完成了。在使用了 \x3ccode\x3eextends\x3c\/code\x3e 关键字后，实际上背后发生的事情是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e子「类」\x3ccode\x3eprototype\x3c\/code\x3e 上的 \x3ccode\x3e__proto__\x3c\/code\x3e 被正确设置，指向父「类」的 \x3ccode\x3eprototype\x3c\/code\x3e: \x3ccode\x3esubClass.prototype = { __proto__: superClass.prototype }\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e子「类」\x3ccode\x3eprototype\x3c\/code\x3e 上的 \x3ccode\x3econstructor\x3c\/code\x3e 被正确初始化，这样 \x3ccode\x3einstanceof\x3c\/code\x3e 关系能得到正确结果\x3c\/li\x3e\n\x3cli\x3e子「类」的 \x3ccode\x3e__proto__\x3c\/code\x3e 被指向父「类」，这样父「类」上的静态字段和方法能被子「类」继承\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e好，要点看完了。后面内容跟继承关系不大，但既然源码扒都扒了，我们不妨继续深入探索一些场景：\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e无继承——静态函数\x3c\/h2\x3e\n\x3cp\x3e看一个简单的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Animal {\n  static create() {\n    return new Animal()\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e create() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Animal()\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先要知道，这个「静态」同样不是强类型类继承语言里有的「静态」的概念。所谓静态，就是说它跟实例是没关系的，而跟「类」本身有关系。比如，你可以这样调用：\x3ccode\x3eAnimal.create()\x3c\/code\x3e，但不能这样用：\x3ccode\x3enew Animal().create\x3c\/code\x3e。什么场景下会用到这种模式呢？比如说：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e工厂模式或单例模式\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eObject.create\x3c\/code\x3e、\x3ccode\x3eObject.keys\x3c\/code\x3e 等常用方法\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e既然只有通过构造函数本身去调用，而不能通过实例来调用，期望它们被绑定到函数本身上似乎很自然。我们来看看上面这段代码将被如何编译：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\nvar _createClass = (function() {\n  function defineProperties(target, props) {\n    for (var i = 0; i \x3c props.length; i\x2b\x2b) {\n      var descriptor = props[i]\n      descriptor.enumerable = descriptor.enumerable || false\n      descriptor.configurable = true\n      if (\x27value\x27 in descriptor) descriptor.writable = true\n      Object.defineProperty(target, descriptor.key, descriptor)\n    }\n  }\n  return function(Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps)\n    if (staticProps) defineProperties(Constructor, staticProps)\n    return Constructor\n  }\n})()\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\x27Cannot call a class as a function\x27)\n  }\n}\n\nvar Animal = (function() {\n  function Animal() {\n    _classCallCheck(this, Animal)\n  }\n\n  _createClass(Animal, null, [\n    {\n      key: \x27create\x27,\n      value: function create() {},\n    },\n  ])\n\n  return Animal\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _createClass = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineProperties\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget, props\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; props.length; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e descriptor = props[i]\n      descriptor.enumerable = descriptor.enumerable || \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      descriptor.configurable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e descriptor) descriptor.writable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(target, descriptor.key, descriptor)\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eConstructor, protoProps, staticProps\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (protoProps) defineProperties(Constructor.prototype, protoProps)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (staticProps) defineProperties(Constructor, staticProps)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Constructor\n  }\n})()\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_classCallCheck\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einstance, Constructor\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(instance \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Constructor)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Cannot call a class as a function\x27\x3c\/span\x3e)\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Animal = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    _classCallCheck(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, Animal)\n  }\n\n  _createClass(Animal, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, [\n    {\n      \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27create\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{},\n    },\n  ])\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Animal\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e熟悉的函数，熟悉的配方。与本文的第二个例子相比，仅有一个地方的不同：\x3ccode\x3ecreate\x3c\/code\x3e 方法是作为 \x3ccode\x3e_createClass\x3c\/code\x3e 方法的第三个参数被传入的，这正是我们上文提到的 \x3ccode\x3estaticProps\x3c\/code\x3e 参数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var _createClass = (function() {\n  function defineProperties(target, props) { ... }\n\n  return function(Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps)\n    if (staticProps) defineProperties(Constructor, staticProps)\n    return Constructor\n  }\n})()\n\n_createClass(Animal, null, [\n  {\n    key: \x27create\x27,\n    value: function create() {},\n  },\n])\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _createClass = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineProperties\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget, props\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eConstructor, protoProps, staticProps\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (protoProps) defineProperties(Constructor.prototype, protoProps)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (staticProps) defineProperties(Constructor, staticProps)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Constructor\n  }\n})()\n\n_createClass(Animal, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, [\n  {\n    \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27create\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{},\n  },\n])\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看见，\x3ccode\x3ecreate\x3c\/code\x3e 方法是直接被创建到 \x3ccode\x3eAnimal\x3c\/code\x3e 上的：\x3ccode\x3edefineProperties(Animal, [{ key: \x27create\x27, value: function() {} }])\x3c\/code\x3e，最终会将函数赋给 \x3ccode\x3eAnimal.create\x3c\/code\x3e。我们的猜测并没有错误。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e无继承——静态变量\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Tiger {\n  static TYPE = \x27REAL\x27\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTiger\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e TYPE = \x3cspan class=\x22hljs-string\x22\x3e\x27REAL\x27\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还有个小例子。如果是静态变量的话，同样因为不希望在实例对象上所使用，我们会看到编译出来的代码中它是直接被设置到函数上。代码已经很熟悉，不必再讲。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\x27Cannot call a class as a function\x27)\n  }\n}\n\nvar Tiger = function Tiger() {\n  _classCallCheck(this, Tiger)\n}\n\nTiger.TYPE = \x27REAL\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_classCallCheck\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einstance, Constructor\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(instance \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Constructor)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Cannot call a class as a function\x27\x3c\/span\x3e)\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Tiger = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTiger\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  _classCallCheck(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, Tiger)\n}\n\nTiger.TYPE = \x3cspan class=\x22hljs-string\x22\x3e\x27REAL\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有趣的是，静态变量会不会被「子类」继承呢？这个可请读者自己做个实验，验证验证。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e神秘的类 arrow function\x3c\/h2\x3e\n\x3cp\x3e写 React 的东西，一定遇见过这个问题：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Button extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      isToggleOn: true,\n    }\n    \/\/ 画重点 👇👇👇👇👇👇👇👇👇👇👇👇\n    \/\/ this.toggleButton = this.toggleButton.bind(this)\n  }\n\n  static propTypes = {\n    text: PropTypes.string,\n  }\n\n  \/\/ ❌❌❌ Uncaught TypeError: this.setState is not a function\n  toggleButton() {\n    this.setState({\n      isToggleOn: !this.state.isToggleOn,\n    })\n  }\n\n  render() {\n    return \x3cbutton onClick={this.toggleButton}\x3eToggle Me\x3c\/button\x3e\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor() {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      isToggleOn: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 画重点 👇👇👇👇👇👇👇👇👇👇👇👇\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this.toggleButton = this.toggleButton.bind(this)\x3c\/span\x3e\n  }\n\n  static propTypes = {\n    text: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.string,\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ❌❌❌ Uncaught TypeError: this.setState is not a function\x3c\/span\x3e\n  toggleButton() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      isToggleOn: !\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.isToggleOn,\n    })\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;button onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.toggleButton}\x26gt;\x3cspan class=\x22hljs-type\x22\x3eToggle\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eMe\x3c\/span\x3e\x26lt;\/button\x26gt;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为什么会有这个问题呢？因为你扔进去的 \x3ccode\x3ethis.toggleButton\x3c\/code\x3e 函数，在 \x3ccode\x3ebutton\x3c\/code\x3e 内部一定是通过 \x3ccode\x3eonClick()\x3c\/code\x3e 这样的方式来调用的，这样的话，\x3ccode\x3ethis\x3c\/code\x3e 引用就会丢失为 \x3ccode\x3eundefined\x3c\/code\x3e，那么 \x3ccode\x3eReact.Component\x3c\/code\x3e 上的 \x3ccode\x3esetState\x3c\/code\x3e 就调用不到。\x3c\/p\x3e\n\x3cp\x3e可以直接去 React 官方示例看看：\x3ca href=\x22https:\/\/codepen.io\/gaearon\/pen\/xEmzGg?editors=0010\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/codepen.io\/gaearon\/pe...\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22gaearon\/pen\/xEmzGg\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Button extends React.Component {\n  ...\n\n  \/\/ ✅✅✅ This will work!\n  toggleButton = () =\x3e {\n    this.setState({ ... })\n  }\n\n  ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  ...\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ✅✅✅ This will work!\x3c\/span\x3e\n  toggleButton = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ ... })\n  }\n\n  ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e解决方案呢，自然也有很多种，比如引用 \x3ccode\x3e@autobind\x3c\/code\x3e、使用 ES7 的 \x3ccode\x3e::this.toggleButton\x3c\/code\x3e、使用箭头函数等。比如上面 👆 这种最常用的解决方案。那么同学们有没有想过这个问题，为什么这样写 \x3ccode\x3ethis\x3c\/code\x3e 应用就可以正确拿到呢？「因为箭头函数将 \x3ccode\x3ethis\x3c\/code\x3e 绑定到词法作用域的上下文中了呀~」那谁来给我解释一下这句话呢？反正我是从来没理解过这个「外层」的作用域，应该是绑定到哪里。因此，只好另辟路径，直接看源码来理解这个写法的含义。\x3c\/p\x3e\n\x3cp\x3e我写了个简单的例子，足以复现这个问题：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Button {\n  constructor() {\n    this.value = 1\n  }\n\n  increment = () =\x3e {\n    this.value \x2b= 2\n  }\n\n  render() {\n    const onClick = this.increment\n    onClick()\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n  }\n\n  increment = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value \x2b= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e onClick = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.increment\n    onClick()\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们调用 \x3ccode\x3erender()\x3c\/code\x3e 时，\x3ccode\x3eincrement()\x3c\/code\x3e 这样的调用方式会使 \x3ccode\x3ethis\x3c\/code\x3e 引用无法被初始化，这也正是我们传入的 \x3ccode\x3eonClick\x3c\/code\x3e 在 React 中会被调用的方式。而上图的 \x3ccode\x3eincrement\x3c\/code\x3e 写法可以重新拯救失去的 \x3ccode\x3ethis\x3c\/code\x3e 引用！让我们来看看源代码，一探究竟。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\n\nvar _createClass = (function() {})()\nfunction _classCallCheck(instance, Constructor) {}\n\nvar Button = (function() {\n  function Button() {\n    var _this = this\n\n    _classCallCheck(this, Button)\n\n    this.increment = function() {\n      _this.value \x2b= 2\n    }\n\n    this.value = 1\n  }\n\n  _createClass(Button, [\n    {\n      key: \x27render\x27,\n      value: function render() {\n        var increment = this.increment\n        increment()\n      },\n    },\n  ])\n\n  return Button\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _createClass = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{})()\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_classCallCheck\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einstance, Constructor\x3c\/span\x3e) \x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Button = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eButton\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n\n    _classCallCheck(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, Button)\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.increment = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      _this.value \x2b= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n  }\n\n  _createClass(Button, [\n    {\n      \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27render\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erender\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e increment = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.increment\n        increment()\n      },\n    },\n  ])\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Button\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我略去了大家耳熟能详的代码，只留下关键的部分。可以看到，编译后的代码中，\x3cstrong\x3e对 \x3ccode\x3eButton\x3c\/code\x3e 实例的 \x3ccode\x3ethis\x3c\/code\x3e 引用被闭包保存了下来\x3c\/strong\x3e！这种写法，与以前我们 \x3ccode\x3evar that = this\x3c\/code\x3e 的写法是一致的，我也终于理解「不再需要 that 引用了」以及各种语焉不详的作用域啊最外层变量啊这些理论。其实，就是 \x3ccode\x3ethis\x3c\/code\x3e 引用会始终被绑定到构造函数上，而这底下是通过闭包实现的。只是把你以前手写的代码自动化生成而已。\x3c\/p\x3e\n\x3cp\x3e在本文的第二个例子中，我们留意到 \x3ccode\x3eAnimal()\x3c\/code\x3e 构造函数被额外包了一层，当时不得其解。看到这里，我们也许可以理解它的意图：就是为了将你在类中编写的箭头函数做个闭包，将 \x3ccode\x3ethis\x3c\/code\x3e 引用存储下来，以做后用。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>深入 JavaScript 原型继承原理——babel 编译码解读</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016828714">https://segmentfault.com/a/1190000016828714</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/bqajfm13th4/" target="_blank">https://alili.tech/archive/bqajfm13th4/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>