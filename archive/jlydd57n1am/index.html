<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="前端路由实现与 react-router 源码分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>前端路由实现与 react-router 源码分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/jlydd57n1am/",
				"appid": "1613049289050283", 
				"title": "前端路由实现与 react-router 源码分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-10T02:30:42"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/bcp202dklyu/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/wze6dkms9d/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fjlydd57n1am%2f&text=%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e4%b8%8e%20react-router%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fjlydd57n1am%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fjlydd57n1am%2f&text=%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e4%b8%8e%20react-router%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fjlydd57n1am%2f&title=%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e4%b8%8e%20react-router%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fjlydd57n1am%2f&is_video=false&description=%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e4%b8%8e%20react-router%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e4%b8%8e%20react-router%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fjlydd57n1am%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fjlydd57n1am%2f&title=%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e4%b8%8e%20react-router%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjlydd57n1am%2f&title=%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e4%b8%8e%20react-router%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjlydd57n1am%2f&title=%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e4%b8%8e%20react-router%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjlydd57n1am%2f&title=%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0%e4%b8%8e%20react-router%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">前端路由实现与 react-router 源码分析</h1><div class="meta"><div class="postdate"><time datetime="2019-02-10" itemprop="datePublished">2019-02-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e原文地址：\x3ca href=\x22https:\/\/github.com\/joeyguo\/blog\/issues\/2\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/joeyguo\/blog\/issues\/2\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e在单页应用上，前端路由并不陌生。很多前端框架也会有独立开发或推荐配套使用的路由系统。那么，当我们在谈前端路由的时候，还可以谈些什么？本文将简要分析并实现一个的前端路由，并对 react-router 进行分析。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e一个极简前端路由实现\x3c\/h2\x3e\n\x3cp\x3e说一下前端路由实现的简要原理，以 hash 形式（也可以使用 History API 来处理）为例，当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。直接看代码或许更直观。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Router() {\n    this.routes = {};\n    this.currentUrl = \x27\x27;\n}\nRouter.prototype.route = function(path, callback) {\n    this.routes[path] = callback || function(){};\n};\nRouter.prototype.refresh = function() {\n    this.currentUrl = location.hash.slice(1) || \x27\/\x27;\n    this.routes[this.currentUrl]();\n};\nRouter.prototype.init = function() {\n    window.addEventListener(\x27load\x27, this.refresh.bind(this), false);\n    window.addEventListener(\x27hashchange\x27, this.refresh.bind(this), false);\n}\nwindow.Router = new Router();\nwindow.Router.init();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRouter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.routes = {};\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentUrl = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n}\nRouter.prototype.route = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epath, callback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.routes[path] = callback || \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{};\n};\nRouter.prototype.refresh = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentUrl = location.hash.slice(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) || \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.routes[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentUrl]();\n};\nRouter.prototype.init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27load\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.refresh.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e), \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27hashchange\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.refresh.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e), \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.Router = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Router();\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.Router.init();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面路由系统 Router 对象实现，主要提供三个方法\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3einit 监听浏览器 url hash 更新事件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eroute 存储路由更新时的回调到回调数组routes中，回调函数将负责对页面的更新\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3erefresh 执行当前url对应的回调函数，更新页面\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eRouter 调用方式以及呈现效果如下：点击触发 url 的 hash 改变，并对应地更新内容（这里为 body 背景色）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cul\x3e \n    \x3cli\x3e\x3ca href=\x26quot;#\/\x26quot;\x3eturn white\x3c\/a\x3e\x3c\/li\x3e \n    \x3cli\x3e\x3ca href=\x26quot;#\/blue\x26quot;\x3eturn blue\x3c\/a\x3e\x3c\/li\x3e \n    \x3cli\x3e\x3ca href=\x26quot;#\/green\x26quot;\x3eturn green\x3c\/a\x3e\x3c\/li\x3e \n\x3c\/ul\x3e \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e \n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22#\/\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eturn white\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e \n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22#\/blue\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eturn blue\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e \n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22#\/green\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eturn green\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e \n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e \x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var content = document.querySelector(\x27body\x27);\n\/\/ change Page anything\nfunction changeBgColor(color) {\n    content.style.backgroundColor = color;\n}\nRouter.route(\x27\/\x27, function() {\n    changeBgColor(\x27white\x27);\n});\nRouter.route(\x27\/blue\x27, function() {\n    changeBgColor(\x27blue\x27);\n});\nRouter.route(\x27\/green\x27, function() {\n    changeBgColor(\x27green\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e content = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27body\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ change Page anything\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echangeBgColor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecolor\x3c\/span\x3e) \x3c\/span\x3e{\n    content.style.backgroundColor = color;\n}\nRouter.route(\x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    changeBgColor(\x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e);\n});\nRouter.route(\x3cspan class=\x22hljs-string\x22\x3e\x27\/blue\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    changeBgColor(\x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e);\n});\nRouter.route(\x3cspan class=\x22hljs-string\x22\x3e\x27\/green\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    changeBgColor(\x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006770567\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006770567\x22 alt=\x2220160513_150041\x22 title=\x2220160513_150041\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e以上为一个前端路由的简单实现，\x3ca href=\x22https:\/\/github.com\/joeyguo\/blog\/blob\/master\/lab\/2016\/router\/simple-router.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e点击查看完整代码\x3c\/a\x3e，虽然简单，但实际上很多路由系统的根基都立于此，其他路由系统主要是对自身使用的框架机制的进行配套及优化，如与 react 配套的 react-router。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3ereact-router 分析\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3ereact-router 与 history 结合形式\x3c\/h3\x3e\n\x3cp\x3ereact-router 是基于 history 模块提供的 api 进行开发的，结合的形式本文记为 \x3cstrong\x3e包装方式\x3c\/strong\x3e。所以在开始对其分析之前，先举一个简单的例子来说明如何进行对象的包装。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 原对象\nvar historyModule = {\n    listener: [],\n    listen: function (listener) {\n        this.listener.push(listener);\n        console.log(\x27historyModule listen..\x27)\n    },\n    updateLocation: function(){\n        this.listener.forEach(function(listener){\n            listener(\x27new localtion\x27);\n        })\n    }\n}\n\/\/ Router 将使用 historyModule 对象，并对其包装\nvar Router = {\n    source: {},\n    init: function(source){\n        this.source = source;\n    },\n    \/\/ 对 historyModule的listen进行了一层包装\n    listen: function(listener) {\n        return this.source.listen(function(location){\n            console.log(\x27Router listen tirgger.\x27);\n            listener(location);\n        })\n    }\n}\n\/\/ 将 historyModule 注入进 Router 中\nRouter.init(historyModule);\n\/\/ Router 注册监听\nRouter.listen(function(location){\n    console.log(location \x2b \x27-\x3e Router setState.\x27);\n})\n\/\/ historyModule 触发回调\nhistoryModule.updateLocation();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e historyModule = {\n    \x3cspan class=\x22hljs-attr\x22\x3elistener\x3c\/span\x3e: [],\n    \x3cspan class=\x22hljs-attr\x22\x3elisten\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listener.push(listener);\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27historyModule listen..\x27\x3c\/span\x3e)\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eupdateLocation\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listener.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e)\x3c\/span\x3e{\n            listener(\x3cspan class=\x22hljs-string\x22\x3e\x27new localtion\x27\x3c\/span\x3e);\n        })\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Router 将使用 historyModule 对象，并对其包装\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Router = {\n    \x3cspan class=\x22hljs-attr\x22\x3esource\x3c\/span\x3e: {},\n    \x3cspan class=\x22hljs-attr\x22\x3einit\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esource\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.source = source;\n    },\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对 historyModule的listen进行了一层包装\x3c\/span\x3e\n    listen: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.source.listen(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elocation\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Router listen tirgger.\x27\x3c\/span\x3e);\n            listener(location);\n        })\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将 historyModule 注入进 Router 中\x3c\/span\x3e\nRouter.init(historyModule);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Router 注册监听\x3c\/span\x3e\nRouter.listen(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elocation\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(location \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27-\x26gt; Router setState.\x27\x3c\/span\x3e);\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ historyModule 触发回调\x3c\/span\x3e\nhistoryModule.updateLocation();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e返回：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005160836\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005160836\x22 alt=\x2222\x22 title=\x2222\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可看到 historyModule 中含有机制：historyModule.updateLocation() -\x26gt; listener( )，Router 通过对其进行包装开发，针对 historyModule 的机制对 Router 也起到了作用，即historyModule.updateLocation() 将触发 Router.listen 中的回调函数 。\x3ca href=\x22https:\/\/github.com\/joeyguo\/blog\/blob\/master\/lab\/2016\/router\/package-style.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e点击查看完整代码\x3c\/a\x3e\x3cbr\x3e这种包装形式能够充分利用原对象（historyModule ）的内部机制，减少开发成本，也更好的分离包装函数（Router）的逻辑，减少对原对象的影响。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3ereact-router 使用方式\x3c\/h3\x3e\n\x3cp\x3ereact-router 以 react component 的组件方式提供 API， 包含 Router，Route，Redirect，Link 等等，这样能够充分利用 react component 提供的生命周期特性，同时也让定义路由跟写 react component 达到统一，如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22render((\n  \x3cRouter history={browserHistory}\x3e\n    \x3cRoute path=\x26quot;\/\x26quot; component={App}\x3e\n      \x3cRoute path=\x26quot;about\x26quot; component={About}\/\x3e\n      \x3cRoute path=\x26quot;users\x26quot; component={Users}\x3e\n        \x3cRoute path=\x26quot;\/user\/:userId\x26quot; component={User}\/\x3e\n      \x3c\/Route\x3e\n      \x3cRoute path=\x26quot;*\x26quot; component={NoMatch}\/\x3e\n    \x3c\/Route\x3e\n  \x3c\/Router\x3e\n), document.body)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3erender((\n  \x26lt;Router history={browserHistory}\x26gt;\n    \x26lt;Route path=\x22\/\x22 component={App}\x26gt;\n      \x26lt;Route path=\x22about\x22 component={About}\/\x26gt;\n      \x26lt;Route path=\x22users\x22 component={Users}\x26gt;\n        \x26lt;Route path=\x22\/user\/:userId\x22 component={User}\/\x26gt;\n      \x26lt;\/Route\x26gt;\n      \x26lt;Route path=\x22*\x22 component={NoMatch}\/\x26gt;\n    \x26lt;\/Route\x26gt;\n  \x26lt;\/Router\x26gt;\n), document.body)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就这样，声明了一份含有 path to component 的各个映射的路由表。\x3c\/p\x3e\n\x3cp\x3ereact-router 还提供的 Link 组件（如下），作为提供更新 url 的途径，触发 Link 后最终将通过如上面定义的路由表进行匹配，并拿到对应的 component 及 state 进行 render 渲染页面。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cLink to={`\/user\/89757`}\x3e\x27joey\x27\x3c\/Link\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;Link to={\x3cspan class=\x22hljs-string\x22\x3e`\/user\/89757`\x3c\/span\x3e}\x26gt;\x3cspan class=\x22hljs-string\x22\x3e\x27joey\x27\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/Link\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里不细讲 react-router 的使用，详情可见：\x3ca href=\x22https:\/\/github.com\/reactjs\/react-router\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/reactjs\/react-router\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e从点击 Link 到 render 对应 component ，路由中发生了什么\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e为何能够触发 render  component ？\x3c\/h3\x3e\n\x3cp\x3e主要是因为触发了 react setState 的方法从而能够触发 render component。\x3cbr\x3e从顶层组件 Router 出发（下面代码从 react-router\/Router 中摘取），可看到 Router 在 react component 生命周期之组件被挂载前 componentWillMount 中使用 this.history.listen 去注册了 url 更新的回调函数。回调函数将在 url 更新时触发，回调中的 setState 起到 render 了新的 component 的作用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Router.prototype.componentWillMount = function componentWillMount() {\n    \/\/ .. 省略其他\n    var createHistory = this.props.history;\n    \n    this.history = _useRoutes2[\x27default\x27](createHistory)({\n      routes: _RouteUtils.createRoutes(routes || children),\n      parseQueryString: parseQueryString,\n      stringifyQuery: stringifyQuery\n    });\n    \n    this._unlisten = this.history.listen(function (error, state) {\n        _this.setState(state, _this.props.onUpdate);\n    });\n  };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eRouter.prototype.componentWillMount = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecomponentWillMount\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ .. 省略其他\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e createHistory = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.history;\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.history = _useRoutes2[\x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e](createHistory)({\n      \x3cspan class=\x22hljs-attr\x22\x3eroutes\x3c\/span\x3e: _RouteUtils.createRoutes(routes || children),\n      \x3cspan class=\x22hljs-attr\x22\x3eparseQueryString\x3c\/span\x3e: parseQueryString,\n      \x3cspan class=\x22hljs-attr\x22\x3estringifyQuery\x3c\/span\x3e: stringifyQuery\n    });\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._unlisten = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.history.listen(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerror, state\x3c\/span\x3e) \x3c\/span\x3e{\n        _this.setState(state, _this.props.onUpdate);\n    });\n  };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的 _useRoutes2 对 history 操作便是对其做一层包装，所以调用的 this.history 实际为包装以后的对象，该对象含有 _useRoutes2 中的 listen 方法，如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function listen(listener) {\n      return history.listen(function (location) {\n          \/\/ .. 省略其他\n          match(location, function (error, redirectLocation, nextState) {\n            listener(null, nextState);\n          });\n      });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3elisten\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e history.listen(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3elocation\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ .. 省略其他\x3c\/span\x3e\n          match(location, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerror, redirectLocation, nextState\x3c\/span\x3e) \x3c\/span\x3e{\n            listener(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, nextState);\n          });\n      });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可看到，上面代码中，主要分为两部分\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e使用了 history 模块的 listen 注册了一个含有 setState 的回调函数（这样就能使用 history 模块中的机制）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e回调中的 match 方法为 react-router 所特有，match 函数根据当前 location 以及前面写的 Route 路由表匹配出对应的路由子集得到新的路由状态值 state，具体实现可见 react-router\/matchRoutes ，再根据 state 得到对应的 component ，最终执行了 match 中的回调 listener(null, nextState) ，即执行了 Router 中的监听回调（setState），从而更新了展示。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e以上，为起始注册的监听，及回调的作用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e如何触发监听的回调函数的执行？\x3c\/h3\x3e\n\x3cp\x3e这里还得从如何更新 url 说起。一般来说，url 更新主要有两种方式：简单的 hash 更新或使用 history api 进行地址更新。在 react-router 中，其提供了 Link 组件，该组件能在 render 中使用，最终会表现为 a 标签，并将 Link 中的各个参数组合放它的 href 属性中。可以从 react-router\/ Link 中看到，对该组件的点击事件进行了阻止了浏览器的默认跳转行为，而改用 history 模块的 pushState 方法去触发 url 更新。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Link.prototype.render = function render() {\n    \/\/ .. 省略其他\n    props.onClick = function (e) {\n      return _this.handleClick(e);\n    };\n    if (history) {\n     \/\/ .. 省略其他\n      props.href = history.createHref(to, query);\n    }\n    return _react2[\x27default\x27].createElement(\x27a\x27, props);\n};\n  \nLink.prototype.handleClick = function handleClick(event) {\n    \/\/ .. 省略其他\n    event.preventDefault();\n    this.context.history.pushState(this.props.state, this.props.to, this.props.query);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eLink.prototype.render = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erender\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ .. 省略其他\x3c\/span\x3e\n    props.onClick = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this.handleClick(e);\n    };\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (history) {\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ .. 省略其他\x3c\/span\x3e\n      props.href = history.createHref(to, query);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _react2[\x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e].createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, props);\n};\n  \nLink.prototype.handleClick = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleClick\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ .. 省略其他\x3c\/span\x3e\n    event.preventDefault();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.history.pushState(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.state, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.to, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.query);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对 history 模块的 pushState 方法对 url 的更新形式，同样分为两种，分别在 history\/createBrowserHistory 及 history\/createHashHistory 各自的 finishTransition 中，如 history\/createBrowserHistory 中使用的是 window.history.replaceState(historyState, null, path); 而 history\/createHashHistory 则使用 window.location.hash = url，调用哪个是根据我们一开始创建 history 的方式。\x3c\/p\x3e\n\x3cp\x3e更新 url 的显示是一部分，另一部分是根据 url 去更新展示，也就是触发前面的监听。这是在前面 finishTransition 更新 url 之后实现的，调用的是 history\/createHistory 中的 updateLocation 方法，changeListeners 中为 history\/createHistory 中的 listen 中所添加的，如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function updateLocation(newLocation) {\n   \/\/ 示意代码\n    location = newLocation;\n    changeListeners.forEach(function (listener) {\n      listener(location);\n    });\n}\nfunction listen(listener) {\n     \/\/ 示意代码\n    changeListeners.push(listener);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateLocation\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enewLocation\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 示意代码\x3c\/span\x3e\n    location = newLocation;\n    changeListeners.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e) \x3c\/span\x3e{\n      listener(location);\n    });\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3elisten\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e) \x3c\/span\x3e{\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 示意代码\x3c\/span\x3e\n    changeListeners.push(listener);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e可以将以上 react-router 的整个包装闭环总结为\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e回调函数：含有能够更新 react UI 的 react setState 方法。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e注册回调：在 Router componentWillMount 中使用 history.listen 注册的回调函数，最终放在 history 模块的 回调函数数组 changeListeners 中。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e触发回调：Link 点击触发 history 中回调函数数组 changeListeners 的执行，从而触发原来 listen 中的 setState 方法，更新了页面\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e至于前进与后退的实现，是通过监听 popstate 以及 hashchange 的事件，当前进或后退 url 更新时，触发这两个事件的回调函数，回调的执行方式 Link 大致相同，最终同样更新了 UI ，这里就不再说明。\x3c\/p\x3e\n\x3cp\x3ereact-router 主要是利用底层 history 模块的机制，通过结合 react 的架构机制做一层包装，实际自身的内容并不多，但其包装的思想笔者认为很值得学习，有兴趣的建议阅读下源码，相信会有其他收获。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>前端路由实现与 react-router 源码分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005160459">https://segmentfault.com/a/1190000005160459</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/jlydd57n1am/" target="_blank">https://alili.tech/archive/jlydd57n1am/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>