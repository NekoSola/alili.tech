<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="nodeJS多进程"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>nodeJS多进程 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ylr9i8j2eck/",
				"appid": "1613049289050283", 
				"title": "nodeJS多进程 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-13T02:31:22"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jkj0jniub9e/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/q5lazkp6kes/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fylr9i8j2eck%2f&text=nodeJS%e5%a4%9a%e8%bf%9b%e7%a8%8b"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fylr9i8j2eck%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fylr9i8j2eck%2f&text=nodeJS%e5%a4%9a%e8%bf%9b%e7%a8%8b"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fylr9i8j2eck%2f&title=nodeJS%e5%a4%9a%e8%bf%9b%e7%a8%8b"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fylr9i8j2eck%2f&is_video=false&description=nodeJS%e5%a4%9a%e8%bf%9b%e7%a8%8b"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=nodeJS%e5%a4%9a%e8%bf%9b%e7%a8%8b&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fylr9i8j2eck%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fylr9i8j2eck%2f&title=nodeJS%e5%a4%9a%e8%bf%9b%e7%a8%8b"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fylr9i8j2eck%2f&title=nodeJS%e5%a4%9a%e8%bf%9b%e7%a8%8b"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fylr9i8j2eck%2f&title=nodeJS%e5%a4%9a%e8%bf%9b%e7%a8%8b"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fylr9i8j2eck%2f&title=nodeJS%e5%a4%9a%e8%bf%9b%e7%a8%8b"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">nodeJS多进程</h1><div class="meta"><div class="postdate"><time datetime="2019-02-13" itemprop="datePublished">2019-02-13</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e首先郑重声明:\x3cbr\x3enodeJS 是一门单线程!异步!非阻塞语言!\x3cbr\x3enodeJS 是一门单线程!异步!非阻塞语言!\x3cbr\x3enodeJS 是一门单线程!异步!非阻塞语言!\x3c\/p\x3e\n\x3cp\x3e重要的事情说3遍。 因为nodeJS天生自带buff, 所以从一出生就受到 万千 粉丝的追捧(俺，也是它的死忠). 但是，傻逼php 竟然嘲笑 我大NodeJS 的性能。 说不稳定，不可靠，只能利用单核CPU。 辣鸡 nodeJS. \x3cbr\x3e艹!艹!艹! \x3cbr\x3e搞mo shi~\x3cbr\x3e但，大哥就是大哥,nodeJS在v0.8 的时候就已经加入了cluster的模块。 完全打脸php. 虽然，现在php 也开始抄袭nodeJS, 退出php7, 但是，渣渣，你就只会抄...\x3cbr\x3e233333 \x3cbr\x3e对不起啊，上面是我自已意淫的一段~  以上内容，纯属调侃，如果雷同，纯属巧合。\x3cbr\x3eOk~ 我们来正式介绍一下nodeJS的多进程吧~\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3ecluster的前世今生\x3c\/h2\x3e\n\x3cp\x3e以前，由于cluster 本身的不完善，可能由于多方面原因吧，实现性能不好。 结果是，pm2 包的 崛起。 轻松使用一个pm2 就可以开启多进程，实现负载均衡的效果。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22pm2 start app.js\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3epm2 start app\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3epm2的内部和cluster内部实现其实是一个道理，都是封装了一层child_process--fork. 而child_process--fork 则是封装了unix 系统的fork 方法。 既然，都到这了，我们来看看官方给出的解释吧。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3efork() creates a new process by duplicating the calling process. The new process is referred to as the child process. The calling process is referred to as the parent process.\x3c\/p\x3e\n\x3cp\x3eThe child process and the parent process run in separate memory spaces. At the time of fork() both memory spaces have the same content. Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by one of the processes do not affect the other.\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e俺来翻译一下，fork其实就是创建子进程的方法，新创建的进程被认为是子进程，而调用fork的进程则是父进程。 子进程和父进程本来是在独立的内存空间中的。但当你使用了fork之后，两者就处在同一个作用域内了。 但是，内存的读写，文件的map,都不会影响对方。\x3c\/p\x3e\n\x3cp\x3e上面那段的意思就是，你创建的进程其实可以相互通信，并且被master进程 管理。 \x3cbr\x3e看图~~~\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/gtms01.alicdn.com\/tps\/i1\/TB1XNnNJVXXXXanXpXXQzA.9VXX-447-300.png\x22 src=\x22https:\/\/static.alili.techhttp:\/\/gtms01.alicdn.com\/tps\/i1\/TB1XNnNJVXXXXanXpXXQzA.9VXX-447-300.png\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其实就是这个意思。 \x3cbr\x3eOk~ 这只是系统创建子进程的模型。那么在NodeJs中是怎样实现进程之间的交互的呢？\x3cbr\x3e很简单监听端口呗。。。\x3cbr\x3e但是，实现通信不是很难，关键在于如果分配请求，这一点nodeJS 踩的坑确实很大。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3enodeJS 实现进程分配的黑历史\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3elong time ago\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3enodeJS的master 开始并不是上帝， 他只是一个小小的太监，每次请求(妃子)来的时候，他只会默默的看着几个worker小皇帝相互争夺，如果某个worker胜出，则其他的worker也就草草了事，等下一个请求过来。所以说，每来一次请求，都会引起一场腥风血雨。而，我们体会最深的就是惊群现象,即,CPU爆表.\x3cbr\x3e借用TJ大神的一幅图，说明一下。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/gtms04.alicdn.com\/tps\/i4\/TB1bexvKpXXXXaMXXXX3GwW0VXX-426-298.png\x22 src=\x22https:\/\/static.alili.techhttp:\/\/gtms04.alicdn.com\/tps\/i4\/TB1bexvKpXXXXaMXXXX3GwW0VXX-426-298.png\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e这里，master只是绑定端口，而不会对来的请求做任何处理。 通过将socket的fd给fork出来的进程。造成的结果就是4个人男人(worker)抢一个妃子(request). 那场面别提有多血腥了。\x3cbr\x3e前面说过，cluster其实就是对child_process的一层封装，那我们继续往底层走一点。实现cluster多进程。 首先，我们需要了解，这几个模块的基本用法。net,child_process.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3echild_process\x3c\/h3\x3e\n\x3cp\x3e这个应该是nodeJS 进程最核心的模块。 基本的方法，有几个，不过我这里，只介绍比较核心的:spawn ,fork ,exec。如果大家有兴趣，可以去\x3ca href=\x22https:\/\/nodejs.org\/dist\/latest-v4.x\/docs\/api\/child_process.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echild_process\x3c\/a\x3e参考.\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3echild_process.spawn(command, args)\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e该方法用来运行指定的程序。比如: \x3ccode\x3enode app.js\x3c\/code\x3e.他是异步的命令，但不支持callback, 不过我们可以使用process.on来监听结果。 他自带3个参数.\x3cbr\x3ecommand: 执行命令\x3cbr\x3eargs[Array]: 命令所带的参数\x3cbr\x3eoptions[Object]: 环境变量\x3cstrong\x3e对象\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eOK~ 我们举个一个简单的demo: 试一试运行 \x3ccode\x3etouch apawn.js\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const spawn = require(\x27child_process\x27).spawn;\nconst touch = spawn(\x27touch\x27,[\x27spawn.js\x27]);\n\ntouch.stdout.on(\x27data\x27, (data) =\x3e {\n  console.log(`stdout: ${data}`);\n});\n\ntouch.stderr.on(\x27data\x27, (data) =\x3e {\n  console.log(`stderr: ${data}`);\n});\n\ntouch.on(\x27close\x27, (code) =\x3e {\n  console.log(`child process exited with code ${code}`);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst spawn = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27child_process\x27\x3c\/span\x3e).spawn;\nconst touch = spawn(\x3cspan class=\x22hljs-string\x22\x3e\x27touch\x27\x3c\/span\x3e,[\x3cspan class=\x22hljs-string\x22\x3e\x27spawn.js\x27\x3c\/span\x3e]);\n\ntouch.stdout.\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(`\x3cspan class=\x22javascript\x22\x3estdout: ${data}\x3c\/span\x3e`);\n});\n\ntouch.stderr.\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(`\x3cspan class=\x22javascript\x22\x3estderr: ${data}\x3c\/span\x3e`);\n});\n\ntouch.\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27close\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(code)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(`\x3cspan class=\x22javascript\x22\x3echild process exited \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e code ${code}\x3c\/span\x3e`);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果，正确的话，应该会输\x3cbr\x3e 出\x3ccode\x3echild process exited with code 0\x3c\/code\x3e. 然后运行目录会生成pawn.js文件。 当然，如果你需要运行多参数的命令的话这就有点蛋疼了。\x3cbr\x3e 所以，nodeJS 使用了exec对其进行很好的封装，而且他支持回调函数，这比较能够让我们理解。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3echild_process.exec(order,cb(err[,stdout,stderr]));\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3eorder: 就是你执行的命令. 比如: \x3ccode\x3erm spawn.js\x3c\/code\x3e\x3cbr\x3ecb: 就是命令执行成功后的回调函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const childProcess = require(\x27child_process\x27);\n\nconst ls = childProcess.exec(\x27rm spawn.js\x27, function (error, stdout, stderr) {\n   if (error) {\n     console.log(error.stack);\n     console.log(\x27Error code: \x27\x2berror.code);\n   }\n   console.log(\x27Child Process STDOUT: \x27\x2bstdout);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e childProcess = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27child_process\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ls = childProcess.exec(\x3cspan class=\x22hljs-string\x22\x3e\x27rm spawn.js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerror, stdout, stderr\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (error) {\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(error.stack);\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Error code: \x27\x3c\/span\x3e\x2berror.code);\n   }\n   \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Child Process STDOUT: \x27\x3c\/span\x3e\x2bstdout);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e正常情况下会删除spawn.js文件。\x3cbr\x3e上面两个只是简单的运行进程的命令。 最后，(Boss总是最后出场的). 我们来瞧瞧fork方法的使用.\x3cbr\x3efork其实也是用来执行进程，比如,spawn(\x22node\x22,[\x27app.js\x27]),其实和fork(\x27app.js\x27) 是一样的效果的。但是，fork牛逼的地方在于他在开启一个子进程时，同时建立了一个信息通道(双工的哦). 俩个进程之间使用process.on(\x22message\x22,fn)和process.send(...)进行信息的交流.\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3echild_process.fork(order)  \/\/创建子进程\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eworker.on(\x27message\x27,cb)  \/\/监听message事件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eworker.send(mes)    \/\/发送信息\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e他和spawn类似都是通过返回的通道进行通信。举一个demo, 两个文件master.js和worker.js 来看一下.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/master.js\nconst childProcess = require(\x27child_process\x27);\nconst worker = childProcess.fork(\x27worker.js\x27);\n\nworker.on(\x27message\x27,function(mes){\n    console.log(`from worder, message: ${mes}`);\n});\nworker.send(\x26quot;this is master\x26quot;);\n\n\/\/worker.js\nprocess.on(\x27message\x27,function(mes){\n    console.log(`from master, message: ${mes}`);\n});\nprocess.send(\x26quot;this is worker\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/master.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e childProcess = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27child_process\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e worker = childProcess.fork(\x3cspan class=\x22hljs-string\x22\x3e\x27worker.js\x27\x3c\/span\x3e);\n\nworker.on(\x3cspan class=\x22hljs-string\x22\x3e\x27message\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emes\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`from worder, message: \x3cspan class=\x22hljs-subst\x22\x3e${mes}\x3c\/span\x3e`\x3c\/span\x3e);\n});\nworker.send(\x3cspan class=\x22hljs-string\x22\x3e\x22this is master\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/worker.js\x3c\/span\x3e\nprocess.on(\x3cspan class=\x22hljs-string\x22\x3e\x27message\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emes\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`from master, message: \x3cspan class=\x22hljs-subst\x22\x3e${mes}\x3c\/span\x3e`\x3c\/span\x3e);\n});\nprocess.send(\x3cspan class=\x22hljs-string\x22\x3e\x22this is worker\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e运行，\x3ccode\x3enode app.js\x3c\/code\x3e, 会输出一下结果:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22from master, message: this is master\nfrom worker, message: this is worker\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e master, message: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e master\n\x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e worker, message: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e worker\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e现在我们已经学会了，如何使用child_process来创建一个基本的进程了。\x3cbr\x3e关于net 这一模块，大家可以参考一下\x3ca href=\x22https:\/\/nodejs.org\/dist\/latest-v4.x\/docs\/api\/net.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enet模块\x3c\/a\x3e.\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3eok . 现在我们正式进入，模拟nodeJS cluster模块通信的procedure了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eout of date 的cluster\x3c\/h3\x3e\n\x3cp\x3e这里先介绍一下，曾经的cluster实现的一套机理。同样，再放一次图\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/gtms04.alicdn.com\/tps\/i4\/TB1bexvKpXXXXaMXXXX3GwW0VXX-426-298.png\x22 src=\x22https:\/\/static.alili.techhttp:\/\/gtms04.alicdn.com\/tps\/i4\/TB1bexvKpXXXXaMXXXX3GwW0VXX-426-298.png\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e我们使用net和child_process来模仿一下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/master.js\nconst net = require(\x27net\x27);\nconst fork = require(\x27child_process\x27).fork;\n\nvar handle = net._createServerHandle(\x270.0.0.0\x27, 3000);\n\nfor(var i=0;i\x3c4;i\x2b\x2b) {\n   fork(\x27.\/worker\x27).send({}, handle);\n}\n\/\/worker.js\nconst net = require(\x27net\x27);\n\/\/监听master发送过来的信息\nprocess.on(\x27message\x27, function(m, handle) {\n  start(handle);\n});\n\nvar buf = \x27hello nodejs\x27; \/\/\/返回信息\nvar res = [\x27HTTP\/1.1 200 OK\x27,\x27content-length:\x27\x2bbuf.length].join(\x27\\r\\n\x27)\x2b\x27\\r\\n\\r\\n\x27\x2bbuf;  \/\/嵌套字\n\nfunction start(server) {\n    server.listen();\n    var num=0;\n    \/\/监听connection函数\n    server.onconnection = function(err,handle) {\n        num\x2b\x2b;\n        console.log(`worker[${process.pid}]:${num}`);\n        var socket = new net.Socket({\n            handle: handle\n        });\n        socket.readable = socket.writable = true;\n        socket.end(res);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/master.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e net = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27net\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fork = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27child_process\x27\x3c\/span\x3e).fork;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e handle = net._createServerHandle(\x3cspan class=\x22hljs-string\x22\x3e\x270.0.0.0\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;i\x26lt;\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;i\x2b\x2b) {\n   fork(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/worker\x27\x3c\/span\x3e).send({}, handle);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/worker.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e net = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27net\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/监听master发送过来的信息\x3c\/span\x3e\nprocess.on(\x3cspan class=\x22hljs-string\x22\x3e\x27message\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3em, handle\x3c\/span\x3e) \x3c\/span\x3e{\n  start(handle);\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e buf = \x3cspan class=\x22hljs-string\x22\x3e\x27hello nodejs\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/\/返回信息\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = [\x3cspan class=\x22hljs-string\x22\x3e\x27HTTP\/1.1 200 OK\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27content-length:\x27\x3c\/span\x3e\x2bbuf.length].join(\x3cspan class=\x22hljs-string\x22\x3e\x27\\r\\n\x27\x3c\/span\x3e)\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27\\r\\n\\r\\n\x27\x3c\/span\x3e\x2bbuf;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/嵌套字\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estart\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eserver\x3c\/span\x3e) \x3c\/span\x3e{\n    server.listen();\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e num=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/监听connection函数\x3c\/span\x3e\n    server.onconnection = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr,handle\x3c\/span\x3e) \x3c\/span\x3e{\n        num\x2b\x2b;\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`worker[\x3cspan class=\x22hljs-subst\x22\x3e${process.pid}\x3c\/span\x3e]:\x3cspan class=\x22hljs-subst\x22\x3e${num}\x3c\/span\x3e`\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e socket = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e net.Socket({\n            \x3cspan class=\x22hljs-attr\x22\x3ehandle\x3c\/span\x3e: handle\n        });\n        socket.readable = socket.writable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n        socket.end(res);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eok~ 我们运行一下程序, 首先运行\x3ccode\x3enode master.js\x3c\/code\x3e. \x3cbr\x3e然后使用测试工具,siege. \x3cbr\x3e\x3ccode\x3esiege -c 100 -r 2 http:\/\/localhost:3000\x3c\/code\x3e\x3cbr\x3eOK，我们看一下，到底此时的负载是否均衡。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22worker[1182]:52\nworker[1183]:42\nworker[1184]:90\nworker[1181]:16\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eworker\x3c\/span\x3e\x3cspan class=\x22hljs-selector-attr\x22\x3e[1182]\x3c\/span\x3e\x3cspan class=\x22hljs-selector-pseudo\x22\x3e:52\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eworker\x3c\/span\x3e\x3cspan class=\x22hljs-selector-attr\x22\x3e[1183]\x3c\/span\x3e\x3cspan class=\x22hljs-selector-pseudo\x22\x3e:42\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eworker\x3c\/span\x3e\x3cspan class=\x22hljs-selector-attr\x22\x3e[1184]\x3c\/span\x3e\x3cspan class=\x22hljs-selector-pseudo\x22\x3e:90\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eworker\x3c\/span\x3e\x3cspan class=\x22hljs-selector-attr\x22\x3e[1181]\x3c\/span\x3e\x3cspan class=\x22hljs-selector-pseudo\x22\x3e:16\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e发现，这样任由worker去争夺请求，效率真的很低呀。每一次，触发请求，都有可能导致惊群事件的发生啊喂。所以，后来cluster改变了一种模式，使用master来控制请求的分配，官方给出的算法其实就是round-robin 轮转方法。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e高富帅版cluster\x3c\/h3\x3e\n\x3cp\x3e现在具体的实现模型就变成这个.\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/gtms02.alicdn.com\/tps\/i2\/TB1kT6gKpXXXXbyXXXXvNGU0VXX-533-352.png\x22 src=\x22https:\/\/static.alili.techhttp:\/\/gtms02.alicdn.com\/tps\/i2\/TB1kT6gKpXXXXbyXXXXvNGU0VXX-533-352.png\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e由master来控制请求的给予。通过监听端口，创建一个socket，将获得的请求传递给子进程。\x3cbr\x3e从tj大神那里借鉴的代码demo:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/master\nconst net = require(\x27net\x27);\nconst fork = require(\x27child_process\x27).fork;\n\nvar workers = [];\nfor (var i = 0; i \x3c 4; i\x2b\x2b) {\n   workers.push(fork(\x27.\/worker\x27));\n}\n\nvar handle = net._createServerHandle(\x270.0.0.0\x27, 3000);\nhandle.listen();\n\/\/将监听事件移到master中\nhandle.onconnection = function (err,handle) {\n    var worker = workers.pop();  \/\/取出一个pop\n    worker.send({},handle);\n    workers.unshift(worker);  \/\/再放回取出的pop\n}\n\n\n\/\/worker.js\nconst net = require(\x27net\x27);\nprocess.on(\x27message\x27, function (m, handle) {\n  start(handle);\n});\n\nvar buf = \x27hello Node.js\x27;\nvar res = [\x27HTTP\/1.1 200 OK\x27,\x27content-length:\x27\x2bbuf.length].join(\x27\\r\\n\x27)\x2b\x27\\r\\n\\r\\n\x27\x2bbuf;\n\nfunction start(handle) {\n    console.log(\x27got a connection on worker, pid = %d\x27, process.pid);\n    var socket = new net.Socket({\n        handle: handle\n    });\n    socket.readable = socket.writable = true;\n    socket.end(res);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/master\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e net = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27net\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fork = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27child_process\x27\x3c\/span\x3e).fork;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e workers = [];\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e; i\x2b\x2b) {\n   workers.push(fork(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/worker\x27\x3c\/span\x3e));\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e handle = net._createServerHandle(\x3cspan class=\x22hljs-string\x22\x3e\x270.0.0.0\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e);\nhandle.listen();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/将监听事件移到master中\x3c\/span\x3e\nhandle.onconnection = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr,handle\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e worker = workers.pop();  \x3cspan class=\x22hljs-comment\x22\x3e\/\/取出一个pop\x3c\/span\x3e\n    worker.send({},handle);\n    workers.unshift(worker);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/再放回取出的pop\x3c\/span\x3e\n}\n\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/worker.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e net = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27net\x27\x3c\/span\x3e);\nprocess.on(\x3cspan class=\x22hljs-string\x22\x3e\x27message\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3em, handle\x3c\/span\x3e) \x3c\/span\x3e{\n  start(handle);\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e buf = \x3cspan class=\x22hljs-string\x22\x3e\x27hello Node.js\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = [\x3cspan class=\x22hljs-string\x22\x3e\x27HTTP\/1.1 200 OK\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27content-length:\x27\x3c\/span\x3e\x2bbuf.length].join(\x3cspan class=\x22hljs-string\x22\x3e\x27\\r\\n\x27\x3c\/span\x3e)\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27\\r\\n\\r\\n\x27\x3c\/span\x3e\x2bbuf;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estart\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ehandle\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27got a connection on worker, pid = %d\x27\x3c\/span\x3e, process.pid);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e socket = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e net.Socket({\n        \x3cspan class=\x22hljs-attr\x22\x3ehandle\x3c\/span\x3e: handle\n    });\n    socket.readable = socket.writable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    socket.end(res);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里就经由master来掌控全局了. 当一个皇帝(worker)正在宠幸妃子的时候，master就会安排剩下的几个皇帝排队一个几个的来。 其实中间的handle就会我们具体的业务逻辑. 如同:\x3ccode\x3eapp.js\x3c\/code\x3e.\x3cbr\x3eok~ 我们再来看一下cluster模块实现多进程的具体写法.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3ecluster模块实现多进程\x3c\/h2\x3e\n\x3cp\x3e现在的cluster已经可以说完全做到的负载均衡。在\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004569460\x22\x3ecluster说明\x3c\/a\x3e我已经做了阐述了。我们来看一下具体的实现吧\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var cluster = require(\x27cluster\x27);\nvar http = require(\x27http\x27);\nvar numCPUs = require(\x27os\x27).cpus().length;\n\nif (cluster.isMaster) {\n    console.log(\x27[master] \x27 \x2b \x26quot;start master...\x26quot;);\n\n    for (var i = 0; i \x3c numCPUs; i\x2b\x2b) {\n         cluster.fork();\n    }\n\n    cluster.on(\x27listening\x27, function (worker, address) {\n        console.log(\x27[master] \x27 \x2b \x27listening: worker\x27 \x2b worker.id \x2b \x27,pid:\x27 \x2b worker.process.pid \x2b \x27, Address:\x27 \x2b address.address \x2b \x26quot;:\x26quot; \x2b address.port);\n    });\n\n} else if (cluster.isWorker) {\n     console.log(\x27[worker] \x27 \x2b \x26quot;start worker ...\x26quot; \x2b cluster.worker.id);\n    var num = 0;\n    http.createServer(function (req, res) {\n        num\x2b\x2b;\n        console.log(\x27worker\x27\x2bcluster.worker.id\x2b\x26quot;:\x26quot;\x2bnum);\n        res.end(\x27worker\x27\x2bcluster.worker.id\x2b\x27,PID:\x27\x2bprocess.pid);\n    }).listen(3000);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cluster = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cluster\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e http = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27http\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e numCPUs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27os\x27\x3c\/span\x3e).cpus().length;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cluster.isMaster) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27[master] \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22start master...\x22\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; numCPUs; i\x2b\x2b) {\n         cluster.fork();\n    }\n\n    cluster.on(\x3cspan class=\x22hljs-string\x22\x3e\x27listening\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eworker, address\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27[master] \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27listening: worker\x27\x3c\/span\x3e \x2b worker.id \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27,pid:\x27\x3c\/span\x3e \x2b worker.process.pid \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27, Address:\x27\x3c\/span\x3e \x2b address.address \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22:\x22\x3c\/span\x3e \x2b address.port);\n    });\n\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cluster.isWorker) {\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27[worker] \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22start worker ...\x22\x3c\/span\x3e \x2b cluster.worker.id);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e num = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    http.createServer(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) \x3c\/span\x3e{\n        num\x2b\x2b;\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27worker\x27\x3c\/span\x3e\x2bcluster.worker.id\x2b\x3cspan class=\x22hljs-string\x22\x3e\x22:\x22\x3c\/span\x3e\x2bnum);\n        res.end(\x3cspan class=\x22hljs-string\x22\x3e\x27worker\x27\x3c\/span\x3e\x2bcluster.worker.id\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27,PID:\x27\x3c\/span\x3e\x2bprocess.pid);\n    }).listen(\x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里使用的是HTTP模块，当然，完全也可以替换为socket模块. 不过由于这样书写，将集群和单边给混淆了。 所以，推荐写法是将具体业务逻辑独立出来.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var cluster = require(\x27cluster\x27);\nvar numCPUs = require(\x27os\x27).cpus().length;\n\nif (cluster.isMaster) {\n    console.log(\x27[master] \x27 \x2b \x26quot;start master...\x26quot;);\n\n    for (var i = 0; i \x3c numCPUs; i\x2b\x2b) {\n         cluster.fork();\n    }\n\n    cluster.on(\x27listening\x27, function (worker, address) {\n        console.log(\x27[master] \x27 \x2b \x27listening: worker\x27 \x2b worker.id \x2b \x27,pid:\x27 \x2b worker.process.pid \x2b \x27, Address:\x27 \x2b address.address \x2b \x26quot;:\x26quot; \x2b address.port);\n    });\n\n} else if (cluster.isWorker) {\n    require(\x27app.js\x27);\n}\n\/\/app.js就是开启具体的业务逻辑了\n\n\/\/app.js具体内容\nconst net = require(\x27net\x27);\n\/\/自动创建socket\nconst server = net.createServer(function(socket) { \/\/\x27connection\x27 listener\n    socket.on(\x27end\x27, function() {\n        console.log(\x27server disconnected\x27);\n    });\n    socket.on(\x27data\x27, function() {\n        socket.end(\x27hello\\r\\n\x27);\n    });\n});\n\/\/开启端口的监听\nserver.listen(8124, function() { \/\/\x27listening\x27 listener\n    console.log(\x27working\x27)\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cluster = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cluster\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e numCPUs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27os\x27\x3c\/span\x3e).cpus().length;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cluster.isMaster) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27[master] \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22start master...\x22\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; numCPUs; i\x2b\x2b) {\n         cluster.fork();\n    }\n\n    cluster.on(\x3cspan class=\x22hljs-string\x22\x3e\x27listening\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eworker, address\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27[master] \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27listening: worker\x27\x3c\/span\x3e \x2b worker.id \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27,pid:\x27\x3c\/span\x3e \x2b worker.process.pid \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27, Address:\x27\x3c\/span\x3e \x2b address.address \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22:\x22\x3c\/span\x3e \x2b address.port);\n    });\n\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cluster.isWorker) {\n    \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27app.js\x27\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/app.js就是开启具体的业务逻辑了\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/app.js具体内容\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e net = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27net\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/自动创建socket\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e server = net.createServer(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esocket\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27connection\x27 listener\x3c\/span\x3e\n    socket.on(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27server disconnected\x27\x3c\/span\x3e);\n    });\n    socket.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        socket.end(\x3cspan class=\x22hljs-string\x22\x3e\x27hello\\r\\n\x27\x3c\/span\x3e);\n    });\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/开启端口的监听\x3c\/span\x3e\nserver.listen(\x3cspan class=\x22hljs-number\x22\x3e8124\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27listening\x27 listener\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27working\x27\x3c\/span\x3e)\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接着我们开启服务，node master.js\x3cbr\x3e然后进行测试\x3cbr\x3e\x3ccode\x3esiege -c 100 -r 2 http:\/\/localhost:8124\x3c\/code\x3e\x3cbr\x3e我这里开启的是长连接. 每个worker处理的长连接数是有限的。所以，当有额外的连接到来时，worker会断开当前没有响应的连接，去处理新的连接。\x3cbr\x3e不过，平常我们都是使用HTTP开启 短连接，快速处理大并发的请求。\x3cbr\x3e这是我改成HTTP短连接之后的结果\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Transactions:                 200 hits\nAvailability:              100.00 %\nElapsed time:                2.09 secs\nData transferred:            0.00 MB\nResponse time:                0.02 secs\nTransaction rate:           95.69 trans\/sec\nThroughput:                0.00 MB\/sec\nConcurrency:                1.74\nSuccessful transactions:         200\nFailed transactions:               0\nLongest transaction:            0.05\nShortest transaction:            0.02\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3eTransactions:\x3c\/span\x3e                 \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e hits\n\x3cspan class=\x22hljs-string\x22\x3eAvailability:\x3c\/span\x3e              \x3cspan class=\x22hljs-number\x22\x3e100.00\x3c\/span\x3e %\nElapsed \x3cspan class=\x22hljs-string\x22\x3etime:\x3c\/span\x3e                \x3cspan class=\x22hljs-number\x22\x3e2.09\x3c\/span\x3e secs\nData \x3cspan class=\x22hljs-string\x22\x3etransferred:\x3c\/span\x3e            \x3cspan class=\x22hljs-number\x22\x3e0.00\x3c\/span\x3e MB\nResponse \x3cspan class=\x22hljs-string\x22\x3etime:\x3c\/span\x3e                \x3cspan class=\x22hljs-number\x22\x3e0.02\x3c\/span\x3e secs\nTransaction \x3cspan class=\x22hljs-string\x22\x3erate:\x3c\/span\x3e           \x3cspan class=\x22hljs-number\x22\x3e95.69\x3c\/span\x3e trans\/sec\n\x3cspan class=\x22hljs-string\x22\x3eThroughput:\x3c\/span\x3e                \x3cspan class=\x22hljs-number\x22\x3e0.00\x3c\/span\x3e MB\/sec\n\x3cspan class=\x22hljs-string\x22\x3eConcurrency:\x3c\/span\x3e                \x3cspan class=\x22hljs-number\x22\x3e1.74\x3c\/span\x3e\nSuccessful \x3cspan class=\x22hljs-string\x22\x3etransactions:\x3c\/span\x3e         \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e\nFailed \x3cspan class=\x22hljs-string\x22\x3etransactions:\x3c\/span\x3e               \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\nLongest \x3cspan class=\x22hljs-string\x22\x3etransaction:\x3c\/span\x3e            \x3cspan class=\x22hljs-number\x22\x3e0.05\x3c\/span\x3e\nShortest \x3cspan class=\x22hljs-string\x22\x3etransaction:\x3c\/span\x3e            \x3cspan class=\x22hljs-number\x22\x3e0.02\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那，怎么模拟大并发嘞？ \x3cbr\x3ee e e e e e e e e ...\x3cbr\x3e自己解决啊~ \x3cbr\x3e开玩笑的啦~ 不然我写blog是为了什么呢？ 就是为了传播知识.\x3cbr\x3e在介绍工具之前，我想先说几个关于性能的基本概念\x3cbr\x3eQPS(TPS),并发数,响应时间,吞吐量,吞吐率\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e你母鸡的性能测试theories\x3c\/h2\x3e\n\x3cp\x3e自从我们和服务器扯上关系后,我们前端的性能测试真的很多。但这也是我们必须掌握的tip. 本来前端宝宝只需要看看控制台，了解一下网页运行是否运行顺畅, 看看TimeLine，Profile 就可以了。 不过，作为一名有追求，有志于改变世界的童鞋来说。。。\x3cbr\x3emd~ 又要学了...\x3cbr\x3eok~ 好了，在进入正题之前，我再放一次 线上的测试结果.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Transactions:                 200 hits\nAvailability:              100.00 %\nElapsed time:               13.46 secs\nData transferred:            0.15 MB\nResponse time:                3.64 secs\nTransaction rate:           14.86 trans\/sec\nThroughput:                0.01 MB\/sec\nConcurrency:               54.15\nSuccessful transactions:         200\nFailed transactions:               0\nLongest transaction:           11.27\nShortest transaction:            0.01\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3eTransactions:\x3c\/span\x3e                 \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e hits\n\x3cspan class=\x22hljs-string\x22\x3eAvailability:\x3c\/span\x3e              \x3cspan class=\x22hljs-number\x22\x3e100.00\x3c\/span\x3e %\nElapsed \x3cspan class=\x22hljs-string\x22\x3etime:\x3c\/span\x3e               \x3cspan class=\x22hljs-number\x22\x3e13.46\x3c\/span\x3e secs\nData \x3cspan class=\x22hljs-string\x22\x3etransferred:\x3c\/span\x3e            \x3cspan class=\x22hljs-number\x22\x3e0.15\x3c\/span\x3e MB\nResponse \x3cspan class=\x22hljs-string\x22\x3etime:\x3c\/span\x3e                \x3cspan class=\x22hljs-number\x22\x3e3.64\x3c\/span\x3e secs\nTransaction \x3cspan class=\x22hljs-string\x22\x3erate:\x3c\/span\x3e           \x3cspan class=\x22hljs-number\x22\x3e14.86\x3c\/span\x3e trans\/sec\n\x3cspan class=\x22hljs-string\x22\x3eThroughput:\x3c\/span\x3e                \x3cspan class=\x22hljs-number\x22\x3e0.01\x3c\/span\x3e MB\/sec\n\x3cspan class=\x22hljs-string\x22\x3eConcurrency:\x3c\/span\x3e               \x3cspan class=\x22hljs-number\x22\x3e54.15\x3c\/span\x3e\nSuccessful \x3cspan class=\x22hljs-string\x22\x3etransactions:\x3c\/span\x3e         \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e\nFailed \x3cspan class=\x22hljs-string\x22\x3etransactions:\x3c\/span\x3e               \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\nLongest \x3cspan class=\x22hljs-string\x22\x3etransaction:\x3c\/span\x3e           \x3cspan class=\x22hljs-number\x22\x3e11.27\x3c\/span\x3e\nShortest \x3cspan class=\x22hljs-string\x22\x3etransaction:\x3c\/span\x3e            \x3cspan class=\x22hljs-number\x22\x3e0.01\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e根据上面的数据，就可以得出，你网页的大致性能了。\x3cbr\x3e恩~ let\x27s begin\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e吞吐率\x3c\/h3\x3e\n\x3cp\x3e关于吞吐率有多种解读，一种是:描绘web服务器单位时间处理请求的能力。根据这个描述,其单位就为: req\/sec. 另一种是: 单位时间内网络上传输的数据量。 而根据这个描述的话,他的单位就为: MB\/sec. \x3cbr\x3e而这个指标就是上面数据中的Throughput. 当然，肯定是越大越好了\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e吞吐量\x3c\/h3\x3e\n\x3cp\x3e这个和上面的吞吐率很有点关系的。 吞吐量是在没有时间的限制下，你一次测试的传输数据总和。 所以，没有时间条件的测试，都是耍流氓。\x3cbr\x3e这个对应于上面数据中的Data transferred.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e事务 \x26amp;\x26amp; TPS\x3c\/h3\x3e\n\x3cp\x3e熟悉数据库操作的童鞋，应该知道，在数据库中常常会提到一个叫做事务的概念。 在数据库中，一个事务，常常代表着一个具体的处理流程和结果. 比如，我现在想要的数据是 2013-2015年，数学期末考试成绩排名. 这个就是一个具体的事务，那么我们映射到数据库中就是，取出2013-2015年的排名，然后取平均值，返回最后的排序结果。 可以看出，事务并不单单指单一的操作，他是由一个或一个以上 操作组合而成具有 实际意义的。 那，反映到前端测试，我们应该怎样去定义呢？ 首先，我们需要了解，前端的网络交流其实就是 请求-响应模式. 也就是说，每一次请求，我们都可以理解为一次事务(trans).\x3cbr\x3e所以，TPS(transaction per second)就可以理解为1sec内，系统能够处理的请求数目.他的单位也就是: trans\/sec . 你当然也可以理解为seq\/sec.\x3cbr\x3e所以说，TPS 应该是衡量一个系统承载力最优的一个标识.\x3cbr\x3eTPS的计算公式很容易的出来就是: \x3ccode\x3eTransactions \/ Elapsed time\x3c\/code\x3e.\x3cbr\x3e不过, 凡事无绝对。 大家以后遇到测试的时候，应该就会知道的.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e并发数\x3c\/h3\x3e\n\x3cp\x3e就是服务器能够并发处理的连接数，具体我也母鸡他的单位是什么。 官方给出的解释是:\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eConcurrency is average number of simultaneous connections, a number which rises as server performance decreases.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这里我们就理解为，这就是一个衡量系统的承载力的一个标准吧。 当Concurrency 越高，表示 系统承载的越多，但性能也越低。\x3c\/p\x3e\n\x3cp\x3eok~ 但是我们如何利用这些数据，来确定我们的并发策略呢？ e e e e e e e ...\x3cbr\x3e当然， 一两次测试的结果真的没有什么卵用. 所以实际上，我们需要进行多次测试，然后画图才行。 当然，一些大公司，早就有一套完整的系统来计算你web服务器的瓶颈,以及 给出 最优的并发策略.\x3cbr\x3e废话不多说，我们来看看，如何分析，才能得出 比较好的 并发策略。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e探究并发策略\x3c\/h2\x3e\n\x3cp\x3e首先，我们这里的并发需要进行区分. 一个是并发的请求数，一个是并发的用户数. 这两个对于服务器是完全不同的需求。 \x3cbr\x3e假如100个用户同时向服务器分别进行10次请求，与1个用户向服务器连续进行1000次请求。两个的效果一样么？\x3c\/p\x3e\n\x3cp\x3e一个用户向服务器连续进行1000次请求的过程中，任何时刻服务器的网卡接受缓存区中只有来自该用户的1个请求，而100个用户同时向服务器分别进行10次请求的过程中，\x3cstrong\x3e服务器网卡接收缓冲区中最多有100个等待处理的请求，显然这时候服务器的压力更大。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e所以上面所说的 并发用户数和吞吐率 是完全不一样的. \x3cbr\x3e不过通常来说，我们更看重的是Concurrency(并发用户数). 因为这样更能反映出系统的 能力。  一般，我们都会对并发用户数进行一些限制，比如apache的maxClients参数. \x3cbr\x3eok~ 我们来实例分析一下吧.\x3c\/p\x3e\n\x3cp\x3e首先，我们拿到一份测试数据.\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/7xpsmd.com1.z0.glb.clouddn.com\/16-3-16\/81008435.jpg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/7xpsmd.com1.z0.glb.clouddn.com\/16-3-16\/81008435.jpg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e接着，我们进行数据分析.\x3cbr\x3e根据并发数和吞吐率的关系得出下列的图.\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/7xpsmd.com1.z0.glb.clouddn.com\/16-3-16\/21398793.jpg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/7xpsmd.com1.z0.glb.clouddn.com\/16-3-16\/21398793.jpg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3eOK~ 我们会发现从大约130并发数的地方开始，吞吐率开始下降，而且越多下降的越厉害。 主要是因为，在前面部分随着用户数的上升，空闲的系统资源得到充分的利用，当然就和正太曲线一样，总会有个顶点。 当到达一定值后，顶点就会出现了. 这就我们的系统的一个瓶颈.\x3cbr\x3e接着，我们细化分析，响应时间和并发用户数的相关性\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/7xpsmd.com1.z0.glb.clouddn.com\/16-3-16\/22714592.jpg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/7xpsmd.com1.z0.glb.clouddn.com\/16-3-16\/22714592.jpg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e同样额道理，当并发数到达130左右，正对每个req的响应时间开始增加，越大越抖，这适合吞吐率是相关的。 所以，我们可以得出一个结论，该次连接 并发数 最好设置为100~150之间。 当然，这样的分析很肤浅，不过，对于我们这些前端宝宝来说了解一下就足够了。\x3c\/p\x3e\n\x3cp\x3e接下来,我们使用工具来武装自己的头脑.\x3cbr\x3e这里主要介绍一个测试工具，siege.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e并发测试工具\x3c\/h2\x3e\n\x3cp\x3e事实上并发测试工具主要有3个siege,ab,还有webbench. 我这里之所以没介绍webbench的原因，因为，我在尝试安装他时，老子，电脑差点就挂了(我的MAC pro)... 不过后面，被聪明的我 巧妙的挽回~ 所以，如果有其他大神在MAC x11 上成功安装，可以私信小弟。让我学习学习。 \x3cbr\x3eok~ 吐槽完了。我们正式说一下siege吧\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3esiege\x3c\/h3\x3e\n\x3cp\x3e安装siege利用MAC神器 homebrew, 就是就和js前端世界的npm一样. \x3cbr\x3e安装ing:\x3cbr\x3e\x3ccode\x3ebrew install siege\x3c\/code\x3e\x3cbr\x3e安装成功--bingo\x3cbr\x3e接着，我们来看一下语法吧.\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e-c NUM 设置并发的用户数量.eg: -c 100;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e-r NUM 设置发送几轮的请求，即，总的请求数为: \x3ccode\x3e-cNum*-rNum\x3c\/code\x3e但是, -r不能和-t一起使用(为什么呢？你猜).eg: -r 20\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e-t NUM 测试持续时间，指你运行一次测试需要的时间，在timeout后，结束测试.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e-f file. 用来测试file里面的url路径 eg: \x3ccode\x3e-f girls.txt\x3c\/code\x3e.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e-b . 就是询问开不开启基准测试(benchmark)。 这个参数不太重要，有兴趣的同学，可以下去学习一下。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e关于-c -r我就不介绍了。 大家有兴趣，可以参考一下，我前一篇文章\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004569460\x22 target=\x22_blank\x22\x3e让你升级的网络知识\x3c\/a\x3e. 这里主要介绍一下 -f 参数.\x3cbr\x3e通常，如果我们想要测试多个页面的话，可以新建一个文件，在文件中创建 你想测试的所有网页地址.\x3cbr\x3e比如:\x3cbr\x3e\/\/文件名为 urls.txt\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22www.example.com\nwww.example.org\n123.45.67.89\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ewww\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.example\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.com\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3ewww\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.example\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.org\x3c\/span\x3e\n123\x3cspan class=\x22hljs-selector-class\x22\x3e.45\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.67\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.89\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后运行测试\x3cbr\x3e\x3ccode\x3esiege -f your\/file\/path.txt -c 100 -t 10s\x3c\/code\x3e\x3cbr\x3eOK~ 关于进程和测试的内容就介绍到这了。\x3c\/p\x3e\n\x3cp\x3e如果大家觉得，嘿, 这哥们写的文章不错呀~ \x3cbr\x3e能请我喝杯coffee，勉励写出更优质的文章吗？\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/7xpsmd.com1.z0.glb.clouddn.com\/16-3-15\/69326879.jpg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/7xpsmd.com1.z0.glb.clouddn.com\/16-3-15\/69326879.jpg\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e转载请注明出处和作者:\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004621734\x22\x3ehttps:\/\/segmentfault.com\/a\/1190000004621734\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>nodeJS多进程</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000004621734">https://segmentfault.com/a/1190000004621734</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ylr9i8j2eck/" target="_blank">https://alili.tech/archive/ylr9i8j2eck/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>