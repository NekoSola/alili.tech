<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="剖析Vue原理&amp;实现双向绑定MVVM"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>剖析Vue原理&amp;实现双向绑定MVVM | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/q9z5086nqn/",
				"appid": "1613049289050283", 
				"title": "剖析Vue原理&amp;实现双向绑定MVVM | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ggpzotyu5y4/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/vduhd1llcj/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fq9z5086nqn%2f&text=%e5%89%96%e6%9e%90Vue%e5%8e%9f%e7%90%86%26%e5%ae%9e%e7%8e%b0%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9aMVVM"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fq9z5086nqn%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fq9z5086nqn%2f&text=%e5%89%96%e6%9e%90Vue%e5%8e%9f%e7%90%86%26%e5%ae%9e%e7%8e%b0%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9aMVVM"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fq9z5086nqn%2f&title=%e5%89%96%e6%9e%90Vue%e5%8e%9f%e7%90%86%26%e5%ae%9e%e7%8e%b0%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9aMVVM"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fq9z5086nqn%2f&is_video=false&description=%e5%89%96%e6%9e%90Vue%e5%8e%9f%e7%90%86%26%e5%ae%9e%e7%8e%b0%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9aMVVM"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%89%96%e6%9e%90Vue%e5%8e%9f%e7%90%86%26%e5%ae%9e%e7%8e%b0%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9aMVVM&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fq9z5086nqn%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fq9z5086nqn%2f&title=%e5%89%96%e6%9e%90Vue%e5%8e%9f%e7%90%86%26%e5%ae%9e%e7%8e%b0%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9aMVVM"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq9z5086nqn%2f&title=%e5%89%96%e6%9e%90Vue%e5%8e%9f%e7%90%86%26%e5%ae%9e%e7%8e%b0%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9aMVVM"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq9z5086nqn%2f&title=%e5%89%96%e6%9e%90Vue%e5%8e%9f%e7%90%86%26%e5%ae%9e%e7%8e%b0%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9aMVVM"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq9z5086nqn%2f&title=%e5%89%96%e6%9e%90Vue%e5%8e%9f%e7%90%86%26%e5%ae%9e%e7%8e%b0%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9aMVVM"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">剖析Vue原理&amp;实现双向绑定MVVM</h1><div class="meta"><div class="postdate"><time datetime="2019-02-05" itemprop="datePublished">2019-02-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e本文能帮你做什么？\x3cbr\x3e1、了解vue的双向数据绑定原理以及核心代码模块\x3cbr\x3e2、缓解好奇心的同时了解如何实现双向绑定\x3cbr\x3e为了便于说明原理与实现，本文相关代码主要摘自\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue源码\x3c\/a\x3e, 并进行了简化改造，相对较简陋，并未考虑到数组的处理、数据的循环依赖等，也难免存在一些问题，欢迎大家指正。不过这些并不会影响大家的阅读和理解，相信看完本文后对大家在阅读vue源码的时候会更有帮助\x26lt;\x3cbr\x3e本文所有相关代码均在github上面可找到 \x3ca href=\x22https:\/\/github.com\/DMQ\/mvvm\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/DMQ\/mvvm\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch5\x3e相信大家对mvvm双向绑定应该都不陌生了，一言不合上代码，下面先看一个本文最终实现的效果吧，和vue一样的语法，如果还不了解双向绑定，猛戳\x3ca href=\x22https:\/\/www.google.com.hk\/search?q=%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGoogle\x3c\/a\x3e\n\x3c\/h5\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv id=\x26quot;mvvm-app\x26quot;\x3e\n    \x3cinput type=\x26quot;text\x26quot; v-model=\x26quot;word\x26quot;\x3e\n    \x3cp\x3e\x22{{\x22word\x22}}\x22\x3c\/p\x3e\n    \x3cbutton v-on:click=\x26quot;sayHi\x26quot;\x3echange model\x3c\/button\x3e\n\x3c\/div\x3e\n\n\x3cscript src=\x26quot;.\/js\/observer.js\x26quot;\x3e\x3c\/script\x3e\n\x3cscript src=\x26quot;.\/js\/watcher.js\x26quot;\x3e\x3c\/script\x3e\n\x3cscript src=\x26quot;.\/js\/compile.js\x26quot;\x3e\x3c\/script\x3e\n\x3cscript src=\x26quot;.\/js\/mvvm.js\x26quot;\x3e\x3c\/script\x3e\n\x3cscript\x3e\n    var vm = new MVVM({\n        el: \x27#mvvm-app\x27,\n        data: {\n            word: \x27Hello World!\x27\n        },\n        methods: {\n            sayHi: function() {\n                this.word = \x27Hi, everybody!\x27;\n            }\n        }\n    });\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs django\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22mvvm-app\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-model\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22word\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22word\x22}}\x22\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-on:click\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22sayHi\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3echange model\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22.\/js\/observer.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22.\/js\/watcher.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22.\/js\/compile.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22.\/js\/mvvm.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22actionscript\x22\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MVVM({\n        el: \x3cspan class=\x22hljs-string\x22\x3e\x27#mvvm-app\x27\x3c\/span\x3e,\n        data: {\n            word: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello World!\x27\x3c\/span\x3e\n        },\n        methods: {\n            sayHi: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.word = \x3cspan class=\x22hljs-string\x22\x3e\x27Hi, everybody!\x27\x3c\/span\x3e;\n            }\n        }\n    });\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e效果：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVBQXk\x22 src=\x22https:\/\/static.alili.tech\/img\/bVBQXk\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e几种实现双向绑定的做法\x3c\/h3\x3e\n\x3cp\x3e目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。\x3c\/p\x3e\n\x3cp\x3e实现数据绑定的做法有大致如下几种：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e发布者-订阅者模式（backbone.js）\x3c\/p\x3e\n\x3cp\x3e脏值检查（angular.js） \x3cbr\x3e\x3c\/p\x3e\n\x3cp\x3e数据劫持（vue.js）\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e发布者-订阅者模式:\x3c\/strong\x3e 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 \x3ccode\x3evm.set(\x27property\x27, value)\x3c\/code\x3e，这里有篇文章讲的比较详细，有兴趣可点\x3ca href=\x22http:\/\/www.html-js.com\/article\/Study-of-twoway-data-binding-JavaScript-talk-about-JavaScript-every-day\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e这种方式现在毕竟太low了，我们更希望通过 \x3ccode\x3evm.property = value \x3c\/code\x3e这种方式更新数据，同时自动更新视图，于是有了下面两种方式\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e脏值检查:\x3c\/strong\x3e angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 \x3ccode\x3esetInterval()\x3c\/code\x3e 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eDOM事件，譬如用户输入文本，点击按钮等。( ng-click )\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eXHR响应事件 ( $http )\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e浏览器Location变更事件 ( $location )\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTimer事件( $timeout , $interval )\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行 $digest() 或 $apply()\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e数据劫持:\x3c\/strong\x3e vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过\x3ccode\x3eObject.defineProperty()\x3c\/code\x3e来劫持各个属性的\x3ccode\x3esetter\x3c\/code\x3e，\x3ccode\x3egetter\x3c\/code\x3e，在数据变动时发布消息给订阅者，触发相应的监听回调。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e思路整理\x3c\/h3\x3e\n\x3cp\x3e已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过\x3ccode\x3eObject.defineProperty()\x3c\/code\x3e来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/defineProperty\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e\x3cbr\x3e整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点：\x3cbr\x3e1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者\x3cbr\x3e2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数\x3cbr\x3e3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图\x3cbr\x3e4、mvvm入口函数，整合以上三者\x3c\/p\x3e\n\x3cp\x3e上述流程如图所示：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVBQYu\x22 src=\x22https:\/\/static.alili.tech\/img\/bVBQYu\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e1、实现Observer\x3c\/h3\x3e\n\x3cp\x3eok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let\x27s do it\x3cbr\x3e我们知道可以利用\x3ccode\x3eObeject.defineProperty()\x3c\/code\x3e来监听属性变动\x3cbr\x3e那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上    \x3ccode\x3esetter\x3c\/code\x3e和\x3ccode\x3egetter\x3c\/code\x3e\x3cbr\x3e这样的话，给这个对象的某个值赋值，就会触发\x3ccode\x3esetter\x3c\/code\x3e，那么就能监听到了数据变化。。相关代码可以是这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var data = {name: \x27kindeng\x27};\nobserve(data);\ndata.name = \x27dmq\x27; \/\/ 哈哈哈，监听到值变化了 kindeng --\x3e dmq\n\nfunction observe(data) {\n    if (!data || typeof data !== \x27object\x27) {\n        return;\n    }\n    \/\/ 取出所有属性遍历\n    Object.keys(data).forEach(function(key) {\n        defineReactive(data, key, data[key]);\n    });\n};\n\nfunction defineReactive(data, key, val) {\n    observe(val); \/\/ 监听子属性\n    Object.defineProperty(data, key, {\n        enumerable: true, \/\/ 可枚举\n        configurable: false, \/\/ 不能再define\n        get: function() {\n            return val;\n        },\n        set: function(newVal) {\n            console.log(\x27哈哈哈，监听到值变化了 \x27, val, \x27 --\x3e \x27, newVal);\n            val = newVal;\n        }\n    });\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = {name: \x3cspan class=\x22hljs-string\x22\x3e\x27kindeng\x27\x3c\/span\x3e};\nobserve(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27dmq\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 哈哈哈，监听到值变化了 kindeng --\x26gt; dmq\x3c\/span\x3e\n\nfunction observe(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e || typeof \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 取出所有属性遍历\x3c\/span\x3e\n    Object.keys(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e).forEach(function(key) {\n        defineReactive(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e, key, \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e[key]);\n    });\n};\n\nfunction defineReactive(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e, key, \x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e) {\n    observe(\x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听子属性\x3c\/span\x3e\n    Object.defineProperty(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e, key, {\n        enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可枚举\x3c\/span\x3e\n        configurable: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不能再define\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: function() {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e;\n        },\n        \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e: function(newVal) {\n            console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27哈哈哈，监听到值变化了 \x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27 --\x26gt; \x27\x3c\/span\x3e, newVal);\n            \x3cspan class=\x22hljs-keyword\x22\x3eval\x3c\/span\x3e = newVal;\n        }\n    });\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ... 省略\nfunction defineReactive(data, key, val) {\n    var dep = new Dep();\n    observe(val); \/\/ 监听子属性\n\n    Object.defineProperty(data, key, {\n        \/\/ ... 省略\n        set: function(newVal) {\n            if (val === newVal) return;\n            console.log(\x27哈哈哈，监听到值变化了 \x27, val, \x27 --\x3e \x27, newVal);\n            val = newVal;\n            dep.notify(); \/\/ 通知所有订阅者\n        }\n    });\n}\n\nfunction Dep() {\n    this.subs = [];\n}\nDep.prototype = {\n    addSub: function(sub) {\n        this.subs.push(sub);\n    },\n    notify: function() {\n        this.subs.forEach(function(sub) {\n            sub.update();\n        });\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... 省略\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineReactive\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata, key, val\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep();\n    observe(val); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听子属性\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(data, key, {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... 省略\x3c\/span\x3e\n        set: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (val === newVal) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27哈哈哈，监听到值变化了 \x27\x3c\/span\x3e, val, \x3cspan class=\x22hljs-string\x22\x3e\x27 --\x26gt; \x27\x3c\/span\x3e, newVal);\n            val = newVal;\n            dep.notify(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通知所有订阅者\x3c\/span\x3e\n        }\n    });\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDep\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs = [];\n}\nDep.prototype = {\n    \x3cspan class=\x22hljs-attr\x22\x3eaddSub\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esub\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs.push(sub);\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3enotify\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esub\x3c\/span\x3e) \x3c\/span\x3e{\n            sub.update();\n        });\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？\x3cbr\x3e没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且\x3ccode\x3evar dep = new Dep();\x3c\/code\x3e是在 \x3ccode\x3edefineReactive\x3c\/code\x3e方法内部定义的，所以想通过\x3ccode\x3edep\x3c\/code\x3e添加订阅者，就必须要在闭包内操作，所以我们可以在    \x3ccode\x3egetter\x3c\/code\x3e里面动手脚：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Observer.js\n\/\/ ...省略\nObject.defineProperty(data, key, {\n    get: function() {\n        \/\/ 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除\n        Dep.target \x26amp;\x26amp; dep.addDep(Dep.target);\n        return val;\n    }\n    \/\/ ... 省略\n});\n\n\/\/ Watcher.js\nWatcher.prototype = {\n    get: function(key) {\n        Dep.target = this;\n        this.value = data[key];    \/\/ 这里会触发属性的getter，从而添加订阅者\n        Dep.target = null;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Observer.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...省略\x3c\/span\x3e\nObject.defineProperty(data, key, {\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除\x3c\/span\x3e\n        Dep.target \x26amp;\x26amp; dep.addDep(Dep.target);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e val;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... 省略\x3c\/span\x3e\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Watcher.js\x3c\/span\x3e\nWatcher.prototype = {\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(key)\x3c\/span\x3e \x3c\/span\x3e{\n        Dep.target = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = data[key];    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里会触发属性的getter，从而添加订阅者\x3c\/span\x3e\n        Dep.target = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能，\x3ca href=\x22https:\/\/github.com\/DMQ\/mvvm\/blob\/master\/js\/observer.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整代码\x3c\/a\x3e。那么接下来就是实现Compile了\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e2、实现Compile\x3c\/h3\x3e\n\x3cp\x3ecompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVBQY3\x22 src=\x22https:\/\/static.alili.tech\/img\/bVBQY3\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点\x3ccode\x3eel\x3c\/code\x3e转换成文档碎片\x3ccode\x3efragment\x3c\/code\x3e进行解析编译操作，解析完成，再将\x3ccode\x3efragment\x3c\/code\x3e添加回原来的真实dom节点中\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Compile(el) {\n    this.$el = this.isElementNode(el) ? el : document.querySelector(el);\n    if (this.$el) {\n        this.$fragment = this.node2Fragment(this.$el);\n        this.init();\n        this.$el.appendChild(this.$fragment);\n    }\n}\nCompile.prototype = {\n    init: function() { this.compileElement(this.$fragment); },\n    node2Fragment: function(el) {\n        var fragment = document.createDocumentFragment(), child;\n        \/\/ 将原生节点拷贝到fragment\n        while (child = el.firstChild) {\n            fragment.appendChild(child);\n        }\n        return fragment;\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3efunction Compile(el) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$el = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isElementNode(el) ? el : document.querySelector(el);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$el) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$fragment = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.node2Fragment(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$el);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.init();\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$el.appendChild(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$fragment);\n    }\n}\nCompile.prototype = {\n    init: function() { \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.compileElement(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$fragment); },\n    node2Fragment: function(el) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fragment = document.createDocumentFragment(), child;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将原生节点拷贝到fragment\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (child = el.firstChild) {\n            fragment.appendChild(child);\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fragment;\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ecompileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Compile.prototype = {\n    \/\/ ... 省略\n    compileElement: function(el) {\n        var childNodes = el.childNodes, me = this;\n        [].slice.call(childNodes).forEach(function(node) {\n            var text = node.textContent;\n            var reg = \/\\{\\{(.*)\\}\\}\/;    \/\/ 表达式文本\n            \/\/ 按元素节点方式编译\n            if (me.isElementNode(node)) {\n                me.compile(node);\n            } else if (me.isTextNode(node) \x26amp;\x26amp; reg.test(text)) {\n                me.compileText(node, RegExp.$1);\n            }\n            \/\/ 遍历编译子节点\n            if (node.childNodes \x26amp;\x26amp; node.childNodes.length) {\n                me.compileElement(node);\n            }\n        });\n    },\n\n    compile: function(node) {\n        var nodeAttrs = node.attributes, me = this;\n        [].slice.call(nodeAttrs).forEach(function(attr) {\n            \/\/ 规定：指令以 v-xxx 命名\n            \/\/ 如 \x3cspan v-text=\x26quot;content\x26quot;\x3e\x3c\/span\x3e 中指令为 v-text\n            var attrName = attr.name;    \/\/ v-text\n            if (me.isDirective(attrName)) {\n                var exp = attr.value; \/\/ content\n                var dir = attrName.substring(2);    \/\/ text\n                if (me.isEventDirective(dir)) {\n                    \/\/ 事件指令, 如 v-on:click\n                    compileUtil.eventHandler(node, me.$vm, exp, dir);\n                } else {\n                    \/\/ 普通指令\n                    compileUtil[dir] \x26amp;\x26amp; compileUtil[dir](node, me.$vm, exp);\n                }\n            }\n        });\n    }\n};\n\n\/\/ 指令处理集合\nvar compileUtil = {\n    text: function(node, vm, exp) {\n        this.bind(node, vm, exp, \x27text\x27);\n    },\n    \/\/ ...省略\n    bind: function(node, vm, exp, dir) {\n        var updaterFn = updater[dir \x2b \x27Updater\x27];\n        \/\/ 第一次初始化视图\n        updaterFn \x26amp;\x26amp; updaterFn(node, vm[exp]);\n        \/\/ 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher\n        new Watcher(vm, exp, function(value, oldValue) {\n            \/\/ 一旦属性值有变化，会收到通知执行此更新函数，更新视图\n            updaterFn \x26amp;\x26amp; updaterFn(node, value, oldValue);\n        });\n    }\n};\n\n\/\/ 更新函数\nvar updater = {\n    textUpdater: function(node, value) {\n        node.textContent = typeof value == \x27undefined\x27 ? \x27\x27 : value;\n    }\n    \/\/ ...省略\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3eCompile.prototype = {\n    \/\/ ... 省略\n    compileElement: function(el) {\n        var childNodes = el.childNodes, me = this;\n        [].slice.call(childNodes).forEach(function(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e) {\n            var\x3c\/span\x3e text = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3etextContent\x3c\/span\x3e;\n            var reg = \/\\{\\{(.*)\\}\\}\/;    \/\/ 表达式文本\n            \/\/ 按元素节点方式编译\n            if (me.isElementNode(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e)) {\n                me\x3c\/span\x3e.compile(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e);\n            } else\x3c\/span\x3e if (me.isTextNode(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e) \x26amp;\x26amp; reg\x3c\/span\x3e.test(text)) {\n                me.compileText(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, RegExp\x3c\/span\x3e.$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n            }\n            \/\/ 遍历编译子节点\n            if (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3echildNodes\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3echildNodes\x3c\/span\x3e.length) {\n                me.compileElement(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e);\n            }\n        });\n    },\n\n    compile\x3c\/span\x3e: function(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e) {\n        var\x3c\/span\x3e nodeAttrs = \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eattributes\x3c\/span\x3e, me = this;\n        [].slice.call(nodeAttrs).forEach(function(attr) {\n            \/\/ 规定：指令以 v-xxx 命名\n            \/\/ 如 \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;span v-text=\x22content\x22\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/span\x26gt;\x3c\/span\x3e 中指令为 v-text\n            var attrName = attr.name;    \/\/ v-text\n            if (me.isDirective(attrName)) {\n                var exp = attr.value; \/\/ content\n                var dir = attrName.substring(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);    \/\/ text\n                if (me.isEventDirective(dir)) {\n                    \/\/ 事件指令, 如 v-on:click\n                    compileUtil.eventHandler(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, me\x3c\/span\x3e.$vm, exp, dir);\n                } else {\n                    \/\/ 普通指令\n                    compileUtil[dir] \x26amp;\x26amp; compileUtil[dir](\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, me\x3c\/span\x3e.$vm, exp);\n                }\n            }\n        });\n    }\n};\n\n\/\/ 指令处理集合\nvar compileUtil = {\n    text: function(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, vm\x3c\/span\x3e, exp) {\n        this.bind(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, vm\x3c\/span\x3e, exp, \x27text\x27);\n    },\n    \/\/ ...省略\n    bind: function(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, vm\x3c\/span\x3e, exp, dir) {\n        var updaterFn = updater[dir \x2b \x27Updater\x27];\n        \/\/ 第一次初始化视图\n        updaterFn \x26amp;\x26amp; updaterFn(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, vm\x3c\/span\x3e[exp]);\n        \/\/ 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher\n        new Watcher(vm, exp, function(value, oldValue) {\n            \/\/ 一旦属性值有变化，会收到通知执行此更新函数，更新视图\n            updaterFn \x26amp;\x26amp; updaterFn(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, value\x3c\/span\x3e, oldValue);\n        });\n    }\n};\n\n\/\/ 更新函数\nvar updater = {\n    textUpdater: function(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, value\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3etextContent\x3c\/span\x3e = typeof value == \x27undefined\x27 ? \x27\x27 : value;\n    }\n    \/\/ ...省略\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了\x22{{\x22\x22}}\x22表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如\x3ccode\x3e\x26lt;span v-text=\x22content\x22 other-attr\x3c\/code\x3e中\x3ccode\x3ev-text\x3c\/code\x3e便是指令，而\x3ccode\x3eother-attr\x3c\/code\x3e不是指令，只是普通的属性。\x3cbr\x3e监听数据、绑定更新函数的处理是在\x3ccode\x3ecompileUtil.bind()\x3c\/code\x3e这个方法中，通过\x3ccode\x3enew Watcher()\x3c\/code\x3e添加回调来接收数据变化的通知\x3c\/p\x3e\n\x3cp\x3e至此，一个简单的Compile就完成了，\x3ca href=\x22https:\/\/github.com\/DMQ\/mvvm\/blob\/master\/js\/compile.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整代码\x3c\/a\x3e。接下来要看看Watcher这个订阅者的具体实现了\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e3、实现Watcher\x3c\/h3\x3e\n\x3cp\x3eWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:\x3cbr\x3e1、在自身实例化时往属性订阅器(dep)里面添加自己\x3cbr\x3e2、自身必须有一个update()方法\x3cbr\x3e3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。\x3cbr\x3e如果有点乱，可以回顾下前面的思路整理\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Watcher(vm, exp, cb) {\n    this.cb = cb;\n    this.vm = vm;\n    this.exp = exp;\n    \/\/ 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解\n    this.value = this.get(); \n}\nWatcher.prototype = {\n    update: function() {\n        this.run();    \/\/ 属性值变化收到通知\n    },\n    run: function() {\n        var value = this.get(); \/\/ 取到最新值\n        var oldVal = this.value;\n        if (value !== oldVal) {\n            this.value = value;\n            this.cb.call(this.vm, value, oldVal); \/\/ 执行Compile中绑定的回调，更新视图\n        }\n    },\n    get: function() {\n        Dep.target = this;    \/\/ 将当前订阅者指向自己\n        var value = this.vm[exp];    \/\/ 触发getter，添加自己到属性订阅器中\n        Dep.target = null;    \/\/ 添加完毕，重置\n        return value;\n    }\n};\n\/\/ 这里再次列出Observer和Dep，方便理解\nObject.defineProperty(data, key, {\n    get: function() {\n        \/\/ 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除\n        Dep.target \x26amp;\x26amp; dep.addDep(Dep.target);\n        return val;\n    }\n    \/\/ ... 省略\n});\nDep.prototype = {\n    notify: function() {\n        this.subs.forEach(function(sub) {\n            sub.update(); \/\/ 调用订阅者的update方法，通知变化\n        });\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWatcher\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(vm, exp, cb)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb = cb;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm = vm;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.exp = exp;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get(); \n}\nWatcher.prototype = {\n    update: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.run();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 属性值变化收到通知\x3c\/span\x3e\n    },\n    run: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 取到最新值\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldVal = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (value !== oldVal) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = value;\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm, value, oldVal); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行Compile中绑定的回调，更新视图\x3c\/span\x3e\n        }\n    },\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        Dep.target = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将当前订阅者指向自己\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm[exp];    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 触发getter，添加自己到属性订阅器中\x3c\/span\x3e\n        Dep.target = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加完毕，重置\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value;\n    }\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里再次列出Observer和Dep，方便理解\x3c\/span\x3e\nObject.defineProperty(data, key, {\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除\x3c\/span\x3e\n        Dep.target \x26amp;\x26amp; dep.addDep(Dep.target);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e val;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... 省略\x3c\/span\x3e\n});\nDep.prototype = {\n    notify: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(sub)\x3c\/span\x3e \x3c\/span\x3e{\n            sub.update(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用订阅者的update方法，通知变化\x3c\/span\x3e\n        });\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实例化\x3ccode\x3eWatcher\x3c\/code\x3e的时候，调用\x3ccode\x3eget()\x3c\/code\x3e方法，通过\x3ccode\x3eDep.target = watcherInstance\x3c\/code\x3e标记订阅者是当前watcher实例，强行触发属性定义的\x3ccode\x3egetter\x3c\/code\x3e方法，\x3ccode\x3egetter\x3c\/code\x3e方法执行的时候，就会在属性的订阅器\x3ccode\x3edep\x3c\/code\x3e添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。\x3c\/p\x3e\n\x3cp\x3eok, Watcher也已经实现了，\x3ca href=\x22https:\/\/github.com\/DMQ\/mvvm\/blob\/master\/js\/watcher.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整代码\x3c\/a\x3e。\x3cbr\x3e基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e , 在\x3ccode\x3esrc\x3c\/code\x3e 目录可找到vue源码。\x3c\/p\x3e\n\x3cp\x3e最后来讲讲MVVM入口文件的相关逻辑和实现吧，相对就比较简单了~\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e4、实现MVVM\x3c\/h3\x3e\n\x3cp\x3eMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -\x26gt; 视图更新；视图交互变化(input) -\x26gt; 数据model变更的双向绑定效果。\x3c\/p\x3e\n\x3cp\x3e一个简单的MVVM构造器是这样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function MVVM(options) {\n    this.$options = options;\n    var data = this._data = this.$options.data;\n    observe(data, this);\n    this.$compile = new Compile(options.el || document.body, this)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3efunction MVVM(options) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options = options;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._data = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e;\n    observe(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$compile = new Compile(options.el || document.body, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过\x3ccode\x3evar vm = new MVVM({data:{name: \x27kindeng\x27\x22}}\x22); vm._data.name = \x27dmq\x27; \x3c\/code\x3e这样的方式来改变数据。\x3c\/p\x3e\n\x3cp\x3e显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的：\x3cbr\x3e\x3ccode\x3evar vm = new MVVM({data: {name: \x27kindeng\x27\x22}}\x22); vm.name = \x27dmq\x27;\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function MVVM(options) {\n    this.$options = options;\n    var data = this._data = this.$options.data, me = this;\n    \/\/ 属性代理，实现 vm.xxx -\x3e vm._data.xxx\n    Object.keys(data).forEach(function(key) {\n        me._proxy(key);\n    });\n    observe(data, this);\n    this.$compile = new Compile(options.el || document.body, this)\n}\n\nMVVM.prototype = {\n    _proxy: function(key) {\n        var me = this;\n        Object.defineProperty(me, key, {\n            configurable: false,\n            enumerable: true,\n            get: function proxyGetter() {\n                return me._data[key];\n            },\n            set: function proxySetter(newVal) {\n                me._data[key] = newVal;\n            }\n        });\n    }\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMVVM\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options = options;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e data = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._data = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options.data, me = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 属性代理，实现 vm.xxx -\x26gt; vm._data.xxx\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(data).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n        me._proxy(key);\n    });\n    observe(data, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$compile = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Compile(options.el || \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n}\n\nMVVM.prototype = {\n    \x3cspan class=\x22hljs-attr\x22\x3e_proxy\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e me = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(me, key, {\n            \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproxyGetter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e me._data[key];\n            },\n            \x3cspan class=\x22hljs-attr\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproxySetter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e) \x3c\/span\x3e{\n                me._data[key] = newVal;\n            }\n        });\n    }\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里主要还是利用了\x3ccode\x3eObject.defineProperty()\x3c\/code\x3e这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了\x3ccode\x3evm._data\x3c\/code\x3e的属性值，达到鱼目混珠的效果，哈哈\x3c\/p\x3e\n\x3cp\x3e至此，全部模块和功能已经完成了，如本文开头所承诺的两点。一个简单的MVVM模块已经实现，其思想和原理大部分来自经过简化改造的vue\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码\x3c\/a\x3e，猛戳\x3ca href=\x22https:\/\/github.com\/DMQ\/mvvm\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e可以看到本文的所有相关代码。\x3cbr\x3e由于本文内容偏实践，所以代码量较多，且不宜列出大篇幅代码，所以建议想深入了解的童鞋可以再次结合本文源代码来进行阅读，这样会更加容易理解和掌握。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e总结\x3c\/h3\x3e\n\x3cp\x3e本文主要围绕“几种实现双向绑定的做法”、“实现Observer”、“实现Compile”、“实现Watcher”、“实现MVVM”这几个模块来阐述了双向绑定的原理和实现。并根据思路流程渐进梳理讲解了一些细节思路和比较关键的内容点，以及通过展示部分关键代码讲述了怎样一步步实现一个双向绑定MVVM。文中肯定会有一些不够严谨的思考和错误，欢迎大家指正，有兴趣欢迎一起探讨和改进~\x3c\/p\x3e\n\x3cp\x3e最后，感谢您的阅读！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>剖析Vue原理&amp;实现双向绑定MVVM</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006599500">https://segmentfault.com/a/1190000006599500</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/q9z5086nqn/" target="_blank">https://alili.tech/archive/q9z5086nqn/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>