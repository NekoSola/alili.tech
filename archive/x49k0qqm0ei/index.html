<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React入门及资源指引"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React入门及资源指引 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/x49k0qqm0ei/",
				"appid": "1613049289050283", 
				"title": "React入门及资源指引 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/zjb9v9zdgm/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/o4ae0jhqvpp/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fx49k0qqm0ei%2f&text=React%e5%85%a5%e9%97%a8%e5%8f%8a%e8%b5%84%e6%ba%90%e6%8c%87%e5%bc%95"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fx49k0qqm0ei%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fx49k0qqm0ei%2f&text=React%e5%85%a5%e9%97%a8%e5%8f%8a%e8%b5%84%e6%ba%90%e6%8c%87%e5%bc%95"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fx49k0qqm0ei%2f&title=React%e5%85%a5%e9%97%a8%e5%8f%8a%e8%b5%84%e6%ba%90%e6%8c%87%e5%bc%95"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fx49k0qqm0ei%2f&is_video=false&description=React%e5%85%a5%e9%97%a8%e5%8f%8a%e8%b5%84%e6%ba%90%e6%8c%87%e5%bc%95"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e5%85%a5%e9%97%a8%e5%8f%8a%e8%b5%84%e6%ba%90%e6%8c%87%e5%bc%95&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fx49k0qqm0ei%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fx49k0qqm0ei%2f&title=React%e5%85%a5%e9%97%a8%e5%8f%8a%e8%b5%84%e6%ba%90%e6%8c%87%e5%bc%95"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx49k0qqm0ei%2f&title=React%e5%85%a5%e9%97%a8%e5%8f%8a%e8%b5%84%e6%ba%90%e6%8c%87%e5%bc%95"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx49k0qqm0ei%2f&title=React%e5%85%a5%e9%97%a8%e5%8f%8a%e8%b5%84%e6%ba%90%e6%8c%87%e5%bc%95"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fx49k0qqm0ei%2f&title=React%e5%85%a5%e9%97%a8%e5%8f%8a%e8%b5%84%e6%ba%90%e6%8c%87%e5%bc%95"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React入门及资源指引</h1><div class="meta"><div class="postdate"><time datetime="2019-02-05" itemprop="datePublished">2019-02-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e因为工作需要，这段时间一直在看\x3cstrong\x3eReact\x3c\/strong\x3e相关的东西，不得不感叹\x3cstrong\x3eFacebook\x3c\/strong\x3e在开源项目和软件架构方面的实力，其在\x3cstrong\x3eReact\x3c\/strong\x3e中提出的一些设计思想非常新颖，极大的简化了前端开发的代码逻辑。本文将介绍\x3cstrong\x3eReact\x3c\/strong\x3e相关的基础知识，以及本人在学习过程发现的好的学习资料。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eReact简介\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e什么是React\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3eReact\x3c\/strong\x3e是\x3cstrong\x3eFacebook\x3c\/strong\x3e开源的一套用来创建用户界面的JS库，它重在界面渲染，因此很多人认为\x3cstrong\x3eReact\x3c\/strong\x3e是传统\x3cstrong\x3eMVC\x3c\/strong\x3e中的\x3cstrong\x3eV\x3c\/strong\x3e（视图），使用\x3cstrong\x3eReact\x3c\/strong\x3e你可以轻松构建可交互、基于状态的、可复用的UI组件。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eFacebook\x3c\/strong\x3e创建\x3cstrong\x3eReact\x3c\/strong\x3e的初衷是想使得构建随着时间流逝数据不断变化的大规模应用程序变得简单，\x3cstrong\x3eFacebook\x3c\/strong\x3e工程师认为传统的\x3cstrong\x3eMVC\x3c\/strong\x3e模式已经不适用于构建这种大规模应用，因为当系统中的模型和对应的视图越来越多时，其复杂程度就会迅速扩大，加之可能存在的双向数据流动，导致程序难以理解和调试。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eReact\x3c\/strong\x3e有两个主要思想：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e简单\x3cbr\x3e仅仅表达出你的应用在任意时间点应该呈现的样子（这种展现是可以预测的，给编写测试代码带来了极大的便利），数据驱动UI，当底层数据变了，\x3cstrong\x3eReact\x3c\/strong\x3e会自动处理所有用户界面的更新，通过Dom Diff算法尽可能少的减少Dom变化以提高性能。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e声明式\x3cbr\x3e当数据（状态）变化时，\x3cstrong\x3eReact\x3c\/strong\x3e内部知道该怎样去局部更新需要变化的部分视图。也就是说在在编程时我们只需要告诉\x3cstrong\x3eReact\x3c\/strong\x3e想要的是什么，而不需要告诉\x3cstrong\x3eReact\x3c\/strong\x3e怎么样一步步Dom操作才能到达需要的效果。可以参见\x3ca href=\x22http:\/\/stackoverflow.com\/questions\/33655534\/difference-between-declarative-and-imperative-in-react-js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e关于声明式和命令式编程的区别。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e为什么使用React\x3c\/h3\x3e\n\x3cp\x3e选择React无非是看中了它所表现出的突出优点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e组件化思想，使应用更加容易维护和复用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVirtual Dom使得React不仅可以在浏览器端渲染也可以运行在服务端，这为编写同构应用提供了可能\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eDom Diff算法尽可能的减少Dom操作，提高应用的性能\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e单向数据流使应用逻辑可容易理解，基于状态的视图更新使应用状态可预测，便于测试\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e当然React也不是完美的，它的JSX语法虽然提供了强大的功能，但它却将HTML结构分散进了JS文件中，不利于初学者对网页整体结构的把握，同时Css-in-js的写法也背离了Web标准倡导的表现结构逻辑分离的思想。如何取舍还要看实际情况。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e快速开始React学习\x3c\/h2\x3e\n\x3cp\x3e想要快速开始学习\x3cstrong\x3eReact\x3c\/strong\x3e，\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/tutorial.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方tutorial\x3c\/a\x3e是个不错的选择，上面包含了构建\x3cstrong\x3eReact\x3c\/strong\x3e组件的关键性内容。如果你想亲手敲两行代码体验一下，你可以下载一个\x3ca href=\x22https:\/\/facebook.github.io\/react\/downloads\/react-15.3.0.zip\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3estarter kit\x3c\/a\x3e，里面包含了相关依赖文件和一些实例，当然你也可以使用\x3ca href=\x22https:\/\/jsfiddle.net\/reactjs\/69z2wepo\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejsfiddle\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22reactjs\/69z2wepo\/\x22 data-typeid=\x220\x22\x3e点击预览\x3c\/button\x3e在线体验。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eJSX\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3eJSX\x3c\/strong\x3e是\x3cstrong\x3eReact\x3c\/strong\x3e提供的用来快速创建\x3cstrong\x3eReact\x3c\/strong\x3e树节点的语法糖，它能够使用类似HTML的语法创建\x3cstrong\x3eJavaScript\x3c\/strong\x3e对象，当然你也可以使用提供的\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/displaying-data.html#react-without-jsx\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eapi\x3c\/a\x3e手动创建。\x3c\/p\x3e\n\x3cp\x3e例如我们事先创建了一个Nav组件，那么在对应的Dom节点渲染它时就可以像下面一样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var navElement = \x3cNav className=\x27nav\x27 \/\x3e;  \/\/jsx语法，react会自动将其转换成javascript 对象\nReactDOM.render(navElement, \/*真实dom节点*\/);  \/\/渲染\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e navElement = \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eNav\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27nav\x27\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e;  \/\/jsx语法，react会自动将其转换成javascript 对象\nReactDOM.render(navElement, \/*真实dom节点*\/);  \/\/渲染\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eJavaScript 表达式\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3eJSX\x3c\/strong\x3e语法的一个重要特点是能够使用JavaScript表达式，通过在属性值或子组件混入js表达式，能够轻易的写出更加复杂的组件，js表达式需要用一对大括号{}包裹起来。\x3c\/p\x3e\n\x3cp\x3e例如属性值混入js表达式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/显示不同的样式类\nvar person = \x3cPerson className={window.isLoggedIn ? \x27logged\x27 : null \/\x3e;\n\/\/输入框禁止输入\nvar input = \x3cinput type=\x27button\x27 disabled={false} \/\x3e; \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/显示不同的样式类\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person = \x26lt;Person className={window.isLoggedIn ? \x27logged\x27 : null \/\x26gt;;\n\/\/输入框禁止输入\nvar input = \x26lt;input type=\x27button\x27 disabled={false} \/\x26gt;; \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e子组件混入js表达式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/根据isLoggedIn的值嵌入不同的子组件\nvar content = \x3cContainer\x3e {window.isLoggedIn ? \x3cNav \/\x3e : \x3cLogin \/\x3e}\x3c\/Container\x3e;\n\n\/\/数组循环创建多个子组件，key属性不能省略，否则会报错\nvar results = [1, 2, 3, 4];\nvar list = \x3col\x3e\n            {results.map(function(result, index) {\n                return \x3cli key={index}\x3e{result}\x3c\/li\x3e;\n             })}\n           \x3c\/ol\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/根据isLoggedIn的值嵌入不同的子组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e content = \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eContainer\x3c\/span\x3e\x26gt;\x3c\/span\x3e {window.isLoggedIn ? \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eNav\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e : \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eLogin\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eContainer\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/数组循环创建多个子组件，key属性不能省略，否则会报错\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e results = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e];\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e list = \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eol\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n            {results.map(function(result, index) {\n                return \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{index}\x3c\/span\x3e\x26gt;\x3c\/span\x3e{result}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e;\n             })}\n           \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eol\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\n\x3cstrong\x3eJSX\x3c\/strong\x3e语法有几个需要注意的地方：\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eJSX既能解析React组件标签也能解析HTML标签，但是React组件必须是首字母大写，如上面的Container；HTML标签则照常小写即可，如ol\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3estyle属性值必须是JavaScript对象\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eJSX最外层的标签必须是唯一的，如果有多个可以用div标签将其包裹起来\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e因为JSX本身是JavaScript，HTML一些与JavaScript关键字有冲突的属性，如class、for都要转换成相应的className、htmlFor，更多不同参见\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/jsx-gotchas.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejsx-gotchas\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e循环创建多个同类子组件的时候，要带上key属性，且key值是唯一的，如上例的多个\x3cstrong\x3eli\x3c\/strong\x3e标签\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e组件\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3eReact\x3c\/strong\x3e提倡组件化思想，认为一个应用应该是多个互相独立的组件构成的大组件，每个组件只关心自己部分的逻辑。如下图的评论界面所示，一个评论组件CommentBoxComponent由CommentListComponent和FormBoxComponent组件组成，相应的CommentListComponent组件又由CommentItemComponent和ButtonComponent组成。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVBo51\x22 src=\x22https:\/\/static.alili.tech\/img\/bVBo51\x22 alt=\x22组件划分\x22 title=\x22组件划分\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e组件的划分原则\x3c\/h3\x3e\n\x3cp\x3e对于初学者而言，想要很好的对UI进行组件划分可能比较困难，但是遵循一些组件划分原则是有益的：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e单一职责，一个组件应该只做一件事情，当你发现在一个组件做了太多事情的时候，应该考虑将其拆分为更小的子组件。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e根据数据模型拆分组件，因为React是基于数据来渲染UI，所以让你的组件仅仅是用来表现数据模型的某个部分通常是正确的选择。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e构建纯组件，一个纯组件通常没有内部状态（state，后面会讲到），它用来渲染的数据完全来自于输入的props，使用相同的props来渲染相同的纯组件多次将得到相同的UI，不存在内部状态导致渲染不同。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e如何创建组件\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3eReact\x3c\/strong\x3e提供了createClass来创建组件，它接受一个对象作为参数，该对象包含一些属性和函数来具体描述一个组件，其中render函数是必须的，其他的状态初始化函数以及生命周期相关的函数都是可选的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/注意Component首字母大写\nvar Component = React.createClass({\n  getIntialState: function(){}, \/\/初始化组件状态\n  getDefaultProps： function(){}, \/\/初始化组件的默认属性\n  \n  propTypes: {}, \/\/规定属性的存在性和类型\n  \n  \/\/一些生命周期相关函数\n  componentWillMount: function(){}, \/\/组件被嵌入之前触发\n  componentDidMount: function(){}, \/\/组件被嵌入之后触发\n  componentWillReceiveProps: function(){}, \/\/当props有改变时触发\n  componentWillUnmount: function(){}, \/\/组件被注销之前触发\n  \/\/渲染函数，不能省略    \n  render: function() {\n    return \x3ch1\x3eHello \x3c\/h1\x3e ;     \n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/注意Component首字母大写\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Component = React.createClass({\n  \x3cspan class=\x22hljs-attr\x22\x3egetIntialState\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化组件状态\x3c\/span\x3e\n  getDefaultProps： \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化组件的默认属性\x3c\/span\x3e\n  \n  propTypes: {}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/规定属性的存在性和类型\x3c\/span\x3e\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/一些生命周期相关函数\x3c\/span\x3e\n  componentWillMount: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/组件被嵌入之前触发\x3c\/span\x3e\n  componentDidMount: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/组件被嵌入之后触发\x3c\/span\x3e\n  componentWillReceiveProps: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/当props有改变时触发\x3c\/span\x3e\n  componentWillUnmount: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/组件被注销之前触发\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/渲染函数，不能省略    \x3c\/span\x3e\n  render: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e ;     \n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上是ES5的写法，如果你看了一些脚手架项目，你会发现有些使用了ES6的语法，ES6创建组件的语法有很大的不同：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Component extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n    \/\/组件状态\n    };\n  }\n  static defaultProps = {\n    \/\/组件属性    \n  };\n  render() {\n    return (\n      \x3cdiv onClick={this.handleClick}\x3e\n        You {text} this. Click to toggle.\n      \x3c\/div\x3e\n    );\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/组件状态\x3c\/span\x3e\n    };\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e defaultProps = {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/组件属性    \x3c\/span\x3e\n  };\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleClick}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        You {text} this. Click to toggle.\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    );\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以看到使用了ES6语法的组件构建很像在编写面向对象编程时创建类，更多写法的不同，可以参见\x3ca href=\x22http:\/\/bbs.reactnative.cn\/topic\/15\/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ees5-es6写法对照表\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e区分props和state\x3c\/h2\x3e\n\x3cp\x3e前面我们有涉及props和state这个两个概念，这里做一下解释。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3eprops\x3c\/h3\x3e\n\x3cp\x3e当我们在使用定义好的组件时，可以向其添加一些属性，在组件定义的内部，可以通过this.props来访问这些属性，如下在render方法里渲染动态数据：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Component = React.createClass({\n    getDefaultProps: function(){\n      return {\n        name: \x27world\x27\n      }\n    },\n    propTypes: {\n    name: React.PropTypes.string \/\/设置属性的类型\n    },\n    render: function(){\n        return (\n            \x3ch1\x3eHello, {this.props.name}!\x3c\/h1\x3e \/\/访问name属性\n        );\n    }\n});\n\nReactDOM.render(\x3cComponent name=\x26quot;Handsome\x26quot; \/\x3e, document.body);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Component = React.createClass({\n    \x3cspan class=\x22hljs-attr\x22\x3egetDefaultProps\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27world\x27\x3c\/span\x3e\n      }\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3epropTypes\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: React.PropTypes.string \x3cspan class=\x22hljs-comment\x22\x3e\/\/设置属性的类型\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello, {this.props.name}!\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/访问name属性\x3c\/span\x3e\n        );\n    }\n});\n\nReactDOM.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eComponent\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22Handsome\x22\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, document.body);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中getDefaultProps用来设置默认的属性值，\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/reusable-components.html#prop-validation\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epropTypes\x3c\/a\x3e来设置属性的类型，在使用时如果属性类型不匹配会提示。\x3c\/p\x3e\n\x3cp\x3ethis.props是只读的，它通常用来传递来自父组件的数据，也是\x3cstrong\x3eReact\x3c\/strong\x3e构建单向数据流的方式。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3estate\x3c\/h3\x3e\n\x3cp\x3e相同的组件之所以能够表现出不一样的UI是因为它们内部拥有不同的状态（states），每个组件都可以拥有自己的state，并且可以在需要的时候通过props传递给子组件。组件可以通过setState函数来修改内部的状态，同时触发界面的渲染。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var ParentComponent = React.createClass({\n  getInitialState: function(){\n    return {\n      name: \x27Tyler McGinnis\x27,\n      friend: \x27Tom\x27 \n    }\n  },\n  handleClick: function(e){\n    this.setState({name: \x27Tim\x27}); \/\/更改状态\n  },\n  render: function(){\n    return (\n      \x3cdiv\x3e\n        \x3ch3\x3e Name: {this.state.name} \x3c\/h3\x3e\n        \/\/点击触发事件，调用handleClick改变组件状态\n        \x3cbutton onClick={this.hanleClick}\x3echange name\x3c\/button\x3e\n        \x3cComponent name={this.state.friend} \/\x3e \/\/传递状态到子组件\n      \x3c\/div\x3e\n    )\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ParentComponent = React.createClass({\n  \x3cspan class=\x22hljs-attr\x22\x3egetInitialState\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Tyler McGinnis\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3efriend\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Tom\x27\x3c\/span\x3e \n    }\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3ehandleClick\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Tim\x27\x3c\/span\x3e}); \x3cspan class=\x22hljs-comment\x22\x3e\/\/更改状态\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e Name: {this.state.name} \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \/\/点击触发事件，调用handleClick改变组件状态\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.hanleClick}\x3c\/span\x3e\x26gt;\x3c\/span\x3echange name\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eComponent\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.state.friend}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e \/\/传递状态到子组件\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    )\n  }\n});\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里需要注意的是getInitialState是用来初始化组件内部状态的默认值，不要在该方法里面使用this.props，除非某个属性有明确的语义是被用来初始化state的，详细请参看\x3ca href=\x22https:\/\/facebook.github.io\/react\/tips\/props-in-getInitialState-as-anti-pattern.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3ediffrent\x3c\/h3\x3e\n\x3cp\x3eprops是只读的，不能够在组件内部修改，它是父组件向子组件传递数据的途径；state是组件自身的状态，它不能是父组件传递过来的数据，并且state是可以改变的。\x3c\/p\x3e\n\x3cp\x3e合理的状态操作是创建多个只负责渲染数据的无状态（stateless）组件，在它们的上层创建一个有状态（stateful）组件并把它的状态通过 props 传给子组件。这个有状态的组件封装了所有用户的交互逻辑，而这些无状态组件则负责声明式地渲染数据。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e生命周期\x3c\/h2\x3e\n\x3cp\x3e如前面组件创建里提到，组件创建时可以提供几个生命周期函数，这些函数决定了组件在不同的时期进行的操作。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3ecomponentWillMount\x3c\/strong\x3e: 在初始化渲染执行前立即调用且仅调用一次。如果在这个方法内部调用setState并不会触发重新渲染，你可以将一些只需要执行一次的操作放在这个函数里。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ecomponentDidMount\x3c\/strong\x3e:在初始化渲染之后，立即调用一次，这个时候你可以访问虚拟Dom节点。我们可以在这个方法中与其他JavaScript框架进行集成、处理一些渲染后的逻辑（比如说绑定一些事件等）、发送Ajax请求或是设置定时器方法(setTimeout\/setInterval)等。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ecomponentWillReceiveProps\x3c\/strong\x3e:初始化渲染时不会被调用，只有当props放生改变时才会被调用。该方法可以作为React在prop传入之后，render()方法执行之前更新state的合适时机。旧的props可以通过this.props获取到。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ecomponentWillUnmount\x3c\/strong\x3e:在组件从DOM中移除的时候立刻被调用我们可以在该方法中执行任何必要的清理，比如无效的定时器，或者清除在componentDidMount()中创建的DOM元素等。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e另外React还提供了一个用来优化渲染的周期函数\x3cstrong\x3eshouldComponentUpdate\x3c\/strong\x3e，它可以用来判断一次状态改变是否需要重新渲染，更多生命周期函数介绍参见\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/component-specs.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e事件系统\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3eReact\x3c\/strong\x3e有内建的跨浏览器的\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/interactivity-and-dynamic-uis.html#under-the-hood-autobinding-and-event-delegation\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e事件系统\x3c\/a\x3e，你可以在组件里以添加属性的方式绑定事件和相应的处理函数，如上面例子中ParentComponent组件里通过设置onClick属性绑定事件的处理函数handleClick。这种事件绑定方法极大的方便了事件操作，不用再像以前先定位到Dom节点，再通过addEventListener绑定事件，还要用removeEventListener解绑。当组件注销时，react会自动帮我们解绑事件。更多React支持的事件，请参见\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/events.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3e进阶\x3c\/h2\x3e\n\x3cp\x3e如果你是刚刚接触\x3cstrong\x3eReact\x3c\/strong\x3e，那么当你阅读官方的\x3ca href=\x22http:\/\/reactjs.cn\/react\/docs\/tutorial.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etutorial\x3c\/a\x3e文档时，会觉得这玩意原来这么简单，无非是将页面功能组件化，调用为数不多的几个api，按照教程一步一步来很快就编写出一个评论应用。当你想利用脚手架快速搭建企业级的\x3cstrong\x3eReact\x3c\/strong\x3e开发环境时，你会也许会用到\x3ca href=\x22https:\/\/github.com\/kriasoft\/react-starter-kit\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-starter-kit\x3c\/a\x3e，但是他却有点“名不符实”，因为匮乏的文档说明，让其对新手并不友好。相比之下\x3ca href=\x22https:\/\/github.com\/erikras\/react-redux-universal-hot-example\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-redux-universal-hot-example\x3c\/a\x3e则更加易于理解和学习。值得注意的是学习\x3cstrong\x3eReact\x3c\/strong\x3e，仅仅是学习框架本身是不够，因为当你阅读代码的过程中，你会发现\x3cstrong\x3enpm\x3c\/strong\x3e是基本的；\x3cstrong\x3ewebpack\x3c\/strong\x3e也是必须的；你还要知道\x3cstrong\x3eES6\x3c\/strong\x3e相关语法，相应的你要懂得使用\x3cstrong\x3eBabel\x3c\/strong\x3e来转换\x3cstrong\x3eES5\x3c\/strong\x3e；更进阶你要开始学习全新的程序设计模式\x3cstrong\x3eFlux\x3c\/strong\x3e和\x3cstrong\x3eRedux\x3c\/strong\x3e来管理应用的状态等等。学习这些知识不可能一蹴而就，当你遇到某个解不开的点时，不妨先跳过，随着学习的深入，当你回头来看时就会有种恍然大悟的感觉。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3e资源索引\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/spyrestudios.com\/the-only-react-js-tutorials-and-resources-youll-need\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eThe Only React.js Tutorials and Resources You’ll Need\x3c\/a\x3e，介绍了很多React学校相关的资源，上面的每篇文章都值得一读。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.cocoachina.com\/webapp\/20150721\/12692.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e一看就懂的ReactJs入门教程（精华版）\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.w3cplus.com\/react\/react-beginner-intro.html?utm_source=tuicool\x26amp;utm_medium=referral\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact的一些概念\x3c\/a\x3e对React的一些概念进行了阐述。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/tylermcginnis.com\/react-js-tutorial-pt-1-a-comprehensive-guide-to-building-apps-with-react-js-8ce321b125ba#.8n8bgdfir\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact.js Tutorial Pt 1: A Comprehensive Guide to Building Apps with React.js\x3c\/a\x3e 非常不错的tutorial，作者思路很清晰，一步步讲解并且附有实例，系列文章还没更新完\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2015\/03\/react\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact 入门实例教程\x3c\/a\x3e，阮一峰写的实例教程，里面包含了各个关键知识点的实例代码。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.oschina.net\/question\/2012764_242688\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ees5-es6语法对比\x3c\/a\x3e ，比较详细的react es5-es6语法对照表，看完它对理解一些项目代码比较有用\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/web-design-weekly.com\/2015\/01\/29\/opinionated-guide-react-js-best-practices-conventions\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact style guide\x3c\/a\x3e，react 代码书写风格的一篇文章，遵守大家都在用的一些规则，对阅读源码很有帮助。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/imweb.io\/topic\/57711e37f0a5487b05f325b5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e浅谈 React、Flux 与 Redux\x3c\/a\x3e，对React、Flux、Redux之间的关系进行了很好的阐述。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/teropa.info\/blog\/2015\/09\/10\/full-stack-redux-tutorial.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFull-Stack Redux Tutorial\x3c\/a\x3e，这篇文章介绍了如何使用Redux构建同构应用，通过一个投票应用，全面介绍了整个开发流程，非常值得阅读。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React入门及资源指引</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006495917">https://segmentfault.com/a/1190000006495917</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/x49k0qqm0ei/" target="_blank">https://alili.tech/archive/x49k0qqm0ei/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>