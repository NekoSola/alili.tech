<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="生成器（Generator）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>生成器（Generator） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/3w4rq2vmuyy/",
				"appid": "1613049289050283", 
				"title": "生成器（Generator） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-11T02:30:49"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/4q3cte6e2zu/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ajzba2rl2ch/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f3w4rq2vmuyy%2f&text=%e7%94%9f%e6%88%90%e5%99%a8%ef%bc%88Generator%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f3w4rq2vmuyy%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f3w4rq2vmuyy%2f&text=%e7%94%9f%e6%88%90%e5%99%a8%ef%bc%88Generator%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f3w4rq2vmuyy%2f&title=%e7%94%9f%e6%88%90%e5%99%a8%ef%bc%88Generator%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f3w4rq2vmuyy%2f&is_video=false&description=%e7%94%9f%e6%88%90%e5%99%a8%ef%bc%88Generator%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%94%9f%e6%88%90%e5%99%a8%ef%bc%88Generator%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f3w4rq2vmuyy%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f3w4rq2vmuyy%2f&title=%e7%94%9f%e6%88%90%e5%99%a8%ef%bc%88Generator%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3w4rq2vmuyy%2f&title=%e7%94%9f%e6%88%90%e5%99%a8%ef%bc%88Generator%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3w4rq2vmuyy%2f&title=%e7%94%9f%e6%88%90%e5%99%a8%ef%bc%88Generator%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3w4rq2vmuyy%2f&title=%e7%94%9f%e6%88%90%e5%99%a8%ef%bc%88Generator%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">生成器（Generator）</h1><div class="meta"><div class="postdate"><time datetime="2019-02-11" itemprop="datePublished">2019-02-11</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e生成器（Generator）可以说是在 ES2015 中最为强悍的一个新特性，因为生成器是涉及到 ECMAScript 引擎运行底层的特性，生成器可以实现一些从前无法想象的事情。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e来龙\x3c\/h2\x3e\n\x3cp\x3e生成器第一次出现在 CLU\x3csup\x3e1\x3c\/sup\x3e 语言中，这门语言是由 MIT （美国麻省理工大学）的 Barbara Liskov 教授和她的学生们在 1974 年至 1975 年所设计和开发出来的。这门语言虽然古老，但是却提出了很多如今被广泛使用的编程语言特性，而生成器便是其中的一个。\x3c\/p\x3e\n\x3cp\x3e而在 CLU 语言之后，有 Icon 语言\x3csup\x3e2\x3c\/sup\x3e、Python 语言\x3csup\x3e3\x3c\/sup\x3e、C# 语言\x3csup\x3e4\x3c\/sup\x3e和 Ruby 语言\x3csup\x3e5\x3c\/sup\x3e等都受 CLU 语言影响，实现了生成器的特性。在 CLU 语言和 C# 语言中，生成器被称为迭代器（Iterator），而在 Ruby 语言中称为枚举器（Enumerator）。\x3c\/p\x3e\n\x3cp\x3e然而无论它被成为什么，所被赋予的能力都是相同的。生成器的主要目的是用于通过一段程序，来持续被迭代或枚举出符合某个公式或算法的有序数列中的元素，而这个程序便是用于实现这个公式或算法，而不需要将目标数列完整写出。\x3c\/p\x3e\n\x3cp\x3e我们来举一个简单的例子，斐波那契数列是非常著名一个理论数学基础数列。它的前两项是 0 和 1，从第三项开始所有的元素都遵循这样的一条公式：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000004993566\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000004993566\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e那么，依靠程序我们可以这样实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fibonacci = [ 0, 1 ]\nconst n = 10\n\nfor (let i = 2; i \x3c n - 1; \x2b\x2bi) {\n  fibonacci.push(fibonacci[i - 1] \x2b fibonacci[i - 2])\n}\nconsole.log(fibonacci) \/\/=\x3e [0, 1, 1, 2, 3, 5, 8, 13, 21]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fibonacci = [ \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ]\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e n = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e; i \x26lt; n - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \x2b\x2bi) {\n  fibonacci.push(fibonacci[i - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] \x2b fibonacci[i - \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e])\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(fibonacci) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; [0, 1, 1, 2, 3, 5, 8, 13, 21]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是这种需要确定一个数量来取得相应的数列，但若需要按需获取元素，那就可以使用生成器来实现了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* fibo() {\n  let a = 0\n  let b = 1\n\n  yield a\n  yield b\n\n  while (true) {\n    let next = a \x2b b\n    a = b\n    b = next\n    yield next\n  }\n}\n\nlet generator = fibo()\n\nfor (var i = 0; i \x3c 10; i\x2b\x2b)\n  console.log(generator.next().value) \/\/=\x3e 0 1 1 2 3 5 8 13 21 34 55\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3efibo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e b = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e a\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e b\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e next = a \x2b b\n    a = b\n    b = next\n    \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e next\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e generator = fibo()\n\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; i\x2b\x2b)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(generator.next().value) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; 0 1 1 2 3 5 8 13 21 34 55\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你一定会对这段代码感到很奇怪：为什么 \x3ccode\x3efunction\x3c\/code\x3e 语句后会有一个 \x3ccode\x3e*\x3c\/code\x3e？为什么函数里使用了 \x3ccode\x3ewhile (true)\x3c\/code\x3e 却没有因为进入死循环而导致程序卡死？而这个 \x3ccode\x3eyield\x3c\/code\x3e 又是什么语句？k4\x3c\/p\x3e\n\x3cp\x3e不必着急，我们一一道来。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e基本概念\x3c\/h2\x3e\n\x3cp\x3e生成器是 ES2015 中同时包含语法和底层支持的一个新特性，其中有几个相关的概念是需要先了解的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e生成器函数（Generator Function）\x3c\/h3\x3e\n\x3cp\x3e生成器函数是 ES2015 中生成器的最主要表现方式，它与普通的函数语法差别在于，在 \x3ccode\x3efunction\x3c\/code\x3e 语句之后和函数名之前，有一个 \x3ccode\x3e*\x3c\/code\x3e 作为它是一个生成器函数的标示符。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* fibo() {\n  \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3efibo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e生成器函数的定义并不是强制性使用声明式的，与普通函数一样可以使用定义式进行定义。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fnName = function*() { \/* ... *\/ }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fnName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e*(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/* ... *\/\x3c\/span\x3e }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e生成器函数的函数体内容将会是所生成的生成器的执行内容，在这些内容之中，\x3ccode\x3eyield\x3c\/code\x3e 语句的引入使得生成器函数与普通函数有了区别。\x3ccode\x3eyield\x3c\/code\x3e 语句的作用与 \x3ccode\x3ereturn\x3c\/code\x3e 语句有些相似，但 \x3ccode\x3eyield\x3c\/code\x3e 语句的作用并非退出函数体，而是\x3cstrong\x3e切出当前函数的运行时\x3c\/strong\x3e（此处为一个类协程，Semi-coroutine），并与此同时可以讲一个值（可以是任何类型）带到主线程中。\x3c\/p\x3e\n\x3cp\x3e我们以一个比较形象的例子来做比喻，你可以把整个生成器运行时看成一条长长的瑞士卷（\x3ccode\x3ewhile (true)\x3c\/code\x3e 则就是无限长的），ECMAScript 引擎在每一次遇到 \x3ccode\x3eyield\x3c\/code\x3e 就要切一刀，而切面所成的“纹路”则是 \x3ccode\x3eyield\x3c\/code\x3e 出来的值。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006771593\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006771593\x22 alt=\x22Swiss Roll\x22 title=\x22Swiss Roll\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e生成器（Generator）\x3c\/h3\x3e\n\x3cp\x3e从计算机科学角度上看，生成器是一种类协程或半协程（Semi-coroutine），生成器提供了一种可以通过特定语句或方法来使生成器的执行对象（Execution）暂停，而这语句一般都是 \x3ccode\x3eyield\x3c\/code\x3e。上面的斐波那契数列的生成器便是通过 \x3ccode\x3eyield\x3c\/code\x3e 语句将每一次的公式计算结果切出执行对象，并带到主线程上来。\x3c\/p\x3e\n\x3cp\x3e在 ES2015 中，\x3ccode\x3eyield\x3c\/code\x3e 可以将一个值带出协程，而主线程也可以通过生成器对象的方法将一个值带回生成器的执行对象中去。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const inputValue = yield outputValue\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e inputValue = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e outputValue\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e生成器切出执行对象并带出 \x3ccode\x3eoutputValue\x3c\/code\x3e，主线程经过同步或异步的处理后，通过 \x3ccode\x3e.next(val)\x3c\/code\x3e 方法将 \x3ccode\x3einputValue\x3c\/code\x3e 带回生成器的执行对象中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e使用方法\x3c\/h2\x3e\n\x3cp\x3e在了解了生成器的背景知识后，我们就可以开始来看看在 ES2015 中，我们要如何使用这个新特性。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e构建生成器函数\x3c\/h3\x3e\n\x3cp\x3e使用生成器的第一步自然是要构建一个生成器函数，以生成相对应的生成器对象。假设我们需要按照下面这个公式来生成一个数列，并以生成器作为构建基础。（此处我们暂不作公式化简）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000004993568\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000004993568\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e为了使得生成器能够不断根据公式输出数列元素，我们与上面的斐波那契数列实例一样，使用 \x3ccode\x3ewhile (true)\x3c\/code\x3e 循环以保持程序的不断执行。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* genFn() {\n  let a = 2\n  \n  yield a\n  \n  while (true) {\n    yield a = a \/ (2 * a \x2b 1)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egenFn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e a\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e a = a \/ (\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * a \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在定义首项为 2 之后，首先将首项通过 \x3ccode\x3eyield\x3c\/code\x3e 作为第一个值切出，其后通过循环和公式将每一项输出。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e启动生成器\x3c\/h3\x3e\n\x3cp\x3e生成器函数不能直接作为函数来使用，执行生成器函数会返回一个生成器对象，将用于运行生成器内容和接受其中的值。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const gen = genFn()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e gen = genFn()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e生成器是是通过生成器函数的一个生成器（类）实例，我们可以简单地用一段伪代码来说明生成器这个类的基本内容和用法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Generator {\n  next(value)\n  throw(error)\n  [@iterator]()\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGenerator\x3c\/span\x3e \x3c\/span\x3e{\n  next(value)\n  \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e(error)\n  [@iterator]()\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e操作方法（语法）\x3c\/th\x3e\n\x3cth\x3e方法内容\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3egenerator.next(value)\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e获取下一个生成器切出状态。（第一次执行时为第一个切出状态）。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3egenerator.throw(error)\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e向当前生成器执行对象抛出一个错误，并终止生成器的运行。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3egenerator[@iterator]\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd\x3e\n\x3ccode\x3e@iterator\x3c\/code\x3e 即 \x3ccode\x3eSymbol.iterator\x3c\/code\x3e，为生成器提供实现可迭代对象的方法。使其可以直接被 \x3ccode\x3efor...of\x3c\/code\x3e 循环语句直接使用。\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e其中 \x3ccode\x3e.next(value)\x3c\/code\x3e 方法会返回一个状态对象，其中包含当前生成器的运行状态和所返回的值。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  value: Any,\n  done: Boolean\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: Any,\n  \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eBoolean\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e生成器执行对象会不断检查生成器的状态，一旦遇到生成器内的最后一个 \x3ccode\x3eyield\x3c\/code\x3e 语句或第一个 \x3ccode\x3ereturn\x3c\/code\x3e 语句时，生成器便进入终止状态，即状态对象中的 \x3ccode\x3edone\x3c\/code\x3e 属性会从 \x3ccode\x3efalse\x3c\/code\x3e 变为 \x3ccode\x3etrue\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e而 \x3ccode\x3e.throw(error)\x3c\/code\x3e 方法会提前让生成器进入终止状态，并将 \x3ccode\x3eerror\x3c\/code\x3e 作为错误抛出。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e运行生成器内容\x3c\/h3\x3e\n\x3cp\x3e因为生成器对象自身也是一种可迭代对象，所以我们直接使用 \x3ccode\x3efor...of\x3c\/code\x3e 循环将其中输出的值打印出来。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (const a of gen) {\n  if (a \x3c 1\/100) break\n    \n  console.log(a)\n}\n\/\/=\x3e\n\/\/  2\n\/\/  0.4\n\/\/  0.2222222222\n\/\/  ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e gen) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (a \x26lt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\/\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e\n    \n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a)\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  2\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  0.4\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  0.2222222222\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e深入理解\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e运行模式\x3c\/h3\x3e\n\x3cp\x3e为了能更好地理解生成器内部的运行模式，我们将上面的这个例子以流程图的形式展示出来。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000004993545\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000004993545\x22 alt=\x22图解 Generator\x22 title=\x22图解 Generator\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e生成器是一种可以被暂停的运行时，在这个例子中，每一次 \x3ccode\x3eyield\x3c\/code\x3e 都会将当前生成器执行对象暂停并输出一个值到主线程。而这在生成器内部的代码是不需要做过多体现的，只需要清楚 \x3ccode\x3eyield\x3c\/code\x3e 语句是暂停的标志及其作用即可。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e生成器函数以及生成器对象的检测\x3c\/h3\x3e\n\x3cp\x3e事实上 ES2015 的生成器函数也是一种构造函数或类，开发者定义的每一个生成器函数都可以看做对应生成器的类，而所产生的生成器都是这些类的派生实例。\x3c\/p\x3e\n\x3cp\x3e在很多基于类（或原型）的库中，我们可以经常看到这样的代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Point(x, y) {\n  if (!(this instanceof Point)) return new Point(x, y)\n  \/\/ ...\n}\n\nconst p1 = new Point(1, 2)\nconst p2 = Point(2, 3)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePoint\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex, y\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Point)) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Point(x, y)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e p1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Point(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e p2 = Point(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这一句代码的作用是为了避免开发者在创建某一个类的实例时，没有使用 \x3ccode\x3enew\x3c\/code\x3e 语句而导致的错误。而 ECMAScript 內部中的绝大部分类型构造函数（不包括 \x3ccode\x3eMap\x3c\/code\x3e 和 \x3ccode\x3eSet\x3c\/code\x3e 及他们的 \x3ccode\x3eWeak\x3c\/code\x3e 版本）都带有这种特性。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22String()  \/\/=\x3e \x26quot;\x26quot;\nNumber()  \/\/=\x3e 0\nBoolean() \/\/=\x3e false\nObject()  \/\/=\x3e Object {}\nArray()   \/\/=\x3e []\nDate()    \/\/=\x3e the current time\nRegExp()  \/\/=\x3e \/(?:)\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e()  \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; \x22\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e()  \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; 0\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eBoolean\x3c\/span\x3e() \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e()  \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; Object {}\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e()   \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; []\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e()    \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; the current time\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e()  \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; \/(?:)\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3eTIPS: 在代码风格检查工具 ESLint 中有一个可选特性名为 \x3ccode\x3eno-new\x3c\/code\x3e 即相比使用 \x3ccode\x3enew\x3c\/code\x3e，更倾向于使用直接调用构造函数来创建实例。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e那么同样的，生成器函数也支持这种特性，而在互联网上的大多数文献都使用了直接执行的方法创建生成器实例。如果我们尝试嗅探生成器函数和生成器实例的原型，我们可以到这样的信息。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* genFn() {}\nconst gen = genFn()\n\nconsole.log(genFn.constructor.prototype) \/\/=\x3e GeneratorFunction\nconsole.log(gen.constructor.prototype)   \/\/=\x3e Generator\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egenFn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e gen = genFn()\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(genFn.constructor.prototype) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; GeneratorFunction\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(gen.constructor.prototype)   \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; Generator\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样我们便可知，我们可以通过使用 \x3ccode\x3einstanceof\x3c\/code\x3e 语句来得知一个生成器实例是否为一个生成器函数所对应的实例。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(gen instanceof genFn) \/\/=\x3e true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(gen \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e genFn) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e十分可惜的是，目前原生支持生成器的主流 JavaScript 引擎（如 Google V8、Mozilla SpiderMonkey）并没有将 \x3ccode\x3eGeneratorFunction\x3c\/code\x3e 和 \x3ccode\x3eGenerator\x3c\/code\x3e 类暴露出来。这就意味着没办法简单地使用 \x3ccode\x3einstanceof\x3c\/code\x3e 来判定一个对象是否是生成器函数或生成器实例。但如果你确实希望对一个未知的对象检测它是否是一个生成器函数或者生成器实例，也可以通过一些取巧的办法来实现。\x3c\/p\x3e\n\x3cp\x3e对于原生支持生成器的运行环境来说，生成器函数自身带有一个 \x3ccode\x3econstructor\x3c\/code\x3e 属性指向并没有被暴露出来的 \x3ccode\x3eGeneratorFunction\x3c\/code\x3e。那么我们就可以利用一个我们已知的生成器函数的 \x3ccode\x3econstructor\x3c\/code\x3e 来检验一个函数是否是生成器函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isGeneratorFunction(fn) {\n  const genFn = (function*(){}).constructor\n\n  return fn instanceof genFn\n}\n\nfunction* genFn() {\n  let a = 2\n  \n  yield a\n  \n  while (true) {\n    yield a = a \/ (2 * a \x2b 1)\n  }\n}\n\nconsole.log(isGeneratorFunction(genFn)) \/\/=\x3e true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisGeneratorFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e genFn = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e*(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}).constructor\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fn \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e genFn\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egenFn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e a\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e a = a \/ (\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * a \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n  }\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isGeneratorFunction(genFn)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e显然出于性能考虑，我们可以将这个判定函数利用惰性加载进行优化。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isGeneratorFunction(fn) {\n  const genFn = (function*(){}).constructor\n\n  return (isGeneratorFunction = fn =\x3e fn instanceof genFn)(fn)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisGeneratorFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e genFn = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e*(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}).constructor\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (isGeneratorFunction = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e =\x26gt;\x3c\/span\x3e fn \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e genFn)(fn)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相对于生成器函数，生成器实例的检测就更为困难。因为无法通过对已知生成器实例自身的属性来获取被运行引擎所隐藏起来的 \x3ccode\x3eGenerator\x3c\/code\x3e 构造函数，所以无法直接用 \x3ccode\x3einstanceof\x3c\/code\x3e 语句来进行类型检测。也就是说我们需要利用别的方法来实现这个需求。\x3c\/p\x3e\n\x3cp\x3e在上一个章节中，我们介绍到了在 ECMAScript 中，每一个对象都会有一个 \x3ccode\x3etoString()\x3c\/code\x3e 方法的实现以及其中一部分有 \x3ccode\x3eSymbol.toStringTag\x3c\/code\x3e 作为属性键的属性，以用于输出一个为了填补引用对象无法被直接序列化的字符串。而这个字符串是可以间接地探测出这个对象的构造函数名称，即带有直接关系的类。\x3c\/p\x3e\n\x3cp\x3e那么对于生成器对象来说，与它拥有直接关系的类除了其对应的生成器函数以外，便是被隐藏起来的 \x3ccode\x3eGenerator\x3c\/code\x3e 类了。而生成器对象的 \x3ccode\x3e@@toStringTag\x3c\/code\x3e 属性正正也是 \x3ccode\x3eGenerator\x3c\/code\x3e，这样的话我们就有了实现的思路了。在著名的 JavaScript 工具类库 LoDash\x3csup\x3e6\x3c\/sup\x3e 的类型检测中，正式使用了（包括但不限于）这种方法来对未知对象进行类型检查，而我们也可以试着使用这种手段。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isGenerator(obj) {\n  return obj.toString ? obj.toString() === \x27[object Generator]\x27 : false\n}\n\nfunction* genFn() {}\nconst gen = genFn()\n\nconsole.log(isGenerator(gen)) \/\/=\x3e true\nconsole.log(isGenerator({}))  \/\/=\x3e false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisGenerator\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e obj.toString ? obj.toString() === \x3cspan class=\x22hljs-string\x22\x3e\x27[object Generator]\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egenFn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e gen = genFn()\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isGenerator(gen)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isGenerator({}))  \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而另外一方面，我们既然已经知道了生成器实例必定带有 \x3ccode\x3e@@toStringTag\x3c\/code\x3e 属性并其值夜必定为 \x3ccode\x3eGenerator\x3c\/code\x3e，我们也可以通过这个来检测位置对象是否为生成器实例。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isGenerator(obj) {\n  return obj[Symbol \x26amp;\x26amp; Symbol.toStringTag ? Symbol.toStringTag : false] === \x27Generator\x27\n}\n\nconsole.log(isGenerator(gen)) \/\/=\x3e true\nconsole.log(isGenerator({}))  \/\/=\x3e false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisGenerator\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e obj[\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toStringTag ? \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toStringTag : \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e] === \x3cspan class=\x22hljs-string\x22\x3e\x27Generator\x27\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isGenerator(gen)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isGenerator({}))  \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此处为了防止因为运行环境不支持 \x3ccode\x3eSymbol\x3c\/code\x3e 或 \x3ccode\x3e@@toStringTag\x3c\/code\x3e 而导致报错，需要使用先做兼容性检测以完成兼容降级。\x3c\/p\x3e\n\x3cp\x3e而我们再回过头来看看生成器函数，我们是否也可以使用 \x3ccode\x3e@@toStringTag\x3c\/code\x3e 属性来对生成器函数进行类型检测呢？我们在一个同时支持生成器和 \x3ccode\x3e@@toStringTag\x3c\/code\x3e 的运行环境中运行下面这段代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* genFn() {}\n\nconsole.log(genFn[Symbol.toStringTag]) \/\/=\x3e GeneratorFunction\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egenFn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(genFn[\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toStringTag]) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; GeneratorFunction\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这显然是可行的，那么我们就来为前面的 \x3ccode\x3eisGeneratorFunction\x3c\/code\x3e 方法再进行优化。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isGeneratorFunction(fn) {\n  return fn[Symbol \x26amp;\x26amp; Symbol.toStringTag ? Symbol.toStringTag : false] === \x27GeneratorFunction\x27\n}\n\nconsole.log(isGeneratorFunction(genFn)) \/\/=\x3e true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisGeneratorFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fn[\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toStringTag ? \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toStringTag : \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e] === \x3cspan class=\x22hljs-string\x22\x3e\x27GeneratorFunction\x27\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isGeneratorFunction(genFn)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而当运行环境不支持 \x3ccode\x3e@@toStringTag\x3c\/code\x3e 时也可以通过 \x3ccode\x3einstanceof\x3c\/code\x3e 语句来进行检测。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isGeneratorFunction(fn) {\n  \/\/ If the current engine supports Symbol and @@toStringTag\n  if (Symbol \x26amp;\x26amp; Symbol.toStringTag) {\n    return (isGeneratorFunction = fn =\x3e fn[Symbol.toStringTag] === \x27GeneratorFunction\x27)(fn)\n  }\n\n  \/\/ Using instanceof statement for detecting\n  const genFn = (function*(){}).constructor\n\n  return (isGeneratorFunction = fn =\x3e fn instanceof genFn)(fn)\n}\n\nconsole.log(isGeneratorFunction(genFn)) \/\/=\x3e true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisGeneratorFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If the current engine supports Symbol and @@toStringTag\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toStringTag) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (isGeneratorFunction = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e =\x26gt;\x3c\/span\x3e fn[\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toStringTag] === \x3cspan class=\x22hljs-string\x22\x3e\x27GeneratorFunction\x27\x3c\/span\x3e)(fn)\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Using instanceof statement for detecting\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e genFn = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e*(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}).constructor\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (isGeneratorFunction = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e =\x26gt;\x3c\/span\x3e fn \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e genFn)(fn)\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isGeneratorFunction(genFn)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e生成器嵌套\x3c\/h3\x3e\n\x3cp\x3e虽然说到现在为止，我们所举出的生成器例子都是单一生成器进行使用。但是在实际开发中，我们同样会遇到需要一个生成器嵌套在另一个生成器内的情况，就比如数学中的分段函数或嵌套的数组公式等。\x3c\/p\x3e\n\x3cp\x3e我们假设有这样的一个分段函数，我们需要对其进行积分计算。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000004993570\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000004993570\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000004993572\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000004993572\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e分别对分段函数的各分段作积分，以便编写程序进行积分。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000004993574\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000004993574\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e此处我们可以分别对分段函数的两个部分分别建立生成器函数并使用牛顿-科特斯公式（Newton-Cotes formulas）\x3csup\x3e7\x3c\/sup\x3e来进行积分计算。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Newton-Cotes formulas\nfunction* newton_cotes(f, a, b, n) {\n  const gaps = (b - a) \/ n\n  const h = gaps \/ 2\n\n  for (var i = 0; i \x3c n; i\x2b\x2b) {\n    yield h \/ 45 *\n      (7 * f(a \x2b i * gaps) \x2b\n      32 * f(a \x2b i * gaps \x2b 0.25 * gaps) \x2b\n      12 * f(a \x2b i * gaps \x2b 0.5 * gaps) \x2b\n      32 * f(a \x2b i * gaps \x2b 0.75 * gaps) \x2b\n      7 * f(a \x2b (i \x2b 1) * gaps))\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Newton-Cotes formulas\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3enewton_cotes\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ef, a, b, n\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e gaps = (b - a) \/ n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e h = gaps \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; n; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e h \/ \x3cspan class=\x22hljs-number\x22\x3e45\x3c\/span\x3e *\n      (\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e * f(a \x2b i * gaps) \x2b\n      \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e * f(a \x2b i * gaps \x2b \x3cspan class=\x22hljs-number\x22\x3e0.25\x3c\/span\x3e * gaps) \x2b\n      \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e * f(a \x2b i * gaps \x2b \x3cspan class=\x22hljs-number\x22\x3e0.5\x3c\/span\x3e * gaps) \x2b\n      \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e * f(a \x2b i * gaps \x2b \x3cspan class=\x22hljs-number\x22\x3e0.75\x3c\/span\x3e * gaps) \x2b\n      \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e * f(a \x2b (i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) * gaps))\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在编写两个分段部分的生成器之前，我们需要先引入一个新语法 \x3ccode\x3eyield*\x3c\/code\x3e。它与 \x3ccode\x3eyield\x3c\/code\x3e 的区别在于，\x3ccode\x3eyield*\x3c\/code\x3e 的功能是为了将一个生成器对象嵌套于另一个生成器内，并将其展开。我们以一个简单地例子说明。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* foo() {\n  yield 1\n  yield 2\n}\n\nfunction* bar() {\n  yield* foo()\n  yield 3\n  yield 4\n}\n\nfor (const n of bar()) console.log(n)\n\/\/=\x3e\n\/\/  1\n\/\/  2\n\/\/  3\n\/\/  4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e* foo()\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e n \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e bar()) \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(n)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  1\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  2\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  3\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  4\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e利用 \x3ccode\x3eyield*\x3c\/code\x3e 语句我们就可以将生成器进行嵌套和组合，使得不同的生成器所输出的值可以被同一个生成器连续输出。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* Part1(n) {\n  yield* newton_cotes(x =\x3e Math.pow(x, 2), -2, 0, n)\n}\n\nfunction* Part2(n) {\n  yield* newton_cotes(x =\x3e Math.sin(x), 0, 2, n)\n}\n\nfunction* sum() {\n  const n = 100\n\n  yield* Part1(n)\n  yield* Part2(n)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3ePart1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e* newton_cotes(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.pow(x, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e-2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, n)\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3ePart2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e* newton_cotes(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.sin(x), \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, n)\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3esum\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e n = \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e* Part1(n)\n  \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e* Part2(n)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最终我们将 \x3ccode\x3esum()\x3c\/code\x3e 生成器的所有输出值相加即可。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e生成器 ≈ 协程？\x3c\/h3\x3e\n\x3cp\x3e从运行机制的角度上看，生成器拥有暂停运行时的能力，那么生成器的运用是否只仅限于生成数据呢？在上文中，我们提到了生成器是一种类协程，而协程自身是可以通过生成器的特性来进行模拟呢。\x3c\/p\x3e\n\x3cp\x3e在现代 JavaScript 应用开发中，我们经常会使用到异步操作（如在 Node.js 开发中绝大部分使用到的 IO 操作都是异步的）。但是当异步操作的层级过深时，就可能会出现回调地狱（Callback Hell）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22io1((err, res1) =\x3e {\n  io2(res1, (err, res2) =\x3e {\n    io3(res2, (err, res3) =\x3e {\n      io4(res3, (err, res4) =\x3e {\n        io5(res5, (err, res5) =\x3e {\n          \/\/ ......\n        })\n      })\n    })\n  })\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eio1(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, res1\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  io2(res1, (err, res2) =\x26gt; {\n    io3(res2, (err, res3) =\x26gt; {\n      io4(res3, (err, res4) =\x26gt; {\n        io5(res5, (err, res5) =\x26gt; {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ......\x3c\/span\x3e\n        })\n      })\n    })\n  })\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e显然这样很不适合真正的复杂开发场景，而我们究竟要如何对着进行优化呢？我们知道 \x3ccode\x3eyield\x3c\/code\x3e 语句可以将一个值带出生成器执行环境，而这个值可以是任何类型的值，这就意味着我们可以利用这一特性做一些更有意思的事情了。\x3c\/p\x3e\n\x3cp\x3e我们回过头来看看生成器对象的操作方法，生成器执行对象的暂停状态可以用 \x3ccode\x3e.next(value)\x3c\/code\x3e 方法恢复，而这个方法是可以被异步执行的。这就说明如果我们将异步 IO 的操作通过 \x3ccode\x3eyield\x3c\/code\x3e 语句来从生成器执行对象带到主线程中，在主线程中完成后再通过 \x3ccode\x3e.next(value)\x3c\/code\x3e 方法将执行结果带回到生成器执行对象中，这一流程在生成器的代码中是可以以同步的写法完成的。\x3c\/p\x3e\n\x3cp\x3e具体思路成型后，我们先以一个简单的例子来实现。为了实现以生成器作为逻辑执行主体，把异步方法带到主线程去，就要先将异步函数做一层包装，使得其可以在带出生成器执行对象之后再执行。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Before\nfunction echo(content, callback) {\n  callback(null, content)\n}\n\n\/\/ After\nfunction echo(content) {\n  return callback =\x3e {\n    callback(null, content)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Before\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eecho\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3econtent, callback\x3c\/span\x3e) \x3c\/span\x3e{\n  callback(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, content)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ After\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eecho\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3econtent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    callback(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, content)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样我们就可以在生成器内使用这个异步方法了。但是还不足够，将方法带出生成器执行对象后，还需要在主线程将带出的函数执行才可实现应有的需求。上面我们通过封装所得到的异步方法在生成器内部执行后，可以通过 \x3ccode\x3eyield\x3c\/code\x3e 语句将内层的函数带到主线程中。这样我们就可以在主线程中执行这个函数并得到返回值，然后将其返回到生成器执行对象中。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function run(genFn) {\n  const gen = genFn()\n  \n  const next = value =\x3e {\n    const ret = gen.next(value)\n    if (ret.done) return\n    \n    ret.value((err, val) =\x3e {\n      if (err) return console.error(err)\n      \n      \/\/ Looop\n      next(val)\n    })\n  }\n  \n  \/\/ First call\n  next()\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3egenFn\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e gen = genFn()\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e next = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ret = gen.next(value)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ret.done) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    \n    ret.value(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, val\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(err)\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Looop\x3c\/span\x3e\n      next(val)\n    })\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ First call\x3c\/span\x3e\n  next()\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过这个运行工具，我们便可以将生成器函数作为逻辑的运行载体，从而将之前多层嵌套的异步操作全部扁平化。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22run(function*() {\n  const msg1 = yield echo(\x27Hello\x27)\n  const msg2 = yield echo(`${msg1} World`)\n\n  console.log(msg2) \/\/=\x3e Hello Wolrd\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3erun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e*(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e msg1 = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e echo(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello\x27\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e msg2 = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e echo(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${msg1}\x3c\/span\x3e World`\x3c\/span\x3e)\n\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(msg2) \x3cspan class=\x22hljs-comment\x22\x3e\/\/=\x26gt; Hello Wolrd\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过简单地封装，我们已经尝到了一些甜头，那么再进一步增强之后又会有什么有趣的东西呢？Node.js 社区中有一个第三方库名为 co，意为 coroutine，这个库的意义在于利用生成器来模拟协程。而我们这里介绍的就是其中的一部分，co 的功能则更为丰富，可以直接使用 Promise 封装工具，如果异步方法有自带 Promise 的接口，就无需再次封装。此外 co 还可以直接实现生成器的嵌套调用，也就是说可以通过 co 来实现逻辑代码的全部同步化开发。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import co from \x27co\x27\nimport { promisify } from \x27bluebird\x27\nimport fs from \x27fs\x27\nimport path from \x27path\x27\n  \nconst filepath = path.resolve(process.cwd(), \x27.\/data.txt\x27)\nconst defaultData = new Buffer(\x27Hello World\x27)\n\nco(function*() {\n  const exists = yield promisify(fs.exists(filepath))\n\n  if (exists) {\n    const data = yield promisify(fs.readFile(filepath))\n    \/\/ ...\n  } else {\n    yield promisify(fs.writeFile(filepath, defaultData))\n    \/\/ ...\n  }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e co \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27co\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { promisify } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27bluebird\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e fs \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e path \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27path\x27\x3c\/span\x3e\n  \n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e filepath = path.resolve(process.cwd(), \x3cspan class=\x22hljs-string\x22\x3e\x27.\/data.txt\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaultData = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Buffer(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello World\x27\x3c\/span\x3e)\n\nco(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e*(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e exists = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e promisify(fs.exists(filepath))\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (exists) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e promisify(fs.readFile(filepath))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e promisify(fs.writeFile(filepath, defaultData))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3eReference\x3c\/h2\x3e\n\x3cp\x3e[1] CLU Language \x3ca href=\x22http:\/\/www.pmg.lcs.mit.edu\/CLU.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.pmg.lcs.mit.edu\/CLU.html\x3c\/a\x3e\x3cbr\x3e[2] Icon Language \x3ca href=\x22http:\/\/www.cs.arizona.edu\/icon\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.cs.arizona.edu\/icon\x3c\/a\x3e\x3cbr\x3e[3] Python Language \x3ca href=\x22http:\/\/www.python.org\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.python.org\x3c\/a\x3e\x3cbr\x3e[4] C# Language \x3ca href=\x22http:\/\/msdn.microsoft.com\/pt-br\/vcsharp\/default.aspx\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/msdn.microsoft.com\/pt-br\/vcsharp\/default.aspx\x3c\/a\x3e\x3cbr\x3e[5] Ruby Language \x3ca href=\x22http:\/\/www.ruby-lang.org\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.ruby-lang.org\x3c\/a\x3e\x3cbr\x3e[6] LoDash \x3ca href=\x22https:\/\/lodash.com\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/lodash.com\x3c\/a\x3e\x3cbr\x3e[7] Newton-Cotes formulas \x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Newton%E2%80%93Cotes_formulas\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/en.wikipedia.org\/wiki\/Newton%E2%80%93Cotes_formulas\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>生成器（Generator）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000004993542">https://segmentfault.com/a/1190000004993542</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/3w4rq2vmuyy/" target="_blank">https://alili.tech/archive/3w4rq2vmuyy/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>