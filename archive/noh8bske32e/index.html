<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 继承方式详解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript 继承方式详解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/noh8bske32e/",
				"appid": "1613049289050283", 
				"title": "JavaScript 继承方式详解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-12T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/zafk2if4oy/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/r2lmphjeb1g/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fnoh8bske32e%2f&text=JavaScript%20%e7%bb%a7%e6%89%bf%e6%96%b9%e5%bc%8f%e8%af%a6%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fnoh8bske32e%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fnoh8bske32e%2f&text=JavaScript%20%e7%bb%a7%e6%89%bf%e6%96%b9%e5%bc%8f%e8%af%a6%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fnoh8bske32e%2f&title=JavaScript%20%e7%bb%a7%e6%89%bf%e6%96%b9%e5%bc%8f%e8%af%a6%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fnoh8bske32e%2f&is_video=false&description=JavaScript%20%e7%bb%a7%e6%89%bf%e6%96%b9%e5%bc%8f%e8%af%a6%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20%e7%bb%a7%e6%89%bf%e6%96%b9%e5%bc%8f%e8%af%a6%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fnoh8bske32e%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fnoh8bske32e%2f&title=JavaScript%20%e7%bb%a7%e6%89%bf%e6%96%b9%e5%bc%8f%e8%af%a6%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnoh8bske32e%2f&title=JavaScript%20%e7%bb%a7%e6%89%bf%e6%96%b9%e5%bc%8f%e8%af%a6%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnoh8bske32e%2f&title=JavaScript%20%e7%bb%a7%e6%89%bf%e6%96%b9%e5%bc%8f%e8%af%a6%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fnoh8bske32e%2f&title=JavaScript%20%e7%bb%a7%e6%89%bf%e6%96%b9%e5%bc%8f%e8%af%a6%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 继承方式详解</h1><div class="meta"><div class="postdate"><time datetime="2019-02-12" itemprop="datePublished">2019-02-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3eJavaScript 继承方式的概念\x3c\/h2\x3e\n\x3cp\x3ejs 中实现继承有两种常用方式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22原型链继承（对象间的继承）\n类式继承（构造函数间的继承）\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode\x3e原型链继承（对象间的继承）\n类式继承（构造函数间的继承）\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eJavaScript不是真正的面向对象的语言，想实现继承可以用JS的原型\x3ccode\x3eprototype\x3c\/code\x3e机制或者\x3ccode\x3ecall\x3c\/code\x3e和\x3ccode\x3eapply\x3c\/code\x3e方法\x3c\/p\x3e\n\x3cp\x3e在面向对象的语言中，可以使用类来创建一个自定义对象，当然\x3ccode\x3eES6\x3c\/code\x3e中也引入了\x3ccode\x3eclass\x3c\/code\x3e来创建类。在这之前，我们需要使用\x3ccode\x3ejs\x3c\/code\x3e的原型来创建自定义对象。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e原型继承与类继承\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3e类继承\x3c\/code\x3e是在子类型构造函数的内部调用父类型的构造函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Super (){\n    this.colors = [\x26quot;blue\x26quot;,\x26quot;red\x26quot;];\n}\n\nfunction Sub () {\n    Super.call(this);\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuper\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.colors = [\x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22red\x22\x3c\/span\x3e];\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSub\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    Super.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e原型式继承\x3c\/code\x3e是借助已有的对象创建新的对象，将子类的原型指向父类。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Super (id) {\n    this.id = id;\n}\nSuper.prototype.toString = function () {\n    return \x27Super\x27 \x2b this.id;\n}\n\nfunction Sub (id) {\n    this.id = id;\n}\n\nSub.prototype = new Super();  \/\/ 这句即原型式继承的核心代码\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSuper\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(id)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = id;\n}\nSuper.prototype.toString = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Super\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSub\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(id)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = id;\n}\n\nSub.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Super();  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这句即原型式继承的核心代码\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e原型链继承\x3c\/h2\x3e\n\x3cp\x3e为了让子类继承父类的属性和方法，首先需要定义一个构造函数，然后将父类的实例赋值给构造函数的原型。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Parent () {\n    this.name = \x27Parent\x27;\n}\n\nfunction Child () {\n    this.age = 10;\n}\nChid.prototype = new Parent();  \/\/ Chid继承Parent,形成原型链\n\nvar test = new Child();\nconsole.log(test.name) \/\/ Parent\nconsole.log(test.age)  \/\/ 10    得到被继承的属性\n\n\/\/ 继续原型链继承\nfunction Brother () {\n    this.weight = 60;\n}\nBrother.prototype = new Child();\nvar peter = new Brother();\nconsole.log(peter.name)  \/\/继承了Child和Parent,输出Parent\nconsole.log(peter.age)  \/\/ 输出10\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Parent\x27\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n}\nChid.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Parent();  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Chid继承Parent,形成原型链\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e test = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(test.name) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Parent\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(test.age)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 10    得到被继承的属性\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 继续原型链继承\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBrother\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.weight = \x3cspan class=\x22hljs-number\x22\x3e60\x3c\/span\x3e;\n}\nBrother.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e peter = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Brother();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(peter.name)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/继承了Child和Parent,输出Parent\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(peter.age)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出10\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所有的构造函数都继承自\x3ccode\x3eObject\x3c\/code\x3e,它是自动完成继承的并不需要我们手动继承，那么接着看它们的从属关系\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e确定原型和实例的关系\x3c\/h3\x3e\n\x3cp\x3e可以通过两种方式确定原型和实例的关系，通过操作符\x3ccode\x3einstanceof\x3c\/code\x3e和\x3ccode\x3eisPrototypeof()\x3c\/code\x3e方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(peter instanceof Object); \/\/true\nconsole.log(test instanceof Brother)  \/\/false,test是brother的父类\nconsole.log(peter instanceof Child) \/\/true\nconsole.log(peter instanceof Parent)  \/\/true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(peter \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(test \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Brother)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/false,test是brother的父类\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(peter \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Child) \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(peter \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Parent)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e只要是原型链中出现过的原型，都可以说是改原型链派生的实例的原型。因此，\x3ccode\x3eisProtptypeof()\x3c\/code\x3e方法也会返回\x3ccode\x3etrue\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e在JS中，被继承的函数成为父类（或者 基类、超类），继承的函数成为子类（派生类）。使用原型继承主要有两个问题，一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型无法给父类型传递参数。\x3c\/p\x3e\n\x3cp\x3e伪类解决引用共享和超类型无法传参的问题，我们可以采用\x27类式继承\x27的方式\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e类式继承(借用构造函数)\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Parent (age) {\n    this.colors = [\x26quot;blue\x26quot;,\x26quot;red\x26quot;,\x26quot;green\x26quot;];\n    this.age = age;\n}\n\nfunction Child (age) {\n    Parent.call(this,age);\n}\n\nvar peter = new Child(20);\nconsole.log(peter.age) \/\/20\nconsole.log(peter.colors) \/\/blue,red,green\n\npeter.colors.push(\x26quot;white\x26quot;);\nconsole.log(peter.colors) \/\/blue,red,green,white\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eage\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.colors = [\x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22red\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22green\x22\x3c\/span\x3e];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eage\x3c\/span\x3e) \x3c\/span\x3e{\n    Parent.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,age);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e peter = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child(\x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(peter.age) \x3cspan class=\x22hljs-comment\x22\x3e\/\/20\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(peter.colors) \x3cspan class=\x22hljs-comment\x22\x3e\/\/blue,red,green\x3c\/span\x3e\n\npeter.colors.push(\x3cspan class=\x22hljs-string\x22\x3e\x22white\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(peter.colors) \x3cspan class=\x22hljs-comment\x22\x3e\/\/blue,red,green,white\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e借用构造函数虽然解决了上面两张问题，但没有原型，所以我们需要\x3ccode\x3e原型链\x2b借用构造函数\x3c\/code\x3e的模式，这种模式成为\x3cstrong\x3e组合继承\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e组合继承\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Parent (age) {\n    this.colors = [\x26quot;blue\x26quot;,\x26quot;red\x26quot;,\x26quot;green\x26quot;];\n    this.age = age;\n}\n\nParent.prototype.run = function () {\n    return this.colors \x2b \x27 is \x27 \x2bthis.age;\n}\nfunction Child (age) {\n    Parent.call(this,age);  \/\/对象冒充，给父类型传参\n}\nChild.prototype = new Parent();  \/\/原型链继承\n\nvar peter = new Child(20);\nconsole.log(peter.run()); \/\/blue,red,green is 20\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eage\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.colors = [\x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22red\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22green\x22\x3c\/span\x3e];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n}\n\nParent.prototype.run = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.colors \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 is \x27\x3c\/span\x3e \x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age;\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eage\x3c\/span\x3e) \x3c\/span\x3e{\n    Parent.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,age);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/对象冒充，给父类型传参\x3c\/span\x3e\n}\nChild.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Parent();  \x3cspan class=\x22hljs-comment\x22\x3e\/\/原型链继承\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e peter = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child(\x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(peter.run()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/blue,red,green is 20\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e组合继承是一种比较常用的方法，思路是使用原型链实现对原型属性和方法的继承，借用构造函数来实现对实例属性的继承。这样，既实现了原型上定义方法的函数复用，又保证每个实例都有自己的属性。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ecall()与apply()\x3c\/code\x3e的用法：调用一个对象的一个方法，用另一个对象替换当前对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22call(thisObj,Object);  \/\/ call接收一个对象\napply(thisObj，[argArray])  \/\/apply接收一个数组\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sql\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ecall\x3c\/span\x3e(thisObj,\x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e);  \/\/ \x3cspan class=\x22hljs-keyword\x22\x3ecall\x3c\/span\x3e接收一个对象\n\x3cspan class=\x22hljs-keyword\x22\x3eapply\x3c\/span\x3e(thisObj，[argArray])  \/\/\x3cspan class=\x22hljs-keyword\x22\x3eapply\x3c\/span\x3e接收一个数组\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e原型式继承\x3c\/h2\x3e\n\x3cp\x3e这种继承借助原型并基于已有的对象创建新的对象，同时还不用创建自定义类型的方式成为\x3ccode\x3e原型式继承\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function obj(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nvar box = {\n        name : \x27peter\x27,\n        arr : [\x27blue\x27,\x27red\x27,\x27green\x27]\n    };\n\nvar b1 = obj(box);\nconsole.log(b1.name) \/\/ peter\n\nb1.name = \x27jack\x27;\nconsole.log(b1.name) \/\/jack\n\nconsole.log(b1.arr) \/\/blue,red,green\nb1.arr.push(\x27white\x27) \/\/blue,red,green,white\n\nvar b2 = obj(box);\nconsole.log(b2.name) \/\/ peter\nconsole.log(b1.arr) \/\/blue,red,green\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eobj\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eo\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eF\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n    F.prototype = o;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e F();\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e box = {\n        \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27peter\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3earr\x3c\/span\x3e : [\x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e]\n    };\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b1 = obj(box);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.name) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ peter\x3c\/span\x3e\n\nb1.name = \x3cspan class=\x22hljs-string\x22\x3e\x27jack\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.name) \x3cspan class=\x22hljs-comment\x22\x3e\/\/jack\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.arr) \x3cspan class=\x22hljs-comment\x22\x3e\/\/blue,red,green\x3c\/span\x3e\nb1.arr.push(\x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/blue,red,green,white\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b2 = obj(box);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.name) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ peter\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.arr) \x3cspan class=\x22hljs-comment\x22\x3e\/\/blue,red,green\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e原型式继承首先在\x3ccode\x3eobj()\x3c\/code\x3e函数内部创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的新实例。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e寄生式继承\x3c\/h3\x3e\n\x3cp\x3e这种继承方式是把\x3ccode\x3e原型式\x2b工厂模式\x3c\/code\x3e结合起来，目的是为了封装创建的过程。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function create(o){\n        var f = obj(o);\n        f.run = function () {\n            return this.arr;\/\/同样，会共享引用\n        };\n        return f;\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreate\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(o)\x3c\/span\x3e\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f = obj(o);\n        f.run = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.arr;\x3cspan class=\x22hljs-comment\x22\x3e\/\/同样，会共享引用\x3c\/span\x3e\n        };\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e f;\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e组合式继承的问题\x3c\/h3\x3e\n\x3cp\x3e组合式继承是\x3ccode\x3eJS\x3c\/code\x3e最常用的继承模式，但组合继承的父类型会在使用过程中被调用两次，一次是创建子类型的时候，另一次是在子类型构造函数的内部\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Parent(name){\n        this.name = name;\n        this.arr = [\x27哥哥\x27,\x27妹妹\x27,\x27父母\x27];\n    }\n\n    Parent.prototype.run = function () {\n        return this.name;\n    };\n\n    function Child(name,age){\n        Parent.call(this,age);\/\/第二次调用\n        this.age = age;\n    }\n\n    Child.prototype = new Parent();\/\/第一次调用\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name)\x3c\/span\x3e\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.arr = [\x3cspan class=\x22hljs-string\x22\x3e\x27哥哥\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27妹妹\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27父母\x27\x3c\/span\x3e];\n    }\n\n    Parent.prototype.run = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;\n    };\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name,age)\x3c\/span\x3e\x3c\/span\x3e{\n        Parent.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,age);\x3cspan class=\x22hljs-comment\x22\x3e\/\/第二次调用\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n    }\n\n    Child.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Parent();\x3cspan class=\x22hljs-comment\x22\x3e\/\/第一次调用\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码是组合继承，那么\x3ccode\x3e寄生组合继承\x3c\/code\x3e解决了两次调用的问题\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e寄生组合继承\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function obj() {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\nfunction create(parent,test) {\n    var f = obj(parent.prototype); \/\/创建对象\n    f.constructor = test; \/\/增强对象\n}\nfunction Parent(name){\n        this.name = name;\n        this.arr = [\x27brother\x27,\x27sister\x27,\x27parents\x27];\n    }\n\nParent.prototype.run = function () {\n        return this.name;\n    };\n\nfunction Child(name,age){\n        Parent.call(this,name);\n        this.age =age;\n    }\ninheritPrototype(Parent,Child);  \/\/通过这里实现继承\n\nvar test = new Child(\x27peter\x27,20);\ntest.arr.push(\x27new\x27);\nconsole.log(test.arr);  \/\/brother,sister,parents,new\nconsole.log(test.run());  \/\/只共享了方法\n\nvar test2 = new Child(\x27jack\x27,22);\nconsole.log(test2.arr);  \/\/引用问题解决\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eobj\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eF\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n    F.prototype = o;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e F();\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eparent,test\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e f = obj(\x3cspan class=\x22hljs-built_in\x22\x3eparent\x3c\/span\x3e.prototype); \x3cspan class=\x22hljs-comment\x22\x3e\/\/创建对象\x3c\/span\x3e\n    f.constructor = test; \x3cspan class=\x22hljs-comment\x22\x3e\/\/增强对象\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.arr = [\x3cspan class=\x22hljs-string\x22\x3e\x27brother\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27sister\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27parents\x27\x3c\/span\x3e];\n    }\n\nParent.prototype.run = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;\n    };\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,age\x3c\/span\x3e)\x3c\/span\x3e{\n        Parent.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,name);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age =age;\n    }\ninheritPrototype(Parent,Child);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/通过这里实现继承\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e test = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child(\x3cspan class=\x22hljs-string\x22\x3e\x27peter\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\ntest.arr.push(\x3cspan class=\x22hljs-string\x22\x3e\x27new\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(test.arr);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/brother,sister,parents,new\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(test.run());  \x3cspan class=\x22hljs-comment\x22\x3e\/\/只共享了方法\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e test2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child(\x3cspan class=\x22hljs-string\x22\x3e\x27jack\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(test2.arr);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/引用问题解决\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3ecall和apply\x3c\/h3\x3e\n\x3cp\x3ecall和apply可以用来改变函数中\x3ccode\x3ethis\x3c\/code\x3e的指向:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 定义一个全局函数\nfunction f () {\n    console.log(this.name);\n}\n\/\/ 定义一个全局变量\nvar name = \x27peter\x27;\nvar obj = {\n    name: \x27jack\x27;\n};\n\nf.apply(window); \/\/apple, 此时this 等于window  相当于window.f()\nf.apply(obj);  \/\/jack, 此时this === obj 相当于obj.f()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义一个全局函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义一个全局变量\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = \x3cspan class=\x22hljs-string\x22\x3e\x27peter\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27jack\x27\x3c\/span\x3e;\n};\n\nf.apply(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/apple, 此时this 等于window  相当于window.f()\x3c\/span\x3e\nf.apply(obj);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/jack, 此时this === obj 相当于obj.f()\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript 继承方式详解</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000004706922">https://segmentfault.com/a/1190000004706922</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/noh8bske32e/" target="_blank">https://alili.tech/archive/noh8bske32e/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>