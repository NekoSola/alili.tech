<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript异步编程的终极演变"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript异步编程的终极演变 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/qtgce9g2usj/",
				"appid": "1613049289050283", 
				"title": "JavaScript异步编程的终极演变 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/7tsrokjxjsh/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/eizezdfg2ep/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fqtgce9g2usj%2f&text=JavaScript%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e7%9a%84%e7%bb%88%e6%9e%81%e6%bc%94%e5%8f%98"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fqtgce9g2usj%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fqtgce9g2usj%2f&text=JavaScript%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e7%9a%84%e7%bb%88%e6%9e%81%e6%bc%94%e5%8f%98"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fqtgce9g2usj%2f&title=JavaScript%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e7%9a%84%e7%bb%88%e6%9e%81%e6%bc%94%e5%8f%98"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fqtgce9g2usj%2f&is_video=false&description=JavaScript%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e7%9a%84%e7%bb%88%e6%9e%81%e6%bc%94%e5%8f%98"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e7%9a%84%e7%bb%88%e6%9e%81%e6%bc%94%e5%8f%98&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fqtgce9g2usj%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fqtgce9g2usj%2f&title=JavaScript%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e7%9a%84%e7%bb%88%e6%9e%81%e6%bc%94%e5%8f%98"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqtgce9g2usj%2f&title=JavaScript%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e7%9a%84%e7%bb%88%e6%9e%81%e6%bc%94%e5%8f%98"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqtgce9g2usj%2f&title=JavaScript%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e7%9a%84%e7%bb%88%e6%9e%81%e6%bc%94%e5%8f%98"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqtgce9g2usj%2f&title=JavaScript%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e7%9a%84%e7%bb%88%e6%9e%81%e6%bc%94%e5%8f%98"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript异步编程的终极演变</h1><div class="meta"><div class="postdate"><time datetime="2019-02-05" itemprop="datePublished">2019-02-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e写在前面\x3c\/h1\x3e\n\x3cp\x3e有一个有趣的问题：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e为什么\x3ccode\x3eNode.js\x3c\/code\x3e约定回调函数的第一个参数必须是错误对象\x3ccode\x3eerr\x3c\/code\x3e(如果没有错误，该参数就是\x3ccode\x3enull\x3c\/code\x3e)?\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e原因是执行回调函数对应的异步操作，它的执行分成两段，这两段之间抛出的错误程序无法捕获，所以只能作为参数传入第二段。大家知道，\x3ccode\x3eJavaScript\x3c\/code\x3e只有一个线程，如果没有异步编辑，复杂的程序基本没法使用。在ES6诞生以前，异步编程的方式大概有下面四种：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e回调函数\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e事件监听\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e发布\/订阅\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ePromise\x3c\/code\x3e对象\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eES6将\x3ccode\x3eJavaScript\x3c\/code\x3e异步编程带入了一个全新的阶段，ES7中的\x3ccode\x3easync\x3c\/code\x3e函数更是给出了异步编程的终极解决方案。下面将具体讲解异步编程的原理和值得注意的地方，待我细细道来～\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e异步编程的演变\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e基本理解\x3c\/h2\x3e\n\x3cp\x3e所谓\x3ccode\x3e异步\x3c\/code\x3e，简单地说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好准备再回过头执行第二段。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e举个例子\x3c\/strong\x3e\x3cbr\x3e读取一个文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。\x3c\/p\x3e\n\x3cp\x3e相应地，连续的执行就叫作同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e回调函数\x3c\/h2\x3e\n\x3cp\x3e所谓回调函数，就是把任务的第二段单独写在一个函数中，等到重新执行该任务时直接调用这个函数。其英文名字 \x3ccode\x3ecallback\x3c\/code\x3e  直译过来就是  \x22重新调用\x22的意思。\x3c\/p\x3e\n\x3cp\x3e拿上面的例子讲，读取文件操作是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fs.readFile(fileA, (err, data) =\x3e {\n    if (err) throw err;\n    console.log(data)\n})\n\nfs.readFile(fileB, (err, data) =\x3e {\n    if (err) throw err;\n    console.log(data)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3efs.readFile(fileA, (err, data) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)\n})\n\nfs.readFile(fileB, (err, data) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e注意：上面两段代码彼此是异步的，虽然开始执行的顺序是从上到下，但是第二段并不会等到第一段结束才执行，而是并发执行。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e那么问题来了，如果想\x3ccode\x3efileB\x3c\/code\x3e等到\x3ccode\x3efileA\x3c\/code\x3e读取成功后再开始执行应该怎么处理呢？最简单的办法是通过 \x3cstrong\x3e回调嵌套\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fs.readFile(fileA, (err, data) =\x3e {\n    if (err) throw err;\n    console.log(data)\n    \n    fs.readFile(fileB, (_err, _data) =\x3e { \n        if (_err) throw err;\n        console.log(_data)\n    })\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3efs.readFile(fileA, (err, data) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)\n    \n    fs.readFile(fileB, (_err, _data) =\x26gt; { \n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_err) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err;\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(_data)\n    })\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方式我只能容忍个位数字的嵌套，而且它使得代码横向发展，实在是丑的一笔，次数多了根本是没法看。试想万一要同步执行100个异步操作呢？疯掉算了吧！有没有更好的办法呢？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e使用\x3ccode\x3ePromise\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e要澄清一点，\x3ccode\x3ePromise\x3c\/code\x3e的概念并不是\x3ccode\x3eES6\x3c\/code\x3e新出的，而是\x3ccode\x3eES6\x3c\/code\x3e整合了一套新的写法。同样继续上面的例子，使用\x3ccode\x3ePromise\x3c\/code\x3e代码就变成这样了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var readFile = require(\x27fs-readfile-promise\x27);\n\nreadFile(fileA)\n.then((data)=\x3e{console.log(data)})\n.then(()=\x3e{return readFile(fileB)})\n.then((data)=\x3e{console.log(data)})\n\/\/ ... 读取n次\n.catch((err)=\x3e{console.log(err)})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e readFile = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs-readfile-promise\x27\x3c\/span\x3e);\n\nreadFile(fileA)\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)})\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e readFile(fileB)})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... 读取n次\x3c\/span\x3e\n.catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e注意：上面代码使用了\x3ccode\x3eNode\x3c\/code\x3e封装好的\x3ccode\x3ePromise\x3c\/code\x3e版本的\x3ccode\x3ereadFile\x3c\/code\x3e函数，它的原理其实就是返回一个\x3ccode\x3ePromise\x3c\/code\x3e对象，咱也简单地写一个：\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fs = require(\x27fs\x27);\n\nvar readFile = function(path) {\n    return new Promise((resolve, reject) =\x3e {\n        fs.readFile(path, (err, data) =\x3e {\n            if (err) reject(err)\n            resolve(data)\n        })\n    })\n}\n\nmodule.export = readFile\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e readFile = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epath\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        fs.readFile(path, (err, data) =\x26gt; {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) reject(err)\n            resolve(data)\n        })\n    })\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.export = readFile\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e但是，\x3ccode\x3ePromise\x3c\/code\x3e的写法只是回调函数的改进，使用\x3ccode\x3ethen()\x3c\/code\x3e之后，异步任务的两段执行看得更清楚，除此之外并无新意。撇开优点，\x3ccode\x3ePromise\x3c\/code\x3e的最大问题就是代码冗余，原来的任务被\x3ccode\x3ePromise\x3c\/code\x3e包装一下，不管什么操作，一眼看上去都是一堆\x3ccode\x3ethen()\x3c\/code\x3e，原本的语意变得很不清楚。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e把酒问苍天，MD还有更好的办法吗？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e使用\x3ccode\x3eGenerator\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e在引入\x3ccode\x3egenerator\x3c\/code\x3e之前，先介绍一下什么叫 \x3cstrong\x3e协程\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x22携程在手，说走就走\x22。哈哈，别混淆了， \x22\x3cstrong\x3e协程\x3c\/strong\x3e\x22 非 \x22\x3cstrong\x3e携程\x3c\/strong\x3e\x22\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e协程\x3c\/h3\x3e\n\x3cp\x3e所谓 \x22协程\x22 ，就是多个线程相互协作，完成异步任务。协程有点像函数，又有点像线程。其运行流程大致如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e第一步： 协程A开始执行\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第二步：协程A执行到一半，暂停，执行权转移到协程B\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第三步：一段时间后，协程B交还执行权\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第四步：协程A恢复执行\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function asyncJob() {\n    \/\/ ... 其他代码\n    var f = yield readFile(fileA);\n    \/\/ ... 其他代码 \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3easyncJob\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... 其他代码\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e readFile(fileA);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... 其他代码 \x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e上面的\x3ccode\x3easyncJob()\x3c\/code\x3e就是一个协程，它的奥妙就在于其中的\x3ccode\x3eyield\x3c\/code\x3e命令。它表示执行到此处执行权交给其他协程，换而言之，\x3ccode\x3eyield\x3c\/code\x3e就是异步两个阶段的分界线。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e协程遇到\x3ccode\x3eyield\x3c\/code\x3e命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点就是代码的写法非常像同步操作，如果除去 \x3ccode\x3eyield\x3c\/code\x3e命令，简直一模一样。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e\n\x3ccode\x3eGenerator\x3c\/code\x3e函数\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eGenerator\x3c\/code\x3e函数是协程在ES6中的实现，最大的特点就是可以交出函数的执行权（即暂停执行）。整个\x3ccode\x3eGenerator\x3c\/code\x3e函数就是一个封装的异步任务，或者说就是异步任务的容器。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* gen(x) {\n    var y = yield x \x2b 2;\n    return y;\n} \n\nvar g = gen(1);\ng.next() \/\/ { value: 3, done: false }\ng.next() \/\/ { value: undefined, done: true }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egen\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e y = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e x \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e y;\n} \n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e g = gen(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\ng.next() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ { value: 3, done: false }\x3c\/span\x3e\ng.next() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ { value: undefined, done: true }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码中，调用\x3ccode\x3eGenerator\x3c\/code\x3e函数，会返回一个内部指针（即遍历器）g，这是\x3ccode\x3eGenerator\x3c\/code\x3e函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的\x3ccode\x3enext()\x3c\/code\x3e方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的\x3ccode\x3eyield\x3c\/code\x3e语句。\x3c\/p\x3e\n\x3cp\x3e换而言之，\x3ccode\x3enext()\x3c\/code\x3e方法的作用是分阶段执行\x3ccode\x3eGenerator\x3c\/code\x3e函数。每次调用\x3ccode\x3enext()\x3c\/code\x3e方法，会返回一个对象，表示当前阶段的信息（\x3ccode\x3evalue\x3c\/code\x3e属性和\x3ccode\x3edone\x3c\/code\x3e属性）。\x3ccode\x3evalue\x3c\/code\x3e属性是\x3ccode\x3eyield\x3c\/code\x3e语句后面表达式的值，表示当前阶段的值；\x3ccode\x3edone\x3c\/code\x3e属性是一个布尔值，表示\x3ccode\x3eGenerator\x3c\/code\x3e函数是否执行完毕，即是否还有一个阶段。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e\n\x3ccode\x3eGenerator\x3c\/code\x3e函数的数据交换和错误处理\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eGenerator\x3c\/code\x3e函数可以暂停执行和恢复执行，这是它封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的解决方案：函数体内外的数据交换和错误处理机制。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3enext()\x3c\/code\x3e方法返回值的\x3ccode\x3evalue\x3c\/code\x3e属性，是\x3ccode\x3eGenerator\x3c\/code\x3e函数向外输出的数据；\x3ccode\x3enext()\x3c\/code\x3e方法还可以接受参数，向\x3ccode\x3eGenerator\x3c\/code\x3e函数体内输入数据。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* gen(x) {\n    var y = yield x \x2b 2;\n    return y;\n} \n\nvar g = gen(1);\ng.next()      \/\/ { value: 3, done: false }\ng.next(2)     \/\/ { value: 2, done: true }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egen\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e y = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e x \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e y;\n} \n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e g = gen(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\ng.next()      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ { value: 3, done: false }\x3c\/span\x3e\ng.next(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ { value: 2, done: true }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e上面的代码中，第一个\x3ccode\x3enext()\x3c\/code\x3e方法的\x3ccode\x3evalue\x3c\/code\x3e属性，返回表达式\x3ccode\x3ex\x2b2\x3c\/code\x3e的值（3）。第二个\x3ccode\x3enext()\x3c\/code\x3e方法带有参数2，这个参数可以传入\x3ccode\x3eGenerator\x3c\/code\x3e函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收，因此这一步的\x3ccode\x3evalue\x3c\/code\x3e属性返回的就是2（变量y的值）。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3ccode\x3eGenerator\x3c\/code\x3e函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function* gen(x) {\n    try {\n        var y = yield x \x2b 2\n    } catch(e) {\n        console.log(e)\n    }\n    return y\n}\n\nvar g = gen(1);\ng.next();\ng.throw(\x27出错了\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egen\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e y = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e x \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e)\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e y\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e g = gen(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\ng.next();\ng.throw(\x3cspan class=\x22hljs-string\x22\x3e\x27出错了\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码的最后一行，\x3ccode\x3eGenerator\x3c\/code\x3e函数体外，使用指针对象的\x3ccode\x3ethrow\x3c\/code\x3e方法抛出的错误，可以被函数体内的\x3ccode\x3etry...catch\x3c\/code\x3e 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e异步任务的封装\x3c\/h3\x3e\n\x3cp\x3e下面看看如何使用\x3ccode\x3eGenerator\x3c\/code\x3e函数，执行一个真实的异步任务。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fetch = require(\x27node-fetch\x27)\n\nfunction* gen() {\n    var url = \x27https:\/\/api.github.com\/usrs\/github\x27;\n    var result = yield fetch(url);\n    console.log(result.bio);\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e fetch = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27node-fetch\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egen\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/api.github.com\/usrs\/github\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e fetch(\x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result.bio);\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e上面代码中，\x3ccode\x3eGenerator\x3c\/code\x3e函数封装了一个异步操作，该操作先读取一个远程接口，然后从\x3ccode\x3eJSON\x3c\/code\x3e格式的数据解析信息。就像前面说过的，这段代码非常像同步操作。除了加上\x3ccode\x3eyield\x3c\/code\x3e命令。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e执行这段代码的方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var g = gen();\nvar result = g.next();\n\nresult.value.then(function(data) {\n    return data.json()\n}).then(function(data) {\n    g.next(data)\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode\x3evar g = gen();\nvar result = g.next();\n\nresult.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.json()\n}).\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e\x3c\/span\x3e {\n    g.next(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e)\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中，首先执行\x3ccode\x3eGenerator\x3c\/code\x3e函数，获取遍历器对象。然后使用\x3ccode\x3enext()\x3c\/code\x3e方法，执行异步任务的第一阶段。由于\x3ccode\x3eFetch\x3c\/code\x3e模块返回的是一个\x3ccode\x3ePromise\x3c\/code\x3e对象，因此需要用\x3ccode\x3ethen()\x3c\/code\x3e方法调用下一个\x3ccode\x3enext()\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3cp\x3e可以看到，虽然\x3ccode\x3eGenerator\x3c\/code\x3e函数将异步操作表示得很简洁，但是流程管理却不方便（即合适执行第一阶段，何时执行第二阶段）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e大Boss登场之 \x3ccode\x3easync\x3c\/code\x3e函数\x3c\/h2\x3e\n\x3cp\x3e所谓\x3ccode\x3easync\x3c\/code\x3e函数，其实是\x3ccode\x3eGenerator\x3c\/code\x3e函数的语法糖。\x3c\/p\x3e\n\x3cp\x3e继续我们异步读取文件的例子，使用\x3ccode\x3eGenerator\x3c\/code\x3e实现\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fs = require(\x27fs\x27);\n\nvar readFile = (path) =\x3e {\n    return new Promise((resolve, reject) =\x3e {\n        fs.readFile(path, (err, data) =\x3e {\n            if (err) reject(err)\n            resolve(data)\n        })\n    })\n}\n\nvar gen = function* () {\n    var f1 = yield readFile(fileA);\n    var f2 = yield readFile(fileB);\n    console.log(f1.toString());\n    console.log(f2.toString());\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e readFile = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3epath\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        fs.readFile(path, (err, data) =\x26gt; {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) reject(err)\n            resolve(data)\n        })\n    })\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e gen = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f1 = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e readFile(fileA);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f2 = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e readFile(fileB);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(f1.toString());\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(f2.toString());\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e写成\x3ccode\x3easync\x3c\/code\x3e函数，就是下面这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var asyncReadFile = async function() {\n    var f1 = await readFile(fileA);\n    var f2 = await readFile(fileB);\n    console.log(f1.toString())\n    console.log(f2.toString())\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e asyncReadFile = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f1 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e readFile(fileA);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f2 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e readFile(fileB);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(f1.toString())\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(f2.toString())\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e发现了吧，\x3ccode\x3easync\x3c\/code\x3e函数就是将\x3ccode\x3eGenerator\x3c\/code\x3e函数的\x3ccode\x3e*\x3c\/code\x3e替换成了\x3ccode\x3easync\x3c\/code\x3e，将\x3ccode\x3eyield\x3c\/code\x3e替换成\x3ccode\x3eawait\x3c\/code\x3e，除此之外，还对 \x3ccode\x3eGenerator\x3c\/code\x3e做了以下四点改进：\x3c\/p\x3e\n\x3cp\x3e（1）内置执行器。\x3ccode\x3eGenerator\x3c\/code\x3e函数的执行比如靠执行器，所以才有了\x3ccode\x3eco\x3c\/code\x3e模块等异步执行器，而\x3ccode\x3easync\x3c\/code\x3e函数是自带执行器的。也就是说：\x3cstrong\x3e\x3ccode\x3easync\x3c\/code\x3e函数的执行，与普通函数一模一样，只要一行：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var result = asyncReadFile();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = asyncReadFile();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e（2）上面的代码调用了\x3ccode\x3easyncReadFile()\x3c\/code\x3e，就会自动执行，输出最后结果。这完全不像\x3ccode\x3eGenerator\x3c\/code\x3e函数，需要调用\x3ccode\x3enext()\x3c\/code\x3e方法，或者使用\x3ccode\x3eco\x3c\/code\x3e模块，才能得到真正执行，从而得到最终结果。\x3c\/p\x3e\n\x3cp\x3e（3）更好的语义。\x3ccode\x3easync\x3c\/code\x3e和\x3ccode\x3eawait\x3c\/code\x3e比起星号和\x3ccode\x3eyield\x3c\/code\x3e，语义更清楚。\x3ccode\x3easync\x3c\/code\x3e表示函数里有异步操作，\x3ccode\x3eawait\x3c\/code\x3e表示紧跟在后面的表达式需要等待结果。\x3c\/p\x3e\n\x3cp\x3e（4）更广的适用性。\x3ccode\x3easync\x3c\/code\x3e函数的\x3ccode\x3eawait\x3c\/code\x3e命令后面可以是\x3ccode\x3ePromise\x3c\/code\x3e对象和原始类型的值（数值、字符串和布尔值，而这是等同于同步操作）。\x3c\/p\x3e\n\x3cp\x3e（5）返回值是\x3ccode\x3ePromise\x3c\/code\x3e，这比\x3ccode\x3eGenerator\x3c\/code\x3e函数返回的是\x3ccode\x3eIterator\x3c\/code\x3e对象方便多了。你可以用\x3ccode\x3ethen()\x3c\/code\x3e指定下一步操作。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e进一步说，\x3ccode\x3easync\x3c\/code\x3e函数完全可以看作由多个异步操作包装成的一个\x3ccode\x3ePromise\x3c\/code\x3e对象，而\x3ccode\x3eawait\x3c\/code\x3e命令就是内部\x3ccode\x3ethen()\x3c\/code\x3e命令的语法糖。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e实现原理\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3easync\x3c\/code\x3e函数的实现就是将\x3ccode\x3eGenerator\x3c\/code\x3e函数和自动执行器包装在一个函数中。如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function fn(args) {\n    \/\/ ...\n}\n\n\/\/ 等同于 \nfunction fn(args) {\n  return spawn(function*() {\n    \/\/ ...\n  })\n}\n\/\/ 自动执行器\nfunction spawn(genF) {\n  return new Promise(function(resolve, reject) {\n    var gen = genF();\n    function step(nextF) {\n      try {\n        var next = nextF()\n      } catch(e) {\n        return reject(e)\n      }\n      if (next.done) {\n        return resolve(next.value)\n      }\n      Promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v) })\n      },function(e) {\n        step(function() { return gen.throw(e) })\n      })\n    }\n    step(function() { return gen.next(undefined) })\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eargs\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等同于 \x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eargs\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e spawn(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e*(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  })\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自动执行器\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3espawn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3egenF\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e gen = genF();\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estep\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextF\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e next = nextF()\n      } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e reject(e)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (next.done) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e resolve(next.value)\n      }\n      \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(next.value).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ev\x3c\/span\x3e) \x3c\/span\x3e{\n        step(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e gen.next(v) })\n      },\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n        step(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e gen.throw(e) })\n      })\n    }\n    step(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e gen.next(\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) })\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e\n\x3ccode\x3easync\x3c\/code\x3e函数用法\x3c\/h3\x3e\n\x3cp\x3e（1）\x3ccode\x3easync\x3c\/code\x3e函数返回一个\x3ccode\x3ePromise\x3c\/code\x3e对象，可以是\x3ccode\x3ethen()\x3c\/code\x3e方法添加回调函数。\x3cbr\x3e（2）当函数执行时，一旦遇到\x3ccode\x3eawait()\x3c\/code\x3e就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。\x3c\/p\x3e\n\x3cp\x3e下面是一个延迟输出结果的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function timeout(ms) {\n  return new Promise((resolve) =\x3e {\n    setTimeout(resolve, ms)\n  })\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms)\n  console.log(value)\n}\n\n\/\/ 延迟500ms后输出 \x26quot;Hello World!\x26quot;\nasyncPrint(\x27Hello World!\x27, 500)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ems\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    setTimeout(resolve, ms)\n  })\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3easyncPrint\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue, ms\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e timeout(ms)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 延迟500ms后输出 \x22Hello World!\x22\x3c\/span\x3e\nasyncPrint(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello World!\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e注意事项\x3c\/h3\x3e\n\x3cp\x3e（1）\x3ccode\x3eawait\x3c\/code\x3e命令后面的\x3ccode\x3ePromise\x3c\/code\x3e对象，运行结果可能是\x3ccode\x3ereject\x3c\/code\x3e，所以最好把\x3ccode\x3eawait\x3c\/code\x3e命令放在\x3ccode\x3etry...catch\x3c\/code\x3e代码块中。\x3c\/p\x3e\n\x3cp\x3e（2）\x3ccode\x3eawait\x3c\/code\x3e命令只能用在\x3ccode\x3easync\x3c\/code\x3e函数中，用在普通函数中会报错。\x3c\/p\x3e\n\x3cp\x3e（3）\x3ccode\x3eES6\x3c\/code\x3e将\x3ccode\x3eawait\x3c\/code\x3e增加为保留字。如果使用这个词作为标识符，在\x3ccode\x3eES5\x3c\/code\x3e中是合法的，但是\x3ccode\x3eES6\x3c\/code\x3e会抛出 \x3ccode\x3eSyntaxError\x3c\/code\x3e（语法错误）。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader14\x22\x3e终极一战\x3c\/h1\x3e\n\x3cp\x3e\x22倚天不出谁与争锋\x22，上面介绍了一大堆，最后还是让我们通过一个例子来看看 \x3ccode\x3easync\x3c\/code\x3e 函数和\x3ccode\x3ePromise\x3c\/code\x3e、\x3ccode\x3eGenerator\x3c\/code\x3e到底谁才是真正的老大吧！\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e需求：假定某个DOM元素上部署了一系列的动画，前一个动画结束才能开始后一个。如果当中又一个动画出错就不再往下执行，返回上一个成功执行动画的返回值。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e用\x3ccode\x3ePromise\x3c\/code\x3e实现\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function chainAnimationsPromise(ele, animations) {\n\n  \/\/ 变量ret用来保存上一个动画的返回值 \n  var ret = null;\n  \n  \/\/ 新建一个空的Promise \n  var p = Promise.resolve();\n\n  \/\/ 使用then方法添加所有动画 \n  for (var anim in animations) {\n    p = p.then(function(val) {\n      ret = val;\n      return anim(ele);\n    })\n  }\n  \n  \/\/ 返回一个部署了错误捕获机制的Promise \n  return p.catch(function(e) {\n    \/* 忽略错误，继续执行 *\/\n  }).then(function() {\n    return ret;\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echainAnimationsPromise\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eele, animations\x3c\/span\x3e) \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 变量ret用来保存上一个动画的返回值 \x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新建一个空的Promise \x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p = \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve();\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用then方法添加所有动画 \x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e anim \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e animations) {\n    p = p.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eval\x3c\/span\x3e) \x3c\/span\x3e{\n      ret = val;\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e anim(ele);\n    })\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回一个部署了错误捕获机制的Promise \x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e p.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* 忽略错误，继续执行 *\/\x3c\/span\x3e\n  }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然\x3ccode\x3ePromise\x3c\/code\x3e的写法比起回调函数的写法有很大的改进，但是操作本身的语义却变得不太明朗。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e用\x3ccode\x3eGenerator\x3c\/code\x3e实现\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function chainAnimationsGenerator(ele, animations) {\n  return spawn(function*() {\n    var ret = null;\n    try {\n      for(var anim of animations) {\n        ret = yield anim(ele)\n      }\n    } catch(e) {\n      \/* 忽略错误，继续执行 *\/\n    }\n    return ret;\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echainAnimationsGenerator\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eele, animations\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e spawn(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e*(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e anim \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e animations) {\n        ret = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e anim(ele)\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/* 忽略错误，继续执行 *\/\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3ccode\x3eGenerator\x3c\/code\x3e虽然语义比\x3ccode\x3ePromise\x3c\/code\x3e写法清晰不少，但是用户定义的操作全部出现在\x3ccode\x3espawn\x3c\/code\x3e函数的内部。这个写法的问题在于，必须有一个任务运行器自动执行\x3ccode\x3eGenerator\x3c\/code\x3e函数，它返回一个\x3ccode\x3ePromise\x3c\/code\x3e对象，而且保证\x3ccode\x3eyield\x3c\/code\x3e语句后的表达式返回的是一个\x3ccode\x3ePromise\x3c\/code\x3e。上面的\x3ccode\x3espawn\x3c\/code\x3e就扮演了这一角色。它的实现如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function spawn(genF) {\n  return new Promise(function(resolve, reject) {\n    var gen = genF();\n    function step(nextF) {\n      try {\n        var next = nextF()\n      } catch(e) {\n        return reject(e)\n      }\n      if (next.done) {\n        return resolve(next.value)\n      }\n      Promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v) })\n      },function(e) {\n        step(function() { return gen.throw(e) })\n      })\n    }\n    step(function() { return gen.next(undefined) })\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3espawn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3egenF\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e gen = genF();\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estep\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextF\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e next = nextF()\n      } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e reject(e)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (next.done) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e resolve(next.value)\n      }\n      \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(next.value).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ev\x3c\/span\x3e) \x3c\/span\x3e{\n        step(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e gen.next(v) })\n      },\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n        step(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e gen.throw(e) })\n      })\n    }\n    step(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e gen.next(\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) })\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3e使用\x3ccode\x3easync\x3c\/code\x3e实现\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function chainAnimationAsync(ele, animations) {\n  var ret = null;\n  try {\n    for(var anim of animations) {\n      ret = await anim(ele)\n    } \n  } catch(e) {\n    \/* 忽略错误，继续执行 *\/\n  }\n  return ret;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echainAnimationAsync\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eele, animations\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e anim \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e animations) {\n      ret = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e anim(ele)\n    } \n  } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* 忽略错误，继续执行 *\/\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e好了，光从代码量上就看出优势了吧！简洁又符合语义，几乎没有不相关代码。完胜！\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注意一点：\x3ccode\x3easync\x3c\/code\x3e属于ES7的提案，使用时请通过\x3ccode\x3ebabel\x3c\/code\x3e或者\x3ccode\x3eregenerator\x3c\/code\x3e进行转码。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader18\x22\x3e参考\x3c\/h1\x3e\n\x3cp\x3e阮一峰 《ES6标准入门》\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e@欢迎关注我的 \x3ca href=\x22https:\/\/github.com\/jafeney\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub\x3c\/a\x3e 和 \x3ca href=\x22http:\/\/jafeney.com\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e个人博客 －Jafeney\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript异步编程的终极演变</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006510526">https://segmentfault.com/a/1190000006510526</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/qtgce9g2usj/" target="_blank">https://alili.tech/archive/qtgce9g2usj/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>