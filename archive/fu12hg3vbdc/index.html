<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="流程控制： jQ Deferred 与 ES6 Promise 使用新手向入坑！"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>流程控制： jQ Deferred 与 ES6 Promise 使用新手向入坑！ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/fu12hg3vbdc/",
				"appid": "1613049289050283", 
				"title": "流程控制： jQ Deferred 与 ES6 Promise 使用新手向入坑！ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-10T02:30:42"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/z3ybp9uxlrh/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/e3baimteolq/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ffu12hg3vbdc%2f&text=%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%ef%bc%9a%20jQ%20Deferred%20%e4%b8%8e%20ES6%20Promise%20%e4%bd%bf%e7%94%a8%e6%96%b0%e6%89%8b%e5%90%91%e5%85%a5%e5%9d%91%ef%bc%81"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ffu12hg3vbdc%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ffu12hg3vbdc%2f&text=%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%ef%bc%9a%20jQ%20Deferred%20%e4%b8%8e%20ES6%20Promise%20%e4%bd%bf%e7%94%a8%e6%96%b0%e6%89%8b%e5%90%91%e5%85%a5%e5%9d%91%ef%bc%81"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ffu12hg3vbdc%2f&title=%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%ef%bc%9a%20jQ%20Deferred%20%e4%b8%8e%20ES6%20Promise%20%e4%bd%bf%e7%94%a8%e6%96%b0%e6%89%8b%e5%90%91%e5%85%a5%e5%9d%91%ef%bc%81"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ffu12hg3vbdc%2f&is_video=false&description=%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%ef%bc%9a%20jQ%20Deferred%20%e4%b8%8e%20ES6%20Promise%20%e4%bd%bf%e7%94%a8%e6%96%b0%e6%89%8b%e5%90%91%e5%85%a5%e5%9d%91%ef%bc%81"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%ef%bc%9a%20jQ%20Deferred%20%e4%b8%8e%20ES6%20Promise%20%e4%bd%bf%e7%94%a8%e6%96%b0%e6%89%8b%e5%90%91%e5%85%a5%e5%9d%91%ef%bc%81&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ffu12hg3vbdc%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ffu12hg3vbdc%2f&title=%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%ef%bc%9a%20jQ%20Deferred%20%e4%b8%8e%20ES6%20Promise%20%e4%bd%bf%e7%94%a8%e6%96%b0%e6%89%8b%e5%90%91%e5%85%a5%e5%9d%91%ef%bc%81"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffu12hg3vbdc%2f&title=%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%ef%bc%9a%20jQ%20Deferred%20%e4%b8%8e%20ES6%20Promise%20%e4%bd%bf%e7%94%a8%e6%96%b0%e6%89%8b%e5%90%91%e5%85%a5%e5%9d%91%ef%bc%81"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffu12hg3vbdc%2f&title=%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%ef%bc%9a%20jQ%20Deferred%20%e4%b8%8e%20ES6%20Promise%20%e4%bd%bf%e7%94%a8%e6%96%b0%e6%89%8b%e5%90%91%e5%85%a5%e5%9d%91%ef%bc%81"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffu12hg3vbdc%2f&title=%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%ef%bc%9a%20jQ%20Deferred%20%e4%b8%8e%20ES6%20Promise%20%e4%bd%bf%e7%94%a8%e6%96%b0%e6%89%8b%e5%90%91%e5%85%a5%e5%9d%91%ef%bc%81"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">流程控制： jQ Deferred 与 ES6 Promise 使用新手向入坑！</h1><div class="meta"><div class="postdate"><time datetime="2019-02-10" itemprop="datePublished">2019-02-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006771934\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006771934\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e谢谢\x3ccode\x3en͛i͛g͛h͛t͛i͛r͛e͛\x3c\/code\x3e大大指出的关于\x3ccode\x3ePromise\x3c\/code\x3e中\x3ccode\x3ecatch\x3c\/code\x3e用的不到位的错误\x3c\/strong\x3e，贴上大大推荐的文章\x3ca href=\x22https:\/\/pouchdb.com\/2015\/05\/18\/we-have-a-problem-with-promises.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise中的菜鸟和高阶错误\x3c\/a\x3e，文章很详细说明了一些\x3cstrong\x3e\x3ccode\x3ePromise\x3c\/code\x3e使用中的错误和指导\x3c\/strong\x3e。另外更正内容在后面补充。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e从 jQuery $.Deferred() 开始\x3c\/h2\x3e\n\x3cp\x3e说到异步流程控制，之前用的比较多的是jQ的Deferred。那Deferred是个啥呢，不清楚没关系，直接控制台来打印看下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005072398\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005072398\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e喔！看得出$.Deferred()后是个对象，其\x3cem\x3e下面\x3c\/em\x3e有着熟悉的\x3ccode\x3edone\x3c\/code\x3e, \x3ccode\x3efail\x3c\/code\x3e, \x3ccode\x3ealways\x3c\/code\x3e字眼（对，，是不是有点熟悉了呢？没错！如果经常用ajax的话就会经常接触到这些货色）。 当然了，不止这些，还有最最最重要的\x3ccode\x3ereject\x3c\/code\x3e和\x3ccode\x3eresolve\x3c\/code\x3e方法，说到这两个方法，就得引出下Deferred的状态机制了——其实很简单，实例化后用上图中的\x3ccode\x3estate\x3c\/code\x3e方法就可以查看(\x3ccode\x3e$.Deferred().state()\x3c\/code\x3e),有三种状态\x3c\/p\x3e\n\x3cblockquote\x3e\x3cul\x3e\n\x3cli\x3e\x3cp\x3e执行resolve\/reject前，返回值是pending\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行了resolve，返回值是resolved\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行了reject，返回值是rejected\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\x3c\/blockquote\x3e\n\x3cp\x3e直接来试着用下吧！这里我们假设执行一个随机延时的\x3ccode\x3esetTimeout\x3c\/code\x3e的异步操作，\x3cstrong\x3e在\x3ccode\x3esetTimeout\x3c\/code\x3e异步操作结束后\x3c\/strong\x3e，根据延时大小，做出不同回应 ! 代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function log (msg) {\n    console.log(msg);\n}\n\/\/ 包装一个异步操作\nvar Async = function () {\n    \/\/ 生成一个0到5秒的延迟\n    var delay = Math.floor(Math.random() * 5);\n    \/\/ 创建一个Deffered对象\n    var dfd = $.Deferred();\n    \/\/ 这里调用一个异步操作\n    setTimeout(function(){\n        if (delay \x3c= 2) {\n            \/\/ 置dfd状态为resolved\n            dfd.resolve(\x27一切正常!\x27);\n        } else {\n            \/\/ 置dfd状态为rejected\n            dfd.reject(\x27超时了!\x27);\n        }            \n    }, delay * 1000)\n    \/\/ 这里要返回Deferred下的promise对象Dererred对象的原因下面会解释\n    return dfd.promise();\n}\n\nAsync()\n    .done(function (data) {\n        log(data) \/\/ 如果延迟不大于三秒 输出dfd.resolve()中的数据 \x27一切正常!\x27\n    })\n    .fail(function (err) {\n        log(err) \/\/ 反之则 输出dfd.reject()中的数据 \x27超时了!\x27 \n    })\n    .always(function () {\n        log(\x27执行完毕!\x27); \/\/ 总是输出 \x27执行完毕!\x27\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3elog\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emsg\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(msg);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 包装一个异步操作\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Async = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成一个0到5秒的延迟\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e delay = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.floor(\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random() * \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个Deffered对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dfd = $.Deferred();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里调用一个异步操作\x3c\/span\x3e\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (delay \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 置dfd状态为resolved\x3c\/span\x3e\n            dfd.resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27一切正常!\x27\x3c\/span\x3e);\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 置dfd状态为rejected\x3c\/span\x3e\n            dfd.reject(\x3cspan class=\x22hljs-string\x22\x3e\x27超时了!\x27\x3c\/span\x3e);\n        }            \n    }, delay * \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里要返回Deferred下的promise对象Dererred对象的原因下面会解释\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e dfd.promise();\n}\n\nAsync()\n    .done(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n        log(data) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果延迟不大于三秒 输出dfd.resolve()中的数据 \x27一切正常!\x27\x3c\/span\x3e\n    })\n    .fail(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n        log(err) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 反之则 输出dfd.reject()中的数据 \x27超时了!\x27 \x3c\/span\x3e\n    })\n    .always(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        log(\x3cspan class=\x22hljs-string\x22\x3e\x27执行完毕!\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 总是输出 \x27执行完毕!\x27\x3c\/span\x3e\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e尝试下通俗理解整个流程就是\x3c\/h3\x3e\n\x3cblockquote\x3e\x3col\x3e\n\x3cli\x3e\x3cp\x3e在某个操作\x3cem\x3e开始前\x3c\/em\x3e创建一个\x3ccode\x3eDeferred\x3c\/code\x3e对象，然后执行操作\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e操作间可根据情况给dfd执行\x3ccode\x3erelove\x3c\/code\x3e或者\x3ccode\x3ereject\x3c\/code\x3e方法改变状态并传入数据\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最后返回出dfd的对象下的一个promise对象，这里不直接返回dfd对象是因为dfd对象的状态是在第一次resolve或者reject后还可以更改的（不过里面的数据以第一次为准）！！\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e操作执行后用\x3ccode\x3edone\x3c\/code\x3e和\x3ccode\x3efail\x3c\/code\x3e方法分别接受resolve和reject状态和数据（一一对应）然后执行回调（其实1.8还有个\x3ccode\x3ethen\x3c\/code\x3e方法，接受两个参数，第一个参数为\x3ccode\x3eresolve\x3c\/code\x3e的回调，第二个为\x3ccode\x3ereject\x3c\/code\x3e的）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ealways\x3c\/code\x3e是无论\x3ccode\x3eresolve\x3c\/code\x3e还是\x3ccode\x3ereject\x3c\/code\x3e都会执行。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e讲个比较烂的比喻啊\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e我是一个流水线车间质检工人，就在平常的这样的一天，来了一批玩具熊，嗯，接下来应该是这样的\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3col\x3e\n\x3cli\x3e\x3cp\x3e来了一个检查目标（\x3ccode\x3e$.Dererred()\x3c\/code\x3e），这时你还不知道它是好是坏\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e我靠我几十年的新东方炒菜技巧检验产品并给良品贴上了合格标签（\x3ccode\x3edfd.res* olve(合格标签)\x3c\/code\x3e），次品贴上回厂标签* （\x3ccode\x3edfd.reject(回厂标签及原因)\x3c\/code\x3e）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e然后通过的良品和次品都来到了各自的包装口打好包，不能对里面的标签做更改了！（\x3ccode\x3edfd.promise()\x3c\/code\x3e）去往自己下一个目的地(\x3ccode\x3ereturn dfd.promise\x3c\/code\x3e)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e再然后良品来到了熊孩子手中（\x3ccode\x3e.done()\x3c\/code\x3e）,次品回到了厂里（\x3ccode\x3e.fail()\x3c\/code\x3e）,最后不管玩具熊到了哪里，其实都会被开膛破肚（\x3ccode\x3e.always()\x3c\/code\x3e好吧这里有点牵强）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e这里再上一张图来解释下！\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005072400\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005072400\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e还有值得说一下的是\x3ccode\x3ealways\x3c\/code\x3e里的回调，我在实际中使用时发现总是在\x3ccode\x3edone\x3c\/code\x3e和\x3ccode\x3efail\x3c\/code\x3e里的回调(假设为同步)执行完毕后后执行的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e金掌银掌仙人掌 掌声有请 ES6 Promise\x3c\/h2\x3e\n\x3cp\x3e和上面一样，先打印一下！\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005072402\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005072402\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到Promise下也有熟悉的\x3ccode\x3eresolve\x3c\/code\x3e和\x3ccode\x3ereject\x3c\/code\x3e方法，好像和jQ的\x3ccode\x3eDeferred\x3c\/code\x3e颇为相似！但是不是少了点什么呢？\x3ccode\x3edone\x3c\/code\x3e或者\x3ccode\x3efail\x3c\/code\x3e之类的流程控制的方法呢？？\x3c\/p\x3e\n\x3cp\x3e不急，其实展开\x3ccode\x3eprototype\x3c\/code\x3e原型上就可以看到挂载着的\x3ccode\x3ethen\x3c\/code\x3e方法了！（像极了jQ1.8后那个\x3ccode\x3ethen\x3c\/code\x3e，不过我觉得应该说是jQ来遵循\x3ccode\x3ePromise\x3c\/code\x3e才对）\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005072404\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005072404\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3ePromise其实就是个构造函数，还是之前的例子，这里我们分三步走\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Async = function () {\n    \/\/ 第一步，新建个promise对象，所需的异步操作在其中进行\n    var prms = new Promise(function(resolve, reject){\n        \/\/ 生成一个0到5秒的延迟\n        var delay = Math.floor(Math.random() * 5);\n        \/\/ 这里调用一个异步操作\n        setTimeout(function(){\n            \/\/ 第二步， 根据情况置promise为resolve或者reject\n            if (delay \x3c= 2) {\n                \/\/ 置dfd状态为resolved\n                resolve(\x27一切正常!\x27);\n            } else {\n                \/\/ 置dfd状态为rejected\n                reject(\x27超时了!\x27);\n            }            \n        }, delay * 1000)\n    })\n    \/\/ 第三步，返回这个Promise对象\n    return prms\n}\n\n\/\/ 强大的来了\nAsync()\n    \/\/ then接受两个函数分别处理resolve和reject两种状态\n    .then(\n    function(data) {\n        console.log(data) \/\/ 一切正常!\n    }, \n    function(err) {\n        console.log(err) \/\/ 超时了!!\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Async = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一步，新建个promise对象，所需的异步操作在其中进行\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e prms = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成一个0到5秒的延迟\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e delay = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.floor(\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random() * \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里调用一个异步操作\x3c\/span\x3e\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第二步， 根据情况置promise为resolve或者reject\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (delay \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 置dfd状态为resolved\x3c\/span\x3e\n                resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27一切正常!\x27\x3c\/span\x3e);\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 置dfd状态为rejected\x3c\/span\x3e\n                reject(\x3cspan class=\x22hljs-string\x22\x3e\x27超时了!\x27\x3c\/span\x3e);\n            }            \n        }, delay * \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第三步，返回这个Promise对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e prms\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 强大的来了\x3c\/span\x3e\nAsync()\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ then接受两个函数分别处理resolve和reject两种状态\x3c\/span\x3e\n    .then(\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一切正常!\x3c\/span\x3e\n    }, \n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 超时了!!\x3c\/span\x3e\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e粗粗一看好像和\x3ccode\x3eDererred\x3c\/code\x3e不能更像了，，不过细心点的话可以发现我们在函数里直接返回了\x3ccode\x3eprms\x3c\/code\x3e这个对象，而不是像之前把包装了一层。。。对！因为\x3ccode\x3ePromise\x3c\/code\x3e的特性就是一旦第一次赋予了状态后面就无法更改了，这也算省心多了吧。但是问题来了，我为什么要选择用\x3ccode\x3ePromise\x3c\/code\x3e呢？？\x3c\/p\x3e\n\x3cp\x3e这么说吧，\x3cstrong\x3e它是原生的 它是原生的 它是原生的！\x3c\/strong\x3e，还有\x3cstrong\x3e可以链式链式链式链式调用！\x3c\/strong\x3e，我们可以把每一个\x3ccode\x3ethen\x3c\/code\x3e或者\x3ccode\x3ecatch\x3c\/code\x3e当做一个处理器, 比如这样\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Async()\n    \/\/ 这里暂时只处理resolve\n    .then(function(data) {\n        console.log(data) \/\/ 一切正常!\n        return Promise.resolve(\x27随便什么\x27);\n    })\n    \/\/ 下一个then处理器接收到上一个处理器发出的数据\n    .then(function(data2) {\n        console.log(data2) \/\/ 随便什么\n        return Promise.reject(\x27错误数据\x27);\n    })\n    ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3eAsync()\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里暂时只处理resolve\x3c\/span\x3e\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一切正常!\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27随便什么\x27\x3c\/span\x3e);\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 下一个then处理器接收到上一个处理器发出的数据\x3c\/span\x3e\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata2\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data2) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 随便什么\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.reject(\x3cspan class=\x22hljs-string\x22\x3e\x27错误数据\x27\x3c\/span\x3e);\n    })\n    ...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对！没看错，其实在\x3ccode\x3ethen\x3c\/code\x3e里面你还可以\x3ccode\x3ereturn\x3c\/code\x3e其他的\x3ccode\x3epromise\x3c\/code\x3e对象传并递数据！更有甚你甚至可以什么都不返回，比如说这样\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Async()\n    .then(function(data) {\n        console.log(data) \/\/ 一切正常!\n    })\n    \/\/ 上面那个处理器如果不return任何东西 就会默认返回个resolve(undefined)\n    \/\/ 然后下面的处理器就会接收到这个resolve(undefined)\n    .then(function(data2) {\n        console.log(data2) \/\/ undefined\n        \/\/ 虽然没有数据来处理，但是你还可以在这里做一些事情啊，例如\n        return Promise.reject(\x27错误数据\x27);\n    })\n    \/\/ 嗒哒，catch就这么登场了，这里用catch处理上个then处理器发出的reject\n    .catch(fucntion(err){\n        console.log(err) \/\/ 错误数据\n        return \x27那直接返回个字符串呢？\x27\n    })\n    \/\/ 上个catch处理器返回了个字符串其实也会被下个处理器接受\n    \/\/ 相当于resolve(\x27那直接返回个字符串呢？\x27)\n    .then(function(data3){\n        console.log(data3) \/\/ 那直接返回个字符串呢？\n    })\n    \/\/ 好，接着我们来试试在没有返回任何东西的情况下接一个catch处理器\n    .catch(function(err2){\n        console.log(err2) \n        \/\/ 我们可以来猜一下上面会输出什么，undefined吗？\n        \/\/ 错，其实这里什么都不会输出，因为这个catch接收的是resolve\n        \/\/ 但它并不会吞没这个resolve而是选择跳过，例如我们这里再返回\n        return Promise.resolve(\x27这个字符串会被跳过\x27)\n    })\n    \/\/ 这里紧接着个then处理器，它接受到的数据呢\n    \/\/ 其实并不是上个catch返回的resolve(\x27这个字符串会被跳过\x27)\n    \/\/ 而是catch之前那个then处理器默认返回的resolve(undefined)\n    .then(function(data4){\n        console.log(data4) \/\/ undefined\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eAsync()\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一切正常!\x3c\/span\x3e\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上面那个处理器如果不return任何东西 就会默认返回个resolve(undefined)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 然后下面的处理器就会接收到这个resolve(undefined)\x3c\/span\x3e\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata2\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data2) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 虽然没有数据来处理，但是你还可以在这里做一些事情啊，例如\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.reject(\x3cspan class=\x22hljs-string\x22\x3e\x27错误数据\x27\x3c\/span\x3e);\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 嗒哒，catch就这么登场了，这里用catch处理上个then处理器发出的reject\x3c\/span\x3e\n    .catch(fucntion(err){\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 错误数据\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27那直接返回个字符串呢？\x27\x3c\/span\x3e\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上个catch处理器返回了个字符串其实也会被下个处理器接受\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 相当于resolve(\x27那直接返回个字符串呢？\x27)\x3c\/span\x3e\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata3\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data3) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 那直接返回个字符串呢？\x3c\/span\x3e\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 好，接着我们来试试在没有返回任何东西的情况下接一个catch处理器\x3c\/span\x3e\n    .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr2\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err2) \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 我们可以来猜一下上面会输出什么，undefined吗？\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 错，其实这里什么都不会输出，因为这个catch接收的是resolve\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但它并不会吞没这个resolve而是选择跳过，例如我们这里再返回\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27这个字符串会被跳过\x27\x3c\/span\x3e)\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里紧接着个then处理器，它接受到的数据呢\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其实并不是上个catch返回的resolve(\x27这个字符串会被跳过\x27)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 而是catch之前那个then处理器默认返回的resolve(undefined)\x3c\/span\x3e\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata4\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data4) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有点被绕晕了吧\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVvrII\x22 src=\x22https:\/\/static.alili.tech\/img\/bVvrII\x22 alt=\x225.gif\x22 title=\x225.gif\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e我们用一句话来梳理下：\x3c\/h3\x3e\n\x3cp\x3e链式调下会有一串\x3ccode\x3ethen\x3c\/code\x3e和\x3ccode\x3ecatch\x3c\/code\x3e，这些\x3ccode\x3ethen\x3c\/code\x3e和\x3ccode\x3ecatch\x3c\/code\x3e处理器会\x3cem\x3e按照顺序\x3c\/em\x3e接受\x3cem\x3e上个处理器\x3c\/em\x3e所产生的返回值，并且根据\x3cem\x3e传入的状态\x3c\/em\x3e做出\x3cem\x3e不同\x3c\/em\x3e响应，要么跳过，要么处理(所以上面23行处的\x3ccode\x3ecatch\x3c\/code\x3e处理器被跳过了)\x3c\/p\x3e\n\x3cp\x3eps: 上面我们用的\x3ccode\x3ethen\x3c\/code\x3e处理器只有一个函数参数，所以只会处理\x3ccode\x3eresolve\x3c\/code\x3e状态，如果是两个\x3ccode\x3ethen\x3c\/code\x3e就可以处理\x3ccode\x3ereject\x3c\/code\x3e了。\x3c\/p\x3e\n\x3cp\x3e－－－－更新于5月11日－－－－－\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\n\x3ccode\x3ecatch\x3c\/code\x3e使用的注意\x3c\/h3\x3e\n\x3cp\x3e上面一块代码中引出了\x3ccode\x3ecatch\x3c\/code\x3e处理器, 之前以为 \x3ccode\x3ecacth()\x3c\/code\x3e 是 \x3ccode\x3ethen(null, ...)\x3c\/code\x3e 的语法糖, 其实这么说不完全正确（功能层面上来说这两个是完全相同的没错——都是处理\x3ccode\x3ereject\x3c\/code\x3e和异常），但是到了实际使用中\x3ca href=\x22https:\/\/pouchdb.com\/2015\/05\/18\/we-have-a-problem-with-promises.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise中的菜鸟和高阶错误\x3c\/a\x3e文章中给出了明确的情况证明，这里贴一下:\x3c\/p\x3e\n\x3cp\x3e首先只处理异常情况，下面两个是等价的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nsomePromise().catch(function (err) {\n  \/\/ 处理异常\n});\n\nsomePromise().then(null, function (err) {\n  \/\/ 处理异常\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\nsomePromise().catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理异常\x3c\/span\x3e\n});\n\nsomePromise().then(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理异常\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是，如果不只是处理异常的下面两种情况下就不一样了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22somePromise().then(function () {\n  return otherPromise();\n}).catch(function (err) {\n  \/\/ 处理异常\n});\n\nsomePromise().then(function () {\n  return otherPromise();\n}, function (err) {\n  \/\/ 处理异常\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esomePromise().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e otherPromise();\n}).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理异常\x3c\/span\x3e\n});\n\nsomePromise().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e otherPromise();\n}, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理异常\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不够清楚吗？那么如果是这样呢？如果\x3ccode\x3e第一个回调函数抛出一个错误\x3c\/code\x3e会发生什么？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22somePromise().then(function () {\n  throw new Error(\x27这里错了！\x27);\n}).catch(function (err) {\n  console.log(err)\n  \/\/ 这里错了! :)\n});\n\nsomePromise().then(\nfunction () {\n  throw new Error(\x27这里错了\x27);\n}, \nfunction (err) {\n  console.log(err)\n  \/\/ 未知 :(\n  \/\/ 并没有catch到上面那个Error\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esomePromise().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27这里错了！\x27\x3c\/span\x3e);\n}).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里错了! :)\x3c\/span\x3e\n});\n\nsomePromise().then(\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27这里错了\x27\x3c\/span\x3e);\n}, \n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 未知 :(\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 并没有catch到上面那个Error\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e结论就是，当使用 \x3ccode\x3ethen(resolveHandler, rejectHandler)\x3c\/code\x3e ， \x3ccode\x3erejectHandler\x3c\/code\x3e 不会捕获在 \x3ccode\x3eresolveHandler\x3c\/code\x3e 中抛出的错误!\x3c\/p\x3e\n\x3ch4\x3e贴完了，好吧，这有什么用呢？\x3c\/h4\x3e\n\x3cp\x3e看似这个注意项并不影响平常使用，原文作者也说道:\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e因为，笔者的个人习惯是从不使用then方法的第二个参数，转而使用 catch() 方法\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e那么，问题来了，如何正确的使用\x3ccode\x3ecatch\x3c\/code\x3e呢? 其实我没有很好的想明白，\x3ccode\x3e希望指教\x3c\/code\x3e，随便抛两个砖\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 1\nsomePromise()\n    .then(resolveHandler)\n    \/\/ 这个catch会处理somePromise或者resolveHandler的异常\n    .catch(rejectHandler) \n    .then(otherResolveHandler)\n    \/\/ 而这个catch呢只会处理resolveHandler的异常\n    .catch(otherRejectHandler)\n    \n\/\/ 2\nsomePromise()\n    .then(resolveHandler)\n    .then(otherResolveHandler)\n    \/\/ 至于这个catch则会处理somePromise、resolveHandler和otherResolveHandler的异常\n    .catch(rejectHandler)\n    \n\/\/ 3 \nsomePromise()\n    .catch(console.log.bind(console))\n    \/\/等价于\n    .catch(function(err){\n        console.log(err)\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\nsomePromise()\n    .then(resolveHandler)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个catch会处理somePromise或者resolveHandler的异常\x3c\/span\x3e\n    .catch(rejectHandler) \n    .then(otherResolveHandler)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 而这个catch呢只会处理resolveHandler的异常\x3c\/span\x3e\n    .catch(otherRejectHandler)\n    \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\nsomePromise()\n    .then(resolveHandler)\n    .then(otherResolveHandler)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 至于这个catch则会处理somePromise、resolveHandler和otherResolveHandler的异常\x3c\/span\x3e\n    .catch(rejectHandler)\n    \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3 \x3c\/span\x3e\nsomePromise()\n    .catch(\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log.bind(\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/等价于\x3c\/span\x3e\n    .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e哈哈哈哈哈哈,还是好好再去想想Promise去了，弄明白了再来补充，再次谢谢\x3ca href=\x22https:\/\/segmentfault.com\/u\/nightire\x22\x3e@n͛i͛g͛h͛t͛i͛r͛e͛大大\x3c\/a\x3e，荆柯刺秦王\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006770036\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006770036\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e写的很粗糙，有错误的地方希望多多指教！！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>流程控制： jQ Deferred 与 ES6 Promise 使用新手向入坑！</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005072394">https://segmentfault.com/a/1190000005072394</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/fu12hg3vbdc/" target="_blank">https://alili.tech/archive/fu12hg3vbdc/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>