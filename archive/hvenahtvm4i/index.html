<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="详解JS类概念的实现"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>详解JS类概念的实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/hvenahtvm4i/",
				"appid": "1613049289050283", 
				"title": "详解JS类概念的实现 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-12T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/hxl51jf33e/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7wvxkyaw52a/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fhvenahtvm4i%2f&text=%e8%af%a6%e8%a7%a3JS%e7%b1%bb%e6%a6%82%e5%bf%b5%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fhvenahtvm4i%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fhvenahtvm4i%2f&text=%e8%af%a6%e8%a7%a3JS%e7%b1%bb%e6%a6%82%e5%bf%b5%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fhvenahtvm4i%2f&title=%e8%af%a6%e8%a7%a3JS%e7%b1%bb%e6%a6%82%e5%bf%b5%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fhvenahtvm4i%2f&is_video=false&description=%e8%af%a6%e8%a7%a3JS%e7%b1%bb%e6%a6%82%e5%bf%b5%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%af%a6%e8%a7%a3JS%e7%b1%bb%e6%a6%82%e5%bf%b5%e7%9a%84%e5%ae%9e%e7%8e%b0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fhvenahtvm4i%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fhvenahtvm4i%2f&title=%e8%af%a6%e8%a7%a3JS%e7%b1%bb%e6%a6%82%e5%bf%b5%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhvenahtvm4i%2f&title=%e8%af%a6%e8%a7%a3JS%e7%b1%bb%e6%a6%82%e5%bf%b5%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhvenahtvm4i%2f&title=%e8%af%a6%e8%a7%a3JS%e7%b1%bb%e6%a6%82%e5%bf%b5%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhvenahtvm4i%2f&title=%e8%af%a6%e8%a7%a3JS%e7%b1%bb%e6%a6%82%e5%bf%b5%e7%9a%84%e5%ae%9e%e7%8e%b0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">详解JS类概念的实现</h1><div class="meta"><div class="postdate"><time datetime="2019-02-12" itemprop="datePublished">2019-02-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e众所周知，JS并没有类(class)的概念,虽然说ES6开始有了类的概念，但是，这并不是说JS有了像Ruby、Java这些基于类的面向对象语言一样，有了全新的继承模型。ES6中的类，仅仅只是基于现有的原型继承的一种语法糖，下面我们好好分析一下，具体是如何实现的\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e\x3ca href=\x22https:\/\/zh.wikipedia.org\/wiki\/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e面向对象思想\x3c\/a\x3e\x3c\/h2\x3e\n\x3cp\x3e在讲正题之前，我们先来讨论一下各种面试题都可能出现的一个问题，什么是\x3ccode\x3e面向对象编程（OOP）\x3c\/code\x3e?\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e类：定义某一事物的抽象特点，包含属性和方法，举个栗子，\x3ccode\x3e狗\x3c\/code\x3e这个类包含狗的一些基础特征，如毛皮颜色，吠叫等能力。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e对象：类的一个实例，还是举个栗子，小明家的白色的狗和小红家红色的狗。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e属性：对象的特征，比如刚提到的狗皮毛的颜色。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e方法：对象的行为，比如刚才提到的狗的吠叫能力。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e封装性：通过限制只有特定类的对象可以访问特定类的成员，一般包含\x3ccode\x3epublic\x3c\/code\x3e \x3ccode\x3eprotected\x3c\/code\x3e \x3ccode\x3eprivate\x3c\/code\x3e 三种，不同语言的实现不同。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e继承性：一个类会有\x3ccode\x3e子类\x3c\/code\x3e,这个\x3ccode\x3e子类\x3c\/code\x3e是更具体化的一个抽象，它包含\x3ccode\x3e父类\x3c\/code\x3e的一些属性和方法，并且有可能有不同于\x3ccode\x3e父类\x3c\/code\x3e的属性和方法。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e多态性：多意为‘许多’，态意为‘形态’。不同类可以定义相同的方法或属性。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e抽象性：复杂现实问题转化为类定义的途径，包括以上所有内容。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e如何实现对象（类）的定义\x3c\/h2\x3e\n\x3cp\x3e由于JS并没有\x3ccode\x3e类(class)\x3c\/code\x3e的概念，更多的时候我们把它叫做\x3ccode\x3e对象（function）\x3c\/code\x3e，然后把\x3ccode\x3e对象\x3c\/code\x3e叫做\x3ccode\x3e实例(instance)\x3c\/code\x3e，跟团队里面的人讨论OOP的时候，经常会有概念上的一些误解，特此说明一下。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e构造函数：一个指明了对象类型的函数，通常我们可以通过构造函数类创建\x3c\/h3\x3e\n\x3cp\x3e在js里面，我们通常都是通过构造函数来创建\x3ccode\x3e对象(class)\x3c\/code\x3e,然后通过\x3ccode\x3enew\x3c\/code\x3e这个关键字来实例化一个对象，如:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Dog(name){\n  this.name = name;\n}\nvar d1 = new Dog(\x26quot;dodo\x26quot;);\nd1.constructor\n\/\/ Dog(name){\n\/\/  this.name = name;\n\/\/ }\n\nvar d2 = new Dog(\x27do2do\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDog\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e d1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dog(\x3cspan class=\x22hljs-string\x22\x3e\x22dodo\x22\x3c\/span\x3e);\nd1.constructor\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Dog(name){\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  this.name = name;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ }\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e d2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dog(\x3cspan class=\x22hljs-string\x22\x3e\x27do2do\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为什么通过\x3ccode\x3e构造函数\x3c\/code\x3e可以实现\x3ccode\x3e对象（class）\x3c\/code\x3e属性的定义呢？首先，我们必须理解这个语法\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Operators\/new\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3enew constructor[([arguments])]\x3c\/code\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e我们来具体看看当\x3ccode\x3enew Dog(\x27name\x27)\x3c\/code\x3e时，具体做了哪些事情\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e一个新实例被创建。它继承自\x3ccode\x3eDog.prototype\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e构造函数被执行，相应的参数会被传入，同时上下文(\x3ccode\x3ethis\x3c\/code\x3e)会指向这个新的实例\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e除非明确返回值，否则返回新的实例\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e至此，我们实现了OOP里面的类(Dog)、对象(d1,d2)、和属性(name)的概念，\x3ccode\x3ed1\x3c\/code\x3e和\x3ccode\x3ed2\x3c\/code\x3e有相同的\x3ccode\x3ename\x3c\/code\x3e属性，但是值并不相同,即属性是私有的。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注: 新创建的实例，都包含一个\x3ccode\x3econstructor\x3c\/code\x3e属性，该属性指向他们的构造函数\x3ccode\x3eDog\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e原型对象(prototype)\x3c\/h3\x3e\n\x3cp\x3e接下来，我们即将讨论如何定义方法，其实，我们完全可以这样定义我们的方法，如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Dog(name){\n  this.name = name;\n  this.bark = function(){\n    console.log(this.name \x2b \x26quot; bark\x26quot;);\n  };\n}\nvar d1 = new Dog(\x26quot;dodo\x26quot;);\nd1.bark();\n\/\/ dodo bark\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDog\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.bark = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 bark\x22\x3c\/span\x3e);\n  };\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e d1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dog(\x3cspan class=\x22hljs-string\x22\x3e\x22dodo\x22\x3c\/span\x3e);\nd1.bark();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ dodo bark\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是，一般我们不推荐这么做，正如我们所知\x3ccode\x3eDog\x3c\/code\x3e是一个构造函数，每次实例化时，都会执行这个函数，也就是说，\x3ccode\x3ebark\x3c\/code\x3e 这个方法每次都会被定义, 比较浪费内存。但是我们通常可以用\x3ccode\x3econstructor\x3c\/code\x3e和闭包的方式来实现私有属性，如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Dog(name){\n  this.name = name;\n  \n  \/\/ barkCount 是私有属性，因为实例并不知道这个属性\n  var barkCount = 0;\n  this.bark = function(){\n    barkCount \x2b\x2b;\n    console.log(this.name \x2b \x26quot; bark\x26quot;);\n  };\n  this.getBarkCount = function(){\n    console.log(this.name \x2b \x26quot; has barked \x26quot; \x2b barkCount \x2b \x26quot; times\x26quot;);\n  };\n}\nvar d1 = new Dog(\x26quot;dodo\x26quot;);\nd1.bark();\nd1.bark();\nd1.getBarkCount();\n\/\/ dodo has barked 2 times\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDog\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ barkCount 是私有属性，因为实例并不知道这个属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e barkCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.bark = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    barkCount \x2b\x2b;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 bark\x22\x3c\/span\x3e);\n  };\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getBarkCount = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 has barked \x22\x3c\/span\x3e \x2b barkCount \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 times\x22\x3c\/span\x3e);\n  };\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e d1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dog(\x3cspan class=\x22hljs-string\x22\x3e\x22dodo\x22\x3c\/span\x3e);\nd1.bark();\nd1.bark();\nd1.getBarkCount();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ dodo has barked 2 times\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e好像扯得有点远，我们回归我们的主角\x3ccode\x3eprototype\x3c\/code\x3e，函数\x3ccode\x3eDog\x3c\/code\x3e有一个特殊的属性，这个属性就叫原型，如上所述，当用\x3ccode\x3enew\x3c\/code\x3e运算符创建实例时，会把\x3ccode\x3eDog\x3c\/code\x3e的原型对象的引用复制到新的实例内部的[[Prototype]]属性，即\x3ccode\x3ed1.[[Prototype]] = Dog.prototype\x3c\/code\x3e，因为所有的实例的[[Prototype]]都指向\x3ccode\x3eDog\x3c\/code\x3e的原型对象，那么，我们就可以很方便的定义我们的方法了，如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Dog(name){\n  this.name = name;\n}\n\nDog.prototype = {\n  bark: function(){\n    console.log(this.name \x2b \x26quot; bark\x26quot;);\n  }\n};\n\nvar d1 = new Dog(\x26quot;dodo\x26quot;);\nd1.bark();\n\/\/ dodo bark\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDog\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n}\n\nDog.prototype = {\n  \x3cspan class=\x22hljs-attr\x22\x3ebark\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 bark\x22\x3c\/span\x3e);\n  }\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e d1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dog(\x3cspan class=\x22hljs-string\x22\x3e\x22dodo\x22\x3c\/span\x3e);\nd1.bark();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ dodo bark\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以通过\x3ccode\x3ed1.__proto__ == Dog.prototype\x3c\/code\x3e，来验证我们的想法。用原型对象还有一个好处，由于实例化的对象的[[Prototype]]指向\x3ccode\x3eDog\x3c\/code\x3e的原型对象，那么我们可以通过添加\x3ccode\x3eDog\x3c\/code\x3e的原型对象的方法，来添加已经实例化后的实例\x3ccode\x3ed1\x3c\/code\x3e的方法。如:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Dog.prototype.run = function(){\n  console.log(this.name \x2b \x26quot; is running!\x26quot;);\n}\nd1.run();\n\/\/ dodo is running!\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eDog.prototype.run = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 is running!\x22\x3c\/span\x3e);\n}\nd1.run();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ dodo is running!\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e注：所有对象的\x3ccode\x3e__proto__\x3c\/code\x3e都指向其构造器的\x3ccode\x3eprototype\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e原型链\x3c\/h3\x3e\n\x3cp\x3e上面已经描述如何定义一个\x3ccode\x3e类\x3c\/code\x3e，接下来我们将要了解，如何实现\x3ccode\x3e类的继承\x3c\/code\x3e。在此之前，我们先了解js里一个老生常谈的概念：\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Inheritance_and_the_prototype_chain\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e原型链\x3c\/a\x3e：每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链\x3c\/p\x3e\n\x3cp\x3emozilla给出一个挺好的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 假定有一个对象 o, 其自身的属性（own properties）有 a 和 b：\n\/\/ {a: 1, b: 2}\n\/\/ o 的原型 o.[[Prototype]]有属性 b 和 c：\n\/\/ {b: 3, c: 4}\n\/\/ 最后, o.[[Prototype]].[[Prototype]] 是 null.\n\/\/ 这就是原型链的末尾，即 null，\n\/\/ 根据定义，null 没有[[Prototype]].\n\/\/ 综上，整个原型链如下: \n\/\/ {a:1, b:2} ---\x3e {b:3, c:4} ---\x3e null\n\nconsole.log(o.a); \/\/ 1\n\/\/ a是o的自身属性吗？是的，该属性的值为1\n\nconsole.log(o.b); \/\/ 2\n\/\/ b是o的自身属性吗？是的，该属性的值为2\n\/\/ o.[[Prototype]]上还有一个\x27b\x27属性,但是它不会被访问到.这种情况称为\x26quot;属性遮蔽 (property shadowing)\x26quot;.\n\nconsole.log(o.c); \/\/ 4\n\/\/ c是o的自身属性吗？不是，那看看o.[[Prototype]]上有没有.\n\/\/ c是o.[[Prototype]]的自身属性吗？是的,该属性的值为4\n\nconsole.log(o.d); \/\/ undefined\n\/\/ d是o的自身属性吗？不是,那看看o.[[Prototype]]上有没有.\n\/\/ d是o.[[Prototype]]的自身属性吗？不是，那看看o.[[Prototype]].[[Prototype]]上有没有.\n\/\/ o.[[Prototype]].[[Prototype]]为null，停止搜索，\n\/\/ 没有d属性，返回undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 假定有一个对象 o, 其自身的属性（own properties）有 a 和 b：\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ {a: 1, b: 2}\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ o 的原型 o.[[Prototype]]有属性 b 和 c：\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ {b: 3, c: 4}\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最后, o.[[Prototype]].[[Prototype]] 是 null.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这就是原型链的末尾，即 null，\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据定义，null 没有[[Prototype]].\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 综上，整个原型链如下: \x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ {a:1, b:2} ---\x26gt; {b:3, c:4} ---\x26gt; null\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(o.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ a是o的自身属性吗？是的，该属性的值为1\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(o.b); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ b是o的自身属性吗？是的，该属性的值为2\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ o.[[Prototype]]上还有一个\x27b\x27属性,但是它不会被访问到.这种情况称为\x22属性遮蔽 (property shadowing)\x22.\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(o.c); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ c是o的自身属性吗？不是，那看看o.[[Prototype]]上有没有.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ c是o.[[Prototype]]的自身属性吗？是的,该属性的值为4\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(o.d); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ d是o的自身属性吗？不是,那看看o.[[Prototype]]上有没有.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ d是o.[[Prototype]]的自身属性吗？不是，那看看o.[[Prototype]].[[Prototype]]上有没有.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ o.[[Prototype]].[[Prototype]]为null，停止搜索，\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 没有d属性，返回undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们可以通过我们理解的构造函数和原型对象来实现继承的概念了，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Dog(name){\n  this.name = name;\n}\n\n\/\/ 这种写法会修改dog实例的constructor，可以通过Dog.prototype.constructor = Dog来重置\nDog.prototype = {\n  bark: function(){\n    console.log(this.name \x2b \x26quot; bark\x26quot;);\n  }\n};\n\n\/\/ 重置Dog实例的构造函数为本身\nDog.prototype.constructor = Dog;\n\n\/\/ Haski 的构造函数\nfunction Haski(name){\n  \/\/ 继承Dog的构造函数\n  Dog.call(this, name);\n  \/\/ 可以补充更多Haski的属性\n  this.type = \x26quot;Haski\x26quot;;\n};\n\n\/\/ 1. 设置Haski的prototype为Dog的实例对象\n\/\/ 2. 此时Haski的原型链是 Haski -\x3e Dog的实例 -\x3e Dog -\x3e Object\n\/\/ 3. 此时，Haski包含了Dog的所有属性和方法，而且还有一个指针，指向Dog的原型对象\n\/\/ 4. 这种做法是不推荐的，下面会改进\nHaski.prototype = new Dog();\n\n\/\/ 重置Haski实例的构造函数为本身\nHaski.prototype.constructor = Haski;\n\n\/\/ 可以为子类添加更多的方法\nHaski.prototype.say = function(){\n  console.log(\x26quot;I\x27m \x26quot; \x2b this.name);\n}\n\nvar ha = new Haski(\x26quot;Ha\x26quot;);\n\/\/ Ha bark\nha.bark();\n\/\/ Ha bark\nha.say();\n\/\/ I\x27m Ha\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDog\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这种写法会修改dog实例的constructor，可以通过Dog.prototype.constructor = Dog来重置\x3c\/span\x3e\nDog.prototype = {\n  \x3cspan class=\x22hljs-attr\x22\x3ebark\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 bark\x22\x3c\/span\x3e);\n  }\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重置Dog实例的构造函数为本身\x3c\/span\x3e\nDog.prototype.constructor = Dog;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Haski 的构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHaski\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 继承Dog的构造函数\x3c\/span\x3e\n  Dog.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可以补充更多Haski的属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = \x3cspan class=\x22hljs-string\x22\x3e\x22Haski\x22\x3c\/span\x3e;\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1. 设置Haski的prototype为Dog的实例对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2. 此时Haski的原型链是 Haski -\x26gt; Dog的实例 -\x26gt; Dog -\x26gt; Object\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3. 此时，Haski包含了Dog的所有属性和方法，而且还有一个指针，指向Dog的原型对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4. 这种做法是不推荐的，下面会改进\x3c\/span\x3e\nHaski.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dog();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重置Haski实例的构造函数为本身\x3c\/span\x3e\nHaski.prototype.constructor = Haski;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可以为子类添加更多的方法\x3c\/span\x3e\nHaski.prototype.say = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22I\x27m \x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ha = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Haski(\x3cspan class=\x22hljs-string\x22\x3e\x22Ha\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Ha bark\x3c\/span\x3e\nha.bark();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Ha bark\x3c\/span\x3e\nha.say();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ I\x27m Ha\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e注： 子类在定义prototype时，不可直接使用\x3ccode\x3eHaski.prototype = {}\x3c\/code\x3e定义，这样会重写Haski的原型链，把Haski的原型当做\x3ccode\x3eObject\x3c\/code\x3e的实例，而非\x3ccode\x3eDog\x3c\/code\x3e的实例\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e但是，当我想找一下\x3ccode\x3eha\x3c\/code\x3e的原型链时，会发现\x3ccode\x3eha\x3c\/code\x3e的原型对象指向的是\x3ccode\x3eDog\x3c\/code\x3e的实例，而且还有一个值为\x3ccode\x3eundefined\x3c\/code\x3e的\x3ccode\x3ename\x3c\/code\x3e属性，在实例化时，name是没必要的, 如下图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ww4.sinaimg.cn\/large\/785cd1e3jw1f2bmnt5qn4j20d50a4abw.jpg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ww4.sinaimg.cn\/large\/785cd1e3jw1f2bmnt5qn4j20d50a4abw.jpg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e所以，我们需要修改一下我们的实现，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 修改前\nHaski.prototype = new Dog();\n\n\/\/ 修改后\nHaski.prototype = Object.create(Dog.prototype);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改前\x3c\/span\x3e\nHaski.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dog();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改后\x3c\/span\x3e\nHaski.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(Dog.prototype);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ww1.sinaimg.cn\/large\/785cd1e3jw1f2bp2gl1sij20qs0iogpa.jpg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ww1.sinaimg.cn\/large\/785cd1e3jw1f2bp2gl1sij20qs0iogpa.jpg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注: \x3ccode\x3e__proto__\x3c\/code\x3e 方法已弃用，从 ECMAScript 6 开始, [[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e自此，我们已经实现继承的概念，父类有自己的方法，子类继承了父类的属性和方法，而且还可以定义自己的属性和方法。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eES6 如何实现\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27;\n\/\/ 声明 Dog 类\nclass Dog {\n  \/\/ 构造函数\n  constructor(name){\n    this.name = name;\n  }\n \n  \/\/ 普通方法\n  dark(){\n    console.log(this.name \x2b \x26quot;bark\x26quot;);\n  }\n \n  \/\/ 静态方法，也叫类方法\n  static staticMethod(){\n    console.log(\x26quot;I\x27m static method!\x26quot;);\n  }\n}\n\n\/\/ 通过`extends`关键字来实现继承\nclass Haski extends Dog {\n  constructor(name){\n    \/\/ 调用父类的构造函数\n    super(name);\n    this.type = \x26quot;Haski\x26quot;;\n  }\n  \n  \/\/ 定义子类方法\n  say(){\n    console.log(\x26quot;I\x27m\x26quot; \x2b this.name);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 声明 Dog 类\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDog\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构造函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name){\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  }\n \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 普通方法\x3c\/span\x3e\n  dark(){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22bark\x22\x3c\/span\x3e);\n  }\n \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 静态方法，也叫类方法\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e staticMethod(){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22I\x27m static method!\x22\x3c\/span\x3e);\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过`extends`关键字来实现继承\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHaski\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDog\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用父类的构造函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(name);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = \x3cspan class=\x22hljs-string\x22\x3e\x22Haski\x22\x3c\/span\x3e;\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义子类方法\x3c\/span\x3e\n  say(){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22I\x27m\x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在ES6中，我们只需通过\x3ccode\x3eclass\x3c\/code\x3e \x3ccode\x3eextends\x3c\/code\x3e \x3ccode\x3esuper\x3c\/code\x3e \x3ccode\x3econstructor\x3c\/code\x3e 即可比较方便的完成原来使用JS比较难理解的实现，我们可以通过babel的解析器，来看看babel是怎么把这些语法糖转成JS的实现的。具体代码可以参考\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;use strict\x26quot;;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i \x3c props.length; i\x2b\x2b) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\x26quot;value\x26quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\x26quot;this hasn\x27t been initialised - super() hasn\x27t been called\x26quot;); } return call \x26amp;\x26amp; (typeof call === \x26quot;object\x26quot; || typeof call === \x26quot;function\x26quot;) ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \x26quot;function\x26quot; \x26amp;\x26amp; superClass !== null) { throw new TypeError(\x26quot;Super expression must either be null or a function, not \x26quot; \x2b typeof superClass); } subClass.prototype = Object.create(superClass \x26amp;\x26amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\x26quot;Cannot call a class as a function\x26quot;); } }\n\n\/\/ 声明 Dog 类\n\nvar Dog = function () {\n  \/\/ 构造函数\n\n  function Dog(name) {\n    _classCallCheck(this, Dog);\n\n    this.name = name;\n  }\n\n  \/\/ 普通方法\n\n\n  _createClass(Dog, [{\n    key: \x26quot;dark\x26quot;,\n    value: function dark() {\n      console.log(this.name \x2b \x26quot;bark\x26quot;);\n    }\n\n    \/\/ 静态方法，也叫类方法\n\n  }], [{\n    key: \x26quot;staticMethod\x26quot;,\n    value: function staticMethod() {\n      console.log(\x26quot;I\x27m static method!\x26quot;);\n    }\n  }]);\n\n  return Dog;\n}();\n\n\/\/ 通过`extends`关键字来实现继承\n\n\nvar Haski = function (_Dog) {\n  _inherits(Haski, _Dog);\n\n  function Haski(name) {\n    _classCallCheck(this, Haski);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Haski).call(this, name));\n    \/\/ 调用父类的构造函数\n\n\n    _this.type = \x26quot;Haski\x26quot;;\n    return _this;\n  }\n\n  _createClass(Haski, [{\n    key: \x26quot;say\x26quot;,\n    value: function say() {\n      console.log(\x26quot;I\x27m\x26quot; \x2b this.name);\n    }\n  }]);\n\n  return Haski;\n}(Dog);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x22use strict\x22\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _createClass = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineProperties\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget, props\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; props.length; i\x2b\x2b) { \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e; descriptor.configurable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e; \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22value\x22\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e descriptor) descriptor.writable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e; \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(target, descriptor.key, descriptor); } } \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eConstructor, protoProps, staticProps\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (protoProps) defineProperties(Constructor.prototype, protoProps); \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (staticProps) defineProperties(Constructor, staticProps); \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Constructor; }; }();\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_possibleConstructorReturn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eself, call\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!self) { \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eReferenceError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22this hasn\x27t been initialised - super() hasn\x27t been called\x22\x3c\/span\x3e); } \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e call \x26amp;\x26amp; (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e call === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e call === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e) ? call : self; }\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_inherits\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esubClass, superClass\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e superClass !== \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e \x26amp;\x26amp; superClass !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) { \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22Super expression must either be null or a function, not \x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e superClass); } subClass.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(superClass \x26amp;\x26amp; superClass.prototype, { \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: { \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: subClass, \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e } }); \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (superClass) \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf ? \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_classCallCheck\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einstance, Constructor\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(instance \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Constructor)) { \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22Cannot call a class as a function\x22\x3c\/span\x3e); } }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 声明 Dog 类\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Dog = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构造函数\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDog\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n    _classCallCheck(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, Dog);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 普通方法\x3c\/span\x3e\n\n\n  _createClass(Dog, [{\n    \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22dark\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edark\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22bark\x22\x3c\/span\x3e);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 静态方法，也叫类方法\x3c\/span\x3e\n\n  }], [{\n    \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22staticMethod\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estaticMethod\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22I\x27m static method!\x22\x3c\/span\x3e);\n    }\n  }]);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Dog;\n}();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过`extends`关键字来实现继承\x3c\/span\x3e\n\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Haski = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e_Dog\x3c\/span\x3e) \x3c\/span\x3e{\n  _inherits(Haski, _Dog);\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHaski\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n    _classCallCheck(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, Haski);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = _possibleConstructorReturn(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(Haski).call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name));\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用父类的构造函数\x3c\/span\x3e\n\n\n    _this.type = \x3cspan class=\x22hljs-string\x22\x3e\x22Haski\x22\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this;\n  }\n\n  _createClass(Haski, [{\n    \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22say\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esay\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22I\x27m\x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n  }]);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Haski;\n}(Dog);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3e教是最好的学\x3c\/code\x3e，我正在尝试把我自己理解的内容分享出来，希望我能讲清楚，如果描述有误，欢迎指正。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e参考文献\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Introduction_to_Object-Oriented_JavaScript\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIntroduction to Object-Oriented JavaScript\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca\x3eClasses\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/stackoverflow.com\/questions\/9772307\/declaring-javascript-object-method-in-constructor-function-vs-in-prototype\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDeclaring javascript object method in constructor function vs. in prototype \x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Introduction_to_Object-Oriented_JavaScript\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eInheritance and the prototype chain\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>详解JS类概念的实现</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000004700001">https://segmentfault.com/a/1190000004700001</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/hvenahtvm4i/" target="_blank">https://alili.tech/archive/hvenahtvm4i/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>