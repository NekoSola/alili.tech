<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【译】React 组件的生命周期"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【译】React 组件的生命周期 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/qjpub8ochad/",
				"appid": "1613049289050283", 
				"title": "【译】React 组件的生命周期 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-04T02:30:58"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jleerniju3l/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6l2431x6arb/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fqjpub8ochad%2f&text=%e3%80%90%e8%af%91%e3%80%91React%20%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fqjpub8ochad%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fqjpub8ochad%2f&text=%e3%80%90%e8%af%91%e3%80%91React%20%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fqjpub8ochad%2f&title=%e3%80%90%e8%af%91%e3%80%91React%20%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fqjpub8ochad%2f&is_video=false&description=%e3%80%90%e8%af%91%e3%80%91React%20%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90%e8%af%91%e3%80%91React%20%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fqjpub8ochad%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fqjpub8ochad%2f&title=%e3%80%90%e8%af%91%e3%80%91React%20%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqjpub8ochad%2f&title=%e3%80%90%e8%af%91%e3%80%91React%20%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqjpub8ochad%2f&title=%e3%80%90%e8%af%91%e3%80%91React%20%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqjpub8ochad%2f&title=%e3%80%90%e8%af%91%e3%80%91React%20%e7%bb%84%e4%bb%b6%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【译】React 组件的生命周期</h1><div class="meta"><div class="postdate"><time datetime="2019-02-04" itemprop="datePublished">2019-02-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\n\x3cp\x3e\x3cstrong\x3e原文：\x3ca href=\x22https:\/\/medium.com\/react-ecosystem\/react-components-lifecycle-ce09239010df#.j7h6w8ccc\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/medium.com\/react-ecosystem\/react-components-lifecycle-ce09239010df#.j7h6w8ccc\x3c\/a\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e译者序：React组件生命周期有很多文章介绍了，这篇作者列出了很多开发中可能不会注意的细节，比如哪些阶段执行setState是否会导致render等，对React组件性能优化有一定的帮助，故译之，不当之处敬请指正！\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3egithub issue: \x3ca href=\x22https:\/\/github.com\/chemdemo\/chemdemo.github.io\/issues\/14\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/chemdemo\/c...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e一段探索React自建内部构造的旅程\x3c\/h2\x3e\n\x3cp\x3e在先前的文章里我们涵盖了\x3ca href=\x22https:\/\/medium.com\/react-ecosystem\/react-a-gentle-introduction-407fb59d3514#.su1qzoxp7\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact基本原理\x3c\/a\x3e和\x3ca href=\x22https:\/\/medium.com\/react-ecosystem\/components-the-war-horses-of-react-1085dddc14e5#.qnz8wjnq2\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e如何构建更加复杂的交互组件\x3c\/a\x3e。此篇文章我们将会继续探索React组件的特性，特别是生命周期。\x3c\/p\x3e\n\x3cp\x3e稍微思考一下React组件所做的事，首先想到的是一点是：React描述了如何去渲染（DOM）。我们已经知道React使用\x3ccode\x3erender()\x3c\/code\x3e方法来达到这个目的。然而仅有\x3ccode\x3erender()\x3c\/code\x3e方法可能不一定都能满足我们的需求。如果在组件rendered之前或之后我们需要做些额外的事情该怎么做呢？我们需要做些什么以避免重复渲染(re-render)呢？\x3c\/p\x3e\n\x3cp\x3e看起来我们需要对组件（运行）的各个阶段进行控制，组件运行所有涉及的各个阶段叫做\x3cstrong\x3e组件的生命周期\x3c\/strong\x3e，并且每一个React组件都会经历这些阶段。React提供了一些方法并在组件处于相应的阶段时通知我们。这些方法叫做React\x3cstrong\x3e组件的生命周期方法\x3c\/strong\x3e且会根据特定并可预测的顺序被调用。\x3c\/p\x3e\n\x3cp\x3e基本上所有的React组件的生命周期方法都可以被分割成四个阶段：\x3cstrong\x3e初始化\x3c\/strong\x3e、\x3cstrong\x3e挂载阶段（mounting）\x3c\/strong\x3e、\x3cstrong\x3e更新阶段\x3c\/strong\x3e、\x3cstrong\x3e卸载阶段（unmounting）\x3c\/strong\x3e。让我们来近距离分别研究下各个阶段。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e初始化阶段\x3c\/h2\x3e\n\x3cp\x3e初始化阶段就是我们分别通过\x3ccode\x3egetDefaultProps()\x3c\/code\x3e和\x3ccode\x3egetInitialState()\x3c\/code\x3e方法定义\x3ccode\x3ethis.props\x3c\/code\x3e默认值和\x3ccode\x3ethis.state\x3c\/code\x3e初始值的阶段。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3egetDefaultProps()\x3c\/code\x3e方法被\x3cstrong\x3e调用一次并缓存\x3c\/strong\x3e起来——在多个类实例之间共享。在组件的任何实例被创建之前，我们（的代码逻辑）不能依赖这里的\x3ccode\x3ethis.props\x3c\/code\x3e。这个方法返回一个对象并且属性如果没有通过父组件传入的话相应的属性会挂载到\x3ccode\x3ethis.props\x3c\/code\x3e对象上。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3egetInitialState()\x3c\/code\x3e方法也只会被调用一次，（调用时机）刚好是\x3cstrong\x3emounting阶段开始之前\x3c\/strong\x3e。返回值将会被当成\x3ccode\x3ethis.state\x3c\/code\x3e的初始值，且必须是一个对象。\x3c\/p\x3e\n\x3cp\x3e现在我们来证明上面的猜想，实现一个显示的值可以被增加和减少的组件，基本上就是一个拥有“\x2b”和“-”按钮的计数器。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Counter = React.createClass({\n    getDefaultProps: function() {\n        console.log(\x27getDefaultProps\x27);\n        return {\n            title: \x27Basic counter!!!\x27\n        }\n    },\n\n    getInitialState: function() {\n        console.log(\x27getInitialState\x27);\n        return {\n            count: 0\n        }\n    },\n\n    render: function() {\n        console.log(\x27render\x27);\n        return (\n            \x3cdiv\x3e\n                \x3ch1\x3e{this.props.title}\x3c\/h1\x3e\n                \x3cdiv\x3e{this.state.count}\x3c\/div\x3e\n                \x3cinput type=\x27button\x27 value=\x27\x2b\x27 onClick={this.handleIncrement} \/\x3e\n                \x3cinput type=\x27button\x27 value=\x27-\x27 onClick={this.handleDecrement} \/\x3e\n            \x3c\/div\x3e\n        );\n    },\n\n    handleIncrement: function() {\n        var newCount = this.state.count \x2b 1;\n        this.setState({count: newCount});\n    },\n\n    handleDecrement: function() {\n        var newCount = this.state.count - 1;\n        this.setState({count: newCount});\n    },\n\n    propTypes: {\n        title: React.PropTypes.string\n    }\n});\n\nReactDOM.render(\n    React.createElement(Counter),\n    document.getElementById(\x27app-container\x27)\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Counter = React.createClass({\n    \x3cspan class=\x22hljs-attr\x22\x3egetDefaultProps\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27getDefaultProps\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Basic counter!!!\x27\x3c\/span\x3e\n        }\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3egetInitialState\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27getInitialState\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        }\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27render\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x26lt;div\x26gt;\n                \x26lt;h1\x26gt;{this.props.title}\x26lt;\/h1\x26gt;\n                \x26lt;div\x26gt;{this.state.count}\x26lt;\/div\x26gt;\n                \x26lt;input type=\x27button\x27 value=\x27\x2b\x27 onClick={this.handleIncrement} \/\x26gt;\n                \x26lt;input type=\x27button\x27 value=\x27-\x27 onClick={this.handleDecrement} \/\x26gt;\n            \x26lt;\/div\x26gt;\n        );\n    },\n\n    handleIncrement: function() {\n        var newCount = this.state.count \x2b 1;\n        this.setState({count: newCount});\n    },\n\n    handleDecrement: function() {\n        var newCount = this.state.count - 1;\n        this.setState({count: newCount});\n    },\n\n    propTypes: {\n        title: React.PropTypes.string\n    }\n});\n\nReactDOM.render(\n    React.createElement(Counter),\n    document.getElementById(\x27app-container\x27)\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们通过\x3ccode\x3egetDefaultProps()\x3c\/code\x3e方法配置一个“title”属性，如果没有传入则提供一个默认值。然后通过\x3ccode\x3egetInitialState()\x3c\/code\x3e为组件设置一个初始state值“{count: 0}”。如果运行这段代码你将会看到控制台输出如下结果：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006807634?w=800\x26amp;h=272\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006807634?w=800\x26amp;h=272\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e现在我们想要让Counter组件可以设置\x3ccode\x3ethis.state.count\x3c\/code\x3e初始值和增加\/减少的步长值，但依然提供一个默认值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Component = React.createClass({\n    getDefaultProps: function() {\n        console.log(\x27getDefaultProps\x27);\n        return {\n            title: \x26quot;Basic counter!!!\x26quot;,\n            step: 1\n        }\n    },\n\n    getInitialState: function() {\n        console.log(\x27getInitialState\x27);\n        return {\n            count: (this.props.initialCount || 0)\n        };\n    },\n\n    render: function() {\n        console.log(\x27render\x27);\n        var step = this.props.step;\n\n        return (\n            \x3cdiv\x3e\n                \x3ch1\x3e{this.props.title}\x3c\/h1\x3e\n                \x3cdiv\x3e{this.state.count}\x3c\/div\x3e\n                \x3cinput type=\x27button\x27 value=\x27\x2b\x27 onClick={this.updateCounter.bind(this, step)} \/\x3e\n                \x3cinput type=\x27button\x27 value=\x27-\x27 onClick={this.updateCounter.bind(this, -step)} \/\x3e\n            \x3c\/div\x3e\n        );\n    },\n\n    updateCounter: function(value) {\n        var newCount = this.state.count \x2b value;\n        this.setState({count: newCount});\n    },\n\n    propTypes: {\n        title: React.PropTypes.string,\n        initialCount: React.PropTypes.number,\n        step: React.PropTypes.number\n    }\n});\n\nReactDOM.render(\n    React.createElement(Component, {initialCount: 5, step: 2}),\n    document.getElementById(\x27app-container\x27)\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Component = React.createClass({\n    \x3cspan class=\x22hljs-attr\x22\x3egetDefaultProps\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27getDefaultProps\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Basic counter!!!\x22\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3estep\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n        }\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3egetInitialState\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27getInitialState\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.initialCount || \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        };\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27render\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e step = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.step;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x26lt;div\x26gt;\n                \x26lt;h1\x26gt;{this.props.title}\x26lt;\/h1\x26gt;\n                \x26lt;div\x26gt;{this.state.count}\x26lt;\/div\x26gt;\n                \x26lt;input type=\x27button\x27 value=\x27\x2b\x27 onClick={this.updateCounter.bind(this, step)} \/\x26gt;\n                \x26lt;input type=\x27button\x27 value=\x27-\x27 onClick={this.updateCounter.bind(this, -step)} \/\x26gt;\n            \x26lt;\/div\x26gt;\n        );\n    },\n\n    updateCounter: function(value) {\n        var newCount = this.state.count \x2b value;\n        this.setState({count: newCount});\n    },\n\n    propTypes: {\n        title: React.PropTypes.string,\n        initialCount: React.PropTypes.number,\n        step: React.PropTypes.number\n    }\n});\n\nReactDOM.render(\n    React.createElement(Component, {initialCount: 5, step: 2}),\n    document.getElementById(\x27app-container\x27)\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e这里通过\x3ca href=\x22https:\/\/developer.mozilla.org\/es\/docs\/Web\/JavaScript\/Referencia\/Objetos_globales\/Function\/bind\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFunction.prototype.bind\x3c\/a\x3e使用\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Partial_application\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e偏函数应用(Partial Application)\x3c\/a\x3e来达到复用代码的目的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e现在我们拥有了一个可定制化的组件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e增长（Mounting）阶段\x3c\/h2\x3e\n\x3cp\x3eMounting阶段发生在组件即将被插入到DOM之前。这个阶段有两个方法可以用：\x3ccode\x3ecomponentWillMount()\x3c\/code\x3e和\x3ccode\x3ecomponentDidMount()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ecomponentWillMount()\x3c\/code\x3e方法是这个阶段最先调用的，它只在\x3cstrong\x3e刚好初始渲染（initial rendering）发生之前\x3c\/strong\x3e被调用\x3cstrong\x3e一次\x3c\/strong\x3e，也就是React在DOM插入组件之前。需要注意的是在此处\x3cstrong\x3e调用\x3ccode\x3ethis.setState()\x3c\/code\x3e方法将不会触发重复渲染（re-render）\x3c\/strong\x3e。如果添加下面的代码到计数器组件我们将会看到此方法在\x3ccode\x3egetInitialState()\x3c\/code\x3e之后且\x3ccode\x3erender()\x3c\/code\x3e之前被调用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22getInitialState: function() {...},\ncomponentWillMount: function() {\n    console.log(\x27componentWillMount\x27);\n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3egetInitialState: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{...},\n\x3cspan class=\x22hljs-attr\x22\x3ecomponentWillMount\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27componentWillMount\x27\x3c\/span\x3e);\n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ecomponentDidMount()\x3c\/code\x3e是这个阶段第二个被调用的方法，刚好发生在\x3cstrong\x3eReact插入组件到DOM之后\x3c\/strong\x3e，且也只被调用\x3cstrong\x3e一次\x3c\/strong\x3e。现在可以更新DOM元素了，这意味着这个方法是初始化其他需要访问DOM或操作数据的第三方库的最佳时机。\x3c\/p\x3e\n\x3cp\x3e假设我们想要通过API拉取数据来初始化组件。我们应该直接在计数器组件的\x3ccode\x3ecomponentDidMount()\x3c\/code\x3e方法拉取数据，但是这让组件看起来有太多逻辑了，更可取的方案是使用\x3ca href=\x22https:\/\/medium.com\/@dan_abramov\/smart-and-dumb-components-7ca2f9a7c7d0#.pqy4fd1c5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e容器组件\x3c\/a\x3e来做：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Container = React.createClass({\n    getInitialState: function() {\n        return {\n            data: null,\n            fetching: false,\n            error: null\n        };\n    },\n\n    render: function() {\n        if (this.props.fetching) {\n            return \x3cdiv\x3eLoading...\x3c\/div\x3e;\n        }\n\n        if (this.props.error) {\n            return (\n                \x3cdiv className=\x27error\x27\x3e\n                    {this.state.error.message}\n                \x3c\/div\x3e\n            );\n        }\n\n        return \x3cCounter {...data} \/\x3e\n    },\n\n    componentDidMount: function() {\n        this.setState({fetching: true});\n\n        Axios.get(this.props.url).then(function(res) {\n            this.setState({data: res.data, fetching: false});\n        }).catch(function(res) {\n            this.setState({error: res.data, fetching: false});\n        });\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Container = React.createClass({\n    \x3cspan class=\x22hljs-attr\x22\x3egetInitialState\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3efetching\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3eerror\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        };\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.fetching) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eLoading...\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.error) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n                \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                    {this.state.error.message}\n                \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n            );\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCounter\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3e...data\x3c\/span\x3e} \/\x26gt;\x3c\/span\x3e\n    },\n\n    componentDidMount: function() {\n        this.setState({fetching: true});\n\n        Axios.get(this.props.url).then(function(res) {\n            this.setState({data: res.data, fetching: false});\n        }).catch(function(res) {\n            this.setState({error: res.data, fetching: false});\n        });\n    }\n});\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/mzabriskie\/axios\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAxios\x3c\/a\x3e是一个基于priomise的跨浏览器和Node.js的HTTP客户端。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e　更新阶段\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e当组件的属性或者状态更新时\x3c\/strong\x3e也需要一些方法来供我们执行代码，这些方法也是组件更新阶段的一部分且按照以下的顺序被调用：\x3c\/p\x3e\n\x3cp\x3e1、当从父组件接收到新的属性时：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006807652?w=505\x26amp;h=533\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006807652?w=505\x26amp;h=533\x22 alt=\x22props updated\x22 title=\x22props updated\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e2、当通过\x3ccode\x3ethis.setState()\x3c\/code\x3e改变状态时：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006807653?w=515\x26amp;h=477\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006807653?w=515\x26amp;h=477\x22 alt=\x22state updated\x22 title=\x22state updated\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e此阶段React组件已经被插入DOM了，因此这些方法将不会在首次render时被调用。\x3c\/p\x3e\n\x3cp\x3e最先被调用的方法是\x3ccode\x3ecomponentWillReceiveProps()\x3c\/code\x3e，当组件接收到新属性时被调用。我们可以利用此方法为React组件提供一个在render之前修改state的机会。\x3cstrong\x3e在此方法内调用\x3ccode\x3ethis.setState()\x3c\/code\x3e将不会导致重复render\x3c\/strong\x3e，然后可以通过\x3ccode\x3ethis.props\x3c\/code\x3e访问旧的属性。例如计数器组件，如果我们想要在任何时候父组件传入“initialCount”时更新状态，可以这样做：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22...\ncomponentWillReceiveProps: function(newProps) {\n    this.setState({count: newProps.initialCount});\n},\n...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e...\ncomponentWillReceiveProps: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enewProps\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: newProps.initialCount});\n},\n...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eshouldComponentUpdate()\x3c\/code\x3e方法允许我们自行决定下一个state更新时是否触发重复render。此方法返回一个布尔值，且默认是true。但是我们也可以返回false，这样下面的（生命周期）方法将不会被调用：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ecomponentWillUpdate()\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3erender()\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecomponentDidUpdate()\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e当有性能瓶颈时也可以使用\x3ccode\x3eshouldComponentUpdate()\x3c\/code\x3e方法（来优化）。尤其是数百个组件一起时重新render的代价将会十分昂贵。为了证明这个猜想我们来看一个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var TextComponent = React.createClass({\n    shouldComponentUpdate: function(nextProps, nextState) {\n        if (this.props.text === nextProps.text) return false;\n        return true;\n    },\n\n    render: function() {\n        return \x3ctextarea value={this.props.text} \/\x3e;\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e TextComponent = React.createClass({\n    \x3cspan class=\x22hljs-attr\x22\x3eshouldComponentUpdate\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextProps, nextState\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.text === nextProps.text) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3etextarea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.text}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e;\n    }\n});\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此例中无论何时父组件传入一个“text”属性到\x3ccode\x3eTextComponent\x3c\/code\x3e并且text属性等于当前的“text”属性时，组件将会不会重复render。\x3c\/p\x3e\n\x3cp\x3e当接收到新的属性或者state时在render之前会立刻调用\x3ccode\x3ecomponentWillUpdate()\x3c\/code\x3e方法。可以利用此时机来为更新做一些准备工作，虽然这个阶段不能调用\x3ccode\x3ethis.setState()\x3c\/code\x3e方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22...\ncomponentWillUpdate: function(nextProps, nextState) {\n    console.log(\x27componentWillUpdate\x27, nextProps, nextState);\n},\n...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e...\ncomponentWillUpdate: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextProps, nextState\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27componentWillUpdate\x27\x3c\/span\x3e, nextProps, nextState);\n},\n...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ecomponentDidUpdate()\x3c\/code\x3e方法在React更新DOM之后立刻被调用。可以在此方法里操作被更新过的DOM或者执行一些后置动作（action）。此方法有两个参数：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eprevProps：旧的属性\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eprevState：旧的state\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这个方法的一个常见使用场景是当我们使用需要操作更新后的DOM才能工作的第三方库——如jQuery插件的时候。在\x3ccode\x3ecomponentDidMount()\x3c\/code\x3e方法内初始化第三方库，但是在属性或state更新触发DOM更新之后也需要同步更新第三方库来保持接口一致，这些必须在\x3ccode\x3ecomponentDidUpdate()\x3c\/code\x3e方法内来完成。为了验证这一点，让我们看看如何开发一个\x3ca href=\x22https:\/\/select2.github.io\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSelect2库\x3c\/a\x3e包裹（wrapper）React组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Select2 = React.createClass({\n    componentDidMount: function() {\n        $(this._ref).select2({data: this.props.items});\n    },\n\n    render: function() {\n        return (\n            \x3cselect\n                ref={\n                    function(input) {\n                        this._ref = input;\n                    }.bind(this)\n                }\x3e\n            \x3c\/select\x3e\n        );\n    },\n\n    componentDidUpdate: function() {\n        $(this._ref).select2(\x27destroy\x27);\n        $(this._ref).select2({data: this.props.items});\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Select2 = React.createClass({\n    \x3cspan class=\x22hljs-attr\x22\x3ecomponentDidMount\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._ref).select2({\x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.items});\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eselect\x3c\/span\x3e\n                \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-attr\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-attr\x22\x3einput\x3c\/span\x3e) {\n                        \x3cspan class=\x22hljs-attr\x22\x3ethis._ref\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3einput;\x3c\/span\x3e\n                    }\x3cspan class=\x22hljs-attr\x22\x3e.bind\x3c\/span\x3e(\x3cspan class=\x22hljs-attr\x22\x3ethis\x3c\/span\x3e)\n                }\x26gt;\x3c\/span\x3e\n            \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eselect\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n        );\n    },\n\n    \x3cspan class=\x22hljs-attr\x22\x3ecomponentDidUpdate\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._ref).select2(\x3cspan class=\x22hljs-string\x22\x3e\x27destroy\x27\x3c\/span\x3e);\n        $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._ref).select2({\x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.items});\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e卸载阶段（unmounting）\x3c\/h2\x3e\n\x3cp\x3e此阶段React只提供了一个方法：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3ecomponentWillUnmount()\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e它将在组件从DOM卸载之前被调用。可以在内部执行任何可能需要的清理工作，如无效的计数器或者清理一些在\x3ccode\x3ecomponentDidMount()\x3c\/code\x3e\/\x3ccode\x3ecomponentDidUpdate()\x3c\/code\x3e内创建的DOM。比如在Select2组件里边我们可以这样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22...\ncomponetWillUnmount: function(){\n   $(this._ref).select2(\x27destroy\x27);\n},\n...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e...\ncomponetWillUnmount: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n   $(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._ref).select2(\x3cspan class=\x22hljs-string\x22\x3e\x27destroy\x27\x3c\/span\x3e);\n},\n...\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e概述\x3c\/h2\x3e\n\x3cp\x3eReact为我们提供了一种在创建组件时申明一些将会在组件生命周期的特定时机被自动调用的方法的可能。现在我们很清晰的理解了每一个组件生命周期方法所扮演的角色以及他们被调用的顺序。这使我们有机会在组件创建和销毁时执行一些操作。也允许我们在当属性和状态变化时做出相应的反应从而更容易的整合第三方库和追踪性能问题。\x3c\/p\x3e\n\x3cp\x3e希望您觉得此文对您有用，如果是这样，请推荐之！！！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【译】React 组件的生命周期</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006807631">https://segmentfault.com/a/1190000006807631</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/qjpub8ochad/" target="_blank">https://alili.tech/archive/qjpub8ochad/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>