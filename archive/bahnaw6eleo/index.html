<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="是时候理清 React 开发中的一些疑惑了"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>是时候理清 React 开发中的一些疑惑了 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bahnaw6eleo/",
				"appid": "1613049289050283", 
				"title": "是时候理清 React 开发中的一些疑惑了 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/6kr9godb83y/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/35n18cfldis/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbahnaw6eleo%2f&text=%e6%98%af%e6%97%b6%e5%80%99%e7%90%86%e6%b8%85%20React%20%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e4%ba%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbahnaw6eleo%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbahnaw6eleo%2f&text=%e6%98%af%e6%97%b6%e5%80%99%e7%90%86%e6%b8%85%20React%20%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e4%ba%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbahnaw6eleo%2f&title=%e6%98%af%e6%97%b6%e5%80%99%e7%90%86%e6%b8%85%20React%20%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e4%ba%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbahnaw6eleo%2f&is_video=false&description=%e6%98%af%e6%97%b6%e5%80%99%e7%90%86%e6%b8%85%20React%20%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e4%ba%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%98%af%e6%97%b6%e5%80%99%e7%90%86%e6%b8%85%20React%20%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e4%ba%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbahnaw6eleo%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbahnaw6eleo%2f&title=%e6%98%af%e6%97%b6%e5%80%99%e7%90%86%e6%b8%85%20React%20%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e4%ba%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbahnaw6eleo%2f&title=%e6%98%af%e6%97%b6%e5%80%99%e7%90%86%e6%b8%85%20React%20%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e4%ba%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbahnaw6eleo%2f&title=%e6%98%af%e6%97%b6%e5%80%99%e7%90%86%e6%b8%85%20React%20%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e4%ba%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbahnaw6eleo%2f&title=%e6%98%af%e6%97%b6%e5%80%99%e7%90%86%e6%b8%85%20React%20%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e7%96%91%e6%83%91%e4%ba%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">是时候理清 React 开发中的一些疑惑了</h1><div class="meta"><div class="postdate"><time datetime="2019-02-05" itemprop="datePublished">2019-02-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3eReact其实很好上手，我在最初使用时并未去了解其一些细节性的东西，但是好像在项目中也一直能正常运作。但是那时总会有一种不安感，深感自己对React的使用逻辑并未理解得非常清晰，本文的目的就在于理清这种使用逻辑，当然个人见解定有偏颇，如果你有一些建议，也希望您能在讨论区予以指教，如果你到现在还没有怎么接触过React，推荐可以跟着\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/tutorial.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方文档的例子\x3c\/a\x3e体会下React再来看本文，也许这样收获更大一些，后文的链接里还有一个更加高级的例子也是非常好的入门教程。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e为什么要使用 React\x3c\/h2\x3e\n\x3cp\x3e这是一个老生常谈的问题了，可能大家在众多的教程、文章里已经了解过了React的好处，比如说它的虚拟DOM可以被高效的渲染，比如说它的组件化使得项目结构非常清晰，代码复用非常容易，比如说它的数据管理机制也能让你清晰的知晓数据的状态，而React本身就是被这种清晰的数据所驱动的。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x22We built React to solve one problem: building large applications with data that changes over time.\x22\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e详细谈论这些优点前，我想说说React给我带来的改变。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在使用React之前，我也一直在使用jQuery，它对节点的操作非常方便，如果仅仅只是普通网页的开发，jQuery无疑是非常好的，但是如果开发的是WebApp，jQuery并不能增强你对全局的把控能力，在学习使用React没多久以后突然有一天我感觉以前所做的开发都好像在玩一些小打小闹的游戏，而使用React也让自己明白了为什么我被称作前端工程师，这个框架让我找到了工程师的归属感，当我再看自己的项目时和一个建筑工程师看自己的设计图的感觉没了太多差别，我知道我的这个组件是房子的总体框架，这个组件是大厅，这个组件是椅子，还有与大厅同级的卧室组件，厨房组件，与椅子同级的桌子组件，家电组件。\x3c\/p\x3e\n\x3cp\x3e我可以用优雅的桌子，椅子，床，台灯来布置一个温馨的卧室；\x3cbr\x3e我可以把桌子压扁拉长变成电视柜，把椅子拉宽加上软软的海绵变成沙发，再把台灯提高，换一个像样的遮光罩它就是落地灯了，再加上一些客厅独有的家电，客厅的感觉也就出来了；\x3cbr\x3e用相同的思路，一个温馨的家就出来了。\x3c\/p\x3e\n\x3cp\x3e其实想想，如果只考虑客厅和卧室（不考虑里面的那些桌子椅子之类的组件）那么除却它们的长、宽、摆放位置这些参数不同，它们又有什么区别呢？\x3c\/p\x3e\n\x3cp\x3e回到React，它即带给我们对整体的把控能力，也让我们可以通过修改数据（参数）以表现不同的细节达到不同的效果，从最大的房子的框架到每个桌子椅子的样子，一切都在我们的掌握。下面就慢慢说说React是如何帮我们达到把握全局，了解细节的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e从虚拟 DOM（Virtual DOM）说起\x3c\/h2\x3e\n\x3cp\x3e想象这么一个场景，客厅里有一把我们不是很喜欢的椅子，想换一把，最合适的做法当然就是改造一下，或者把这把丢了重新买一把新的，为了换一把椅子而重新组装整个房子一看就是不聪明的做法。Virtual DOM为我们提供了一种高效的渲染机制，使得我们可以只改变我们想改变的地方，而尽量不去影响其它无关的组件。它是React高性能的基础。\x3c\/p\x3e\n\x3ch4\x3e虚拟 DOM 究竟是什么？\x3c\/h4\x3e\n\x3cp\x3e要说明Virtual DOM究竟是什么，不得不提到React DOM模块的一个方法，\x3ccode\x3eReactDOM.reader()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e这个方法就像打开一道门的钥匙，门的两边就是Virtual DOM和Html DOM，我们在浏览器中看到的肯定是Html DOM，Virtual DOM存在于隔着这道门的系统内存之中，Html DOM和Virtual DOM之间存在着映射关系。\x3cbr\x3e就像Html DOM由各种节点构成，Virtual DOM也是由一种被称为\x3ccode\x3eReact node\x3c\/code\x3e的节点构成。\x3c\/p\x3e\n\x3cp\x3e每个React组件中还有另外一个\x3ccode\x3erender()\x3c\/code\x3e方法（不同于\x3ccode\x3eReactDOM.reader()\x3c\/code\x3e），我的理解是这个方法用于将\x3ccode\x3eReactNode\x3c\/code\x3e构建为Virtual DOM。下面再来详细看看\x3ccode\x3eReact node\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch4\x3eReact node\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e“a light, stateless, immutable, virtual representation of a DOM node.”\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3eReact node其实并非真实的节点，实际上它们可以看做是真实节点在Virtual DOM中的代表，Virtual DOM就是由ReactNodes构成，真实的DOM就是依据它们所构建；\x3c\/p\x3e\n\x3cp\x3e在需要改变真实的DOM时，React其实是先修改虚拟DOM，然后和真实的DOM做比较，在真实DOM中只改变需要改变的地方，这种补丁机制只改变局部，不改变整体，因此对系统性能的消耗较小，对虚拟DOM的修改会在状态改变时触发，后文会详细说明这种状态机制。可能大家也已经听说了二者之间的比较是基于diff算法，知乎上有一篇详细解析React的这个算法的\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/20346379?refer=purerender\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e文章\x3c\/a\x3e，推荐大家阅读。\x3c\/p\x3e\n\x3cp\x3e一般来说创建React node有两种方法，如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 方法1，使用React 内置的工厂方法创建\nvar reactNodeLi = React.DOM.li({id:\x27li1\x27}, \x27one\x27);\n\n\/\/方法2，使用JavaScript创建node的方法\nvar reactNodeLi = React.createElement(\x27li\x27, null, \x27one\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 方法1，使用React 内置的工厂方法创建\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reactNodeLi = React.DOM.li({\x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27li1\x27\x3c\/span\x3e}, \x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/方法2，使用JavaScript创建node的方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reactNodeLi = React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27li\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最近有一本开源的电子书\x3ca href=\x22https:\/\/www.gitbook.com\/book\/frontendmasters\/react-enlightenment\/details\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Enlightenment\x3c\/a\x3e里有一章对React node有详细的介绍，也推荐大家阅读。\x3c\/p\x3e\n\x3cp\x3eReact提供的另外一种简洁，直观的创建React node的方法，那就是JSX，其实提到React，大家好像都会想到JSX，因为它实在是太方便了，其实使用React其实并非必须使用JSX，不过使用它真的能让我们的工作更加轻松。\x3c\/p\x3e\n\x3ch4\x3eJSX\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var App = React.createClass({\n  render: function() {\n    return \x3cp\x3eMy name is { this.props.name }\x3c\/p\x3e;\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e App = React.createClass({\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eMy name is { this.props.name }\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面例子里return中的那一部分就是JSX了，初看JSX的语法，可能大家会想到前端开发中经常使用到的模板，不过JSX并非模板，它应该算是React对JS语法的拓展，需要编译后才能正确使用它，JSX的构建是非常简洁明了的，在此就不再赘述。\x3c\/p\x3e\n\x3ch4\x3e再说 Babel\x3c\/h4\x3e\n\x3cp\x3e刚刚已经提及JSX是需要编译才能被浏览器识别的，它就是被Babel编译的，具体说来是被babel-preset-react来编译的。不过Babel的最主要目的其实并非编译JSX，Babel应该算是一个编译平台，其主要目的是转换你在代码中使用了的ES6甚至ES7语法为浏览器识别的ES5语法（babel-core,babel-preset-es2015模块），编译React倒像是其的附加功能。初学者有时候会觉得使用React困难，配置合适的开发环境可是就是原因之一。以前翻译过一篇基础的配置webpack的文章，具体可以\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006178770?_ea=1088498\x22\x3e点这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e说到组件了（Component）\x3c\/h2\x3e\n\x3cp\x3e除却高性能，组件是另外一个React非常吸引人的地方，组件的可复用性,可组合性以及其对模块化开发的天然适应性，使得我们的项目非常直观，便于理解和管理。拿到一个项目，最开始要想的就是如何来划分组件。当然划分肯定需要一些依据，先来看看React自己对组件的分类。\x3c\/p\x3e\n\x3ch4\x3e划分并创建组件\x3c\/h4\x3e\n\x3cp\x3e我在最初使用React时，我的项目里的所有的组件都是通过\x3ccode\x3eReact.createClass()\x3c\/code\x3e创建，所有的组件在里面可能都拥有\x3ccode\x3egetInitialState(),componentDidMount()\x3c\/code\x3e等方法，当然这样用其实一点也没有问题。但是这样写，除非对项目非常熟悉，否则我们并不能很容易的就区分组件之间的层级关系。而且随着项目的复杂化，也不利于数据的管理。\x3c\/p\x3e\n\x3ch5\x3eStateful Component\x3c\/h5\x3e\n\x3cp\x3e之前在\x3ca href=\x22http:\/\/wangfupeng.coding.me\/share\/2016\/08\/06\/restruct-bdnews-webapp-by-react.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e使用React重构百度新闻webapp前端\x3c\/a\x3e看到智能组件和木偶组件二词，我觉得它们可能可以分别对应到\x3ccode\x3eStateful Component\x3c\/code\x3e和\x3ccode\x3eStateless Component\x3c\/code\x3e,在此引用一下该文里的说法。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e智能组件\x3c\/strong\x3e 它是数据的所有者，它拥有数据、且拥有操作数据的action，但是它不实现任何具体功能。它会将数据和操作action传递给子组件，让子组件来完成UI或者功能。这就是智能组件，也就是项目中的各个页面。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这是一个完整的组件，在这种组件里可能会出现所有的React提供的方法（包括各种生命周期函数\x3ccode\x3elife cycle methods\x3c\/code\x3e,各种事件响应函数等等）\x3c\/p\x3e\n\x3cp\x3e创建：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ES5 写法\nvar App = React.createClass({\ngetInitialState(){\n    return{\n    name:\x26quot;Tom\x26quot;,\n    ...\n    }\n},\n\ncomponentDidMount(){\n    this.setState({\n        name:\x26quot;Jim\x26quot;\n    })\n},\n\n  render: function() {\n    return \x3cp\x3eMy name is { this.state.name }\x3c\/p\x3e;\n  }\n});\n\n\/\/ ES6 写法\nclass SearchBar extends React.Component {\n      constructor(props) {\/\/props需要作为参数传入\n            super(props);\/\/需要使用super，如果没有this就会是undefined\n            this.state = {\n              searchTerm: \x27\x27,\n            };\n            this.handleInputChange = this.handleInputChange.bind(this);\/\/为事件绑定this，这是ES6语法所要求的，ES5并没相关要求\n      }\n\n      handleInputChange(event) {\n        this.setState({\n              searchTerm: event.target.value,\n        });\n      }\n\n      render() {\n            return \x3cinput onChange={this.handleInputChange} \/\x3e;\n      }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ES5 写法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e App = React.createClass({\ngetInitialState(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22Tom\x22\x3c\/span\x3e,\n    ...\n    }\n},\n\ncomponentDidMount(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n        \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22Jim\x22\x3c\/span\x3e\n    })\n},\n\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eMy name is { this.state.name }\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ES6 写法\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSearchBar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\x3cspan class=\x22hljs-comment\x22\x3e\/\/props需要作为参数传入\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\x3cspan class=\x22hljs-comment\x22\x3e\/\/需要使用super，如果没有this就会是undefined\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n              \x3cspan class=\x22hljs-attr\x22\x3esearchTerm\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e,\n            };\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleInputChange = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleInputChange.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/为事件绑定this，这是ES6语法所要求的，ES5并没相关要求\x3c\/span\x3e\n      }\n\n      handleInputChange(event) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n              \x3cspan class=\x22hljs-attr\x22\x3esearchTerm\x3c\/span\x3e: event.target.value,\n        });\n      }\n\n      render() {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonChange\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleInputChange}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e;\n      }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e两种写法其实没有本质区别，ES6语法也会通过Babel转换为ES5语法后被执行，但是两种写法里确实存在一些不一样的地方，比如说使用ES6时需要单独绑定\x3ccode\x3ethis\x3c\/code\x3e，ES6语法里方法之间不能使用逗号\x3ccode\x3e,\x3c\/code\x3e等等。网上可以查到很多相关资料，在此不做赘述。\x3c\/p\x3e\n\x3ch5\x3eStateless Component\x3c\/h5\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e木偶组件\x3c\/strong\x3e：它就是一个工具，不拥有任何数据、及操作数据的action，给它什么数据它就显示什么数据，给它什么方法，它就调用什么方法，比较傻。这就是木偶组件，即项目中的各个组件。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这种组件里只会出现，React提供的\x3ccode\x3erender()\x3c\/code\x3e方法,用于构建虚拟DOM，其创建方式除了ES5，ES6的写法，还可以使用\x3ccode\x3eStateless Functions\x3c\/code\x3e方法创建。\x3c\/p\x3e\n\x3cp\x3e创建：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ES5\nvar HelloMessage = React.createClass({\n    render(){\n        return \x3cdiv\x3eHello {props.name}\x3c\/div\x3e \/\/多个节点时需要加括号\n    }\n})\n\n\/\/ES6\nclass HelloMessage extends React.Component {\n        constructor(props) {\/\/props需要作为参数传入\n            super(props);\/\/需要使用super，如果没有this就会是undefined\n            }\n            \n            render() {\n            return \x3cdiv\x3eHello {props.name}\x3c\/div\x3e;\n      }\n}\n\n\/\/Stateless Functions\nfunction HelloMessage(props) {\n  return \x3cdiv\x3eHello {props.name}\x3c\/div\x3e;\n}\n\n\/\/ES6 Stateless Functions\nconst HelloMessage = (props) =\x3e \x3cdiv\x3eHello {props.name}\x3c\/div\x3e;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ES5\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e HelloMessage = React.createClass({\n    render(){\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello {props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/多个节点时需要加括号\x3c\/span\x3e\n    }\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ES6\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHelloMessage\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\x3cspan class=\x22hljs-comment\x22\x3e\/\/props需要作为参数传入\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\x3cspan class=\x22hljs-comment\x22\x3e\/\/需要使用super，如果没有this就会是undefined\x3c\/span\x3e\n            }\n            \n            render() {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello {props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n      }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/Stateless Functions\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHelloMessage\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello {props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ES6 Stateless Functions\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HelloMessage = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x26lt;div\x26gt;Hello {props.name}\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/div\x26gt;;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e模块和组件\x3c\/h4\x3e\n\x3cp\x3e如若需要，所有的React组件都是可以当做模块被导出的，不过就就我本人看来，一般所导出的模块都是由一个或者若干个组件组成的功能单元。不过说到这里更想说明的一点时，React其实是很依赖类似于webpack这样的模块管理工具的，所以想要用好React，其实也需要对模块的定义，以及模块管理工具有一点的了解。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e有生命的组件\x3c\/h2\x3e\n\x3cp\x3eReact里的组件是活的，组件不仅仅有类似于出生，成长，死亡的过程，还有心脏和血液。\x3c\/p\x3e\n\x3ch4\x3e生命周期函数 life cycle methods\x3c\/h4\x3e\n\x3cp\x3e组件的生命周期函数可以分为三个阶段：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3eMounting Phase（此阶段的函数在一个组件的生命中只会执行一次）（挂载阶段）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- getInitialState()\n- componentWillMount()\n- componentDidMount()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haml\x22\x3e\x3ccode\x3e-\x3cspan class=\x22ruby\x22\x3e getInitialState()\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e componentWillMount()\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e componentDidMount()\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eUpdating Phase（此阶段的函数在一个组件的生命中可别多次执行）（更新阶段）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- componentWillReceiveProps()\n- shouldComponentUpdate()\n- componentWillUpdate()\n- componentDidUpdate()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haml\x22\x3e\x3ccode\x3e-\x3cspan class=\x22ruby\x22\x3e componentWillReceiveProps()\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e shouldComponentUpdate()\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e componentWillUpdate()\n\x3c\/span\x3e-\x3cspan class=\x22ruby\x22\x3e componentDidUpdate()\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eUnmount Phase （此阶段的函数在一个组件的生命中只会执行一次）（卸载阶段）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- componentWillUnmount()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs asciidoc\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-bullet\x22\x3e- \x3c\/span\x3ecomponentWillUnmount()\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e关于各个函数的具体意义，在此不在赘述，一个比较容易出错的地方是弄明白各个函数的执行顺序，下面给出一个参考列表。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- Mounting Phase：\n    1. Initialize \/ Construction\n    2. getDefaultProps() (React.createClass) or MyComponent.defaultProps (ES6 class)\n    3. getInitialState() (React.createClass) or this.state = ... (ES6 constructor)\n    4. componentWillMount()\n    5. render()\n    6. Children initialization \x26amp; life cycle kickoff\n    7. componentDidMount()\n\n- Updating Phase follows this order:\n    1. componentWillReceiveProps()\n    2. shouldComponentUpdate()\n    3. render()\n    4. Children Life cycle methods\n    5. componentWillUpdate()\n\n- Unmount Phase follows this order:\n    1. componentWillUnmount()\n    2. Children Life cycle methods\n    3. Instance destroyed for Garbage Collection\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs oxygene\x22\x3e\x3ccode\x3e- Mounting Phase：\n    \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e. Initialize \/ Construction\n    \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e. getDefaultProps() (React.createClass) \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e MyComponent.defaultProps (ES6 \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e. getInitialState() (React.createClass) \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e this.state = ... (ES6 \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e)\n    4. \x3cspan class=\x22hljs-title\x22\x3ecomponentWillMount\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\n    5. \x3cspan class=\x22hljs-title\x22\x3erender\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\n    6. \x3cspan class=\x22hljs-title\x22\x3eChildren\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitialization\x3c\/span\x3e \x26amp; \x3cspan class=\x22hljs-title\x22\x3elife\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecycle\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ekickoff\x3c\/span\x3e\n    7. \x3cspan class=\x22hljs-title\x22\x3ecomponentDidMount\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\n\n- \x3cspan class=\x22hljs-title\x22\x3eUpdating\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePhase\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efollows\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eorder\x3c\/span\x3e:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e. componentWillReceiveProps()\n    \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e. shouldComponentUpdate()\n    \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e. render()\n    \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e. Children Life cycle methods\n    \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e. componentWillUpdate()\n\n- Unmount Phase follows this \x3cspan class=\x22hljs-keyword\x22\x3eorder\x3c\/span\x3e:\n    \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e. componentWillUnmount()\n    \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e. Children Life cycle methods\n    \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e. Instance destroyed \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e Garbage Collection\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e组件的生命之源-state\x3c\/h4\x3e\n\x3cp\x3e用过React的人都知道，\x3ccode\x3ethis.setState({})\x3c\/code\x3e可能算是React里使用最多的方法了，每次使用都会根据所更新的数据重构Virtual DOM已达到更新组件的目的，使得组件充满活力，满足我们的各种要求。\x3c\/p\x3e\n\x3cp\x3estate在getInitialState()阶段被初始化，之后通过其它生命周期函数（\x3ccode\x3ecomponentWillUpdate()\x3c\/code\x3e里不能使用）或React事件调用的函数，可以使用利用\x3ccode\x3ethis.setState({})\x3c\/code\x3e更新某一state的值。\x3c\/p\x3e\n\x3cp\x3e我在最初使用React时总觉得，使用了过多的\x3ccode\x3ethis.setState({})\x3c\/code\x3e会不会导致React变得性能低下，不过阅读了\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/20328570?refer=purerender\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这篇文章\x3c\/a\x3e打消了我的一些疑惑。\x3c\/p\x3e\n\x3ch4\x3e组件的血液-props\x3c\/h4\x3e\n\x3cp\x3e为什么把\x3ccode\x3eprops\x3c\/code\x3e比作血液呢，因为它本身自己并不会变化，它就像是一个传输的中介，把父组件的方法，属性传递给子组件。一般在子组件中它可能有三方面的作用\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e作为子组件的属性\x3ccode\x3e\x26lt;div className=\x22this.props.className\x22\x26gt;作为属性\x26lt;\/div\x26gt;\x3c\/code\x3e；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e作为参数\x3ccode\x3e\x26lt;div\x26gt;{\x22我的名字是\x22\x2bthis.props.name}\x26lt;\/div\x26gt;\x3c\/code\x3e;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e传递方法\x3ccode\x3e\x26lt;div onClick=\x22this.props.click\x22\x26gt;传递方法\x26lt;\/div\x26gt;\x3c\/code\x3e;\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e配合\x3ccode\x3estate\x3c\/code\x3e，props可以用来改变子组件的表现形式，如果用来传递方法，\x3ccode\x3eprops\x3c\/code\x3e可以在子组件中调用父组件的方法。\x3c\/p\x3e\n\x3cp\x3e在开发时，props还可以配合\x3ccode\x3epropTypes\x3c\/code\x3e使用，这样可以使得props的使用更加准确（如下例），也使得组件更加健壮。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const AlbumList = (props) =\x3e {\n  const albums = props.albums.map((album) =\x3e \x3cli\x3e{album.name}\x3c\/li\x3e);\n \n  return (\n    \x3cul\x3e\n      {albums}\n    \x3c\/ul\x3e\n  );\n};\n \nAlbumList.propTypes = {\n  albums: React.PropTypes.array.isRequired,\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e AlbumList = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e albums = props.albums.map(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ealbum\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x26lt;li\x26gt;{album.name}\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/li\x26gt;);\n \n  return (\n    \x26lt;ul\x26gt;\n      {albums}\n    \x26lt;\/u\x3c\/span\x3el\x26gt;\n  );\n};\n \nAlbumList.propTypes = {\n  \x3cspan class=\x22hljs-attr\x22\x3ealbums\x3c\/span\x3e: React.PropTypes.array.isRequired,\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e一点小结\x3c\/h2\x3e\n\x3cp\x3e本文只总结了我对React的最基础的部分的一些思考，类似于高阶组件，Redux这类的目前我并未接触过多的知识和以及一些类似于React中的事件这类的较容易理解的知识没做过多的叙述，至于Routing这类构建app的知识，以后有机会一定会再和大家分享。\x3c\/p\x3e\n\x3cp\x3e对于刚刚接触React的童鞋，可能看完依旧是云里雾里，不过本文实在算不上教程，初学者可能还是得看比较靠谱的教程。\x3c\/p\x3e\n\x3cp\x3e之前看过一个一个比较好的React学习路径推荐在此也分享给大家，希望对大家的React学习有帮助\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e学习React的基本知识；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e熟悉npm\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e熟悉JavaScript的打包工具\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e了解ES6\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e学习Routing和flux（redux）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e最后还要做一个小广告，或者其实也算是对自己的一个激励和监督，之前和 \x3ca href=\x22https:\/\/www.gitbook.com\/book\/frontendmasters\/react-enlightenment\/details\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Enlightenment\x3c\/a\x3e这本开源书的作者联系，他也非常愿意自己的书能让更多人有收获，所以就同意我把这本书翻译为汉语了。这本书目前一共八章，这本书，上周我看就看完了，感觉有很大收获，对初学者也比较友好，应该好好看一道，React肯定就入门了，我打算是每三四天翻译一章，然后也发布在此处，欢迎大家关注，希望和大家一起进步。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e参考\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/patternhatch.com\/2016\/07\/06\/a-primer-on-the-react-ecosystem-part-1-of-3\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eA Primer on the React Ecosystem: Part 1 of 3\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/patternhatch.com\/2016\/08\/02\/a-primer-on-the-react-ecosystem-part-2-of-3\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eA Primer on the React Ecosystem: Part 2 of 3\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/20346379?refer=purerender\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact 源码剖析系列 － 不可思议的 react diff\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/www.gitbook.com\/book\/frontendmasters\/react-enlightenment\/details\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Enlightenment\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006178770?_ea=1088498\x22\x3e入门 Webpack，看这篇就够了\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/20328570?refer=purerender\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact 源码剖析系列 － 解密 setState\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/zhangwang1990.gitbooks.io\/reactenlightenment\/content\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Enlightenment译文地址\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>是时候理清 React 开发中的一些疑惑了</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006685370">https://segmentfault.com/a/1190000006685370</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/bahnaw6eleo/" target="_blank">https://alili.tech/archive/bahnaw6eleo/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>