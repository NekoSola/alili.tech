<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React性能优化"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React性能优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/zjb9v9zdgm/",
				"appid": "1613049289050283", 
				"title": "React性能优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fcbxpy5am0u/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/x49k0qqm0ei/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fzjb9v9zdgm%2f&text=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fzjb9v9zdgm%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fzjb9v9zdgm%2f&text=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fzjb9v9zdgm%2f&title=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fzjb9v9zdgm%2f&is_video=false&description=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fzjb9v9zdgm%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fzjb9v9zdgm%2f&title=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fzjb9v9zdgm%2f&title=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fzjb9v9zdgm%2f&title=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fzjb9v9zdgm%2f&title=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React性能优化</h1><div class="meta"><div class="postdate"><time datetime="2019-02-05" itemprop="datePublished">2019-02-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e当大家考虑在项目中使用 React 的时候，第一个问题往往是他们的应用的速度和响应是否能和非 React 版一样，每当状态改变的时候就重新渲染组件的整个子树，让大家怀疑这会不会对性能造成负面影响。React 用了一些黑科技来减少 UI 更新需要的花费较大的 DOM 操作。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e使用 production 版本\x3c\/h2\x3e\n\x3cp\x3e如果你在你的 React app 中进行性能测试或在寻找性能问题，一定要确定你在使用 \x3ca href=\x22\/react\/downloads.html\x22\x3eminified production build\x3c\/a\x3e。开发者版本包括额外的警告信息，这对你在开发你的 app 的时候很有用，但是因为要进行额外的处理，所以它也会比较慢。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e避免更新 DOM\x3c\/h2\x3e\n\x3cp\x3eReact 使用虚拟 DOM，它是在浏览器中的 DOM 子树的渲染描述，这个平行的描述让 React 避免创建和操作 DOM 节点，这些远比操作一个 JavaScript 对象慢。当一个组件的 props 或 state 改变，React 会构造一个新的虚拟 DOM 和旧的进行对比来决定真实 DOM 更新的必要性，只有在它们不相等的时候，React 才会使用尽量少的改动更新 DOM。\x3c\/p\x3e\n\x3cp\x3e在此之上，React 提供了生命周期函数 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e，在重新渲染机制回路（虚拟 DOM 对比和 DOM 更新）之前会被触发，赋予开发者跳过这个过程的能力。这个函数默认返回 \x3ccode\x3etrue\x3c\/code\x3e，让 React 执行更新。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22shouldComponentUpdate: function(nextProps, nextState) {\n  return true;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eshouldComponentUpdate: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextProps, nextState\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一定要记住，React 会非常频繁的调用这个函数，所以要确保它的执行速度够快。\x3c\/p\x3e\n\x3cp\x3e假如你有个带有多个对话的消息应用，如果只有一个对话发生改变，如果我们在 \x3ccode\x3eChatThread\x3c\/code\x3e 组件执行 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e，React 可以跳过其他对话的重新渲染步骤。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22shouldComponentUpdate: function(nextProps, nextState) {\n  \/\/ TODO: return whether or not current chat thread is\n  \/\/ different to former one.\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eshouldComponentUpdate: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextProps, nextState\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x3cspan class=\x22hljs-doctag\x22\x3eTODO:\x3c\/span\x3e return whether or not current chat thread is\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ different to former one.\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此，总的说，React 通过让用户使用 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 减短重新渲染回路，避免进行昂贵的更新 DOM 子树的操作，而且这些必要的更新，需要对比虚拟 DOM。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eshouldComponentUpdate 实战\x3c\/h2\x3e\n\x3cp\x3e这里有个组件的子树，每一个都指明了 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 返回值和虚拟 DOM 是否相等，最后，圆圈的颜色表示组件是否需要更新。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVApam?w=555\x26amp;h=371\x22 src=\x22https:\/\/static.alili.tech\/img\/bVApam?w=555\x26amp;h=371\x22 alt=\x22should-component-update.png\x22 title=\x22should-component-update.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在上面的示例中，因为 C2 的 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 返回 false，React 就不需要生成新的虚拟 DOM，也就不需要更新 DOM，注意 React 甚至不需要调用 C4 和 C5 的 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3eC1 和 C3 的 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 返回 \x3ccode\x3etrue\x3c\/code\x3e，所以 React 需要向下到叶子节点检查它们，C6 返回 \x3ccode\x3etrue\x3c\/code\x3e，因为虚拟 DOM 不相等，需要更新 DOM。最后感兴趣的是 C8，对于这个节点，React 需要计算虚拟 DOM，但是因为它和旧的相等，所以不需要更新 DOM。\x3c\/p\x3e\n\x3cp\x3e注意 React 只需要对 C6 进行 DOM 转换，这是必须的。对于 C8，通过虚拟 DOM 的对比确定它是不需要的，C2 的子树和 C7，它们甚至不需要计算虚拟 DOM，因为 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e那么，我们怎么实现 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 呢？比如说你有一个组件仅仅渲染一个字符串:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React.createClass({\n  propTypes: {\n    value: React.PropTypes.string.isRequired\n  },\n\n  render: function() {\n    return \x3cdiv\x3e{this.props.value}\x3c\/div\x3e;\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eReact.createClass({\n  \x3cspan class=\x22hljs-attr\x22\x3epropTypes\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: React.PropTypes.string.isRequired\n  },\n\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e{this.props.value}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以简单的实现 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22shouldComponentUpdate: function(nextProps, nextState) {\n  return this.props.value !== nextProps.value;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eshouldComponentUpdate: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextProps, nextState\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.value !== nextProps.value;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e非常好！处理这样简单结构的 props／state 很简单，我门甚至可以归纳出一个基于浅对比的实现，然后把它 Mixin 到组件中。实际上 React 已经提供了这样的实现: \x3ca href=\x22\/react\/docs\/pure-render-mixin.html\x22\x3ePureRenderMixin\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e但是如果你的组件的 props 或者 state 是可变的数据结构呢？比如说，组件接收的 prop 不是一个像 \x3ccode\x3e\x27bar\x27\x3c\/code\x3e 这样的字符串，而是一个包涵字符串的 JavaScript 对象，比如 \x3ccode\x3e{ foo: \x27bar\x27 }\x3c\/code\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React.createClass({\n  propTypes: {\n    value: React.PropTypes.object.isRequired\n  },\n\n  render: function() {\n    return \x3cdiv\x3e{this.props.value.foo}\x3c\/div\x3e;\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eReact.createClass({\n  \x3cspan class=\x22hljs-attr\x22\x3epropTypes\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: React.PropTypes.object.isRequired\n  },\n\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e{this.props.value.foo}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e前面的 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 实现就不会一直和我们期望的一样工作:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ assume this.props.value is { foo: \x27bar\x27 }\n\/\/ assume nextProps.value is { foo: \x27bar\x27 },\n\/\/ but this reference is different to this.props.value\nthis.props.value !== nextProps.value; \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ assume this.props.value is { foo: \x27bar\x27 }\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ assume nextProps.value is { foo: \x27bar\x27 },\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ but this reference is different to this.props.value\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.value !== nextProps.value; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个问题是当 prop 没有改变的时候 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 也会返回 \x3ccode\x3etrue\x3c\/code\x3e。为了解决这个问题，我们有了这个替代实现:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22shouldComponentUpdate: function(nextProps, nextState) {\n  return this.props.value.foo !== nextProps.value.foo;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eshouldComponentUpdate: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextProps, nextState\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.value.foo !== nextProps.value.foo;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e基本上，我们结束了使用深度对比来确保改变的正确跟踪，这个方法在性能上的花费是很大的，因为我们需要为每个 model 写不同的深度对比代码。就算这样，如果我们没有处理好对象引用，它甚至不能工作，比如说这个父组件:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React.createClass({\n  getInitialState: function() {\n    return { value: { foo: \x27bar\x27 } };\n  },\n\n  onClick: function() {\n    var value = this.state.value;\n    value.foo \x2b= \x27bar\x27; \/\/ ANTI-PATTERN!\n    this.setState({ value: value });\n  },\n\n  render: function() {\n    return (\n      \x3cdiv\x3e\n        \x3cInnerComponent value={this.state.value} \/\x3e\n        \x3ca onClick={this.onClick}\x3eClick me\x3c\/a\x3e\n      \x3c\/div\x3e\n    );\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eReact.createClass({\n  \x3cspan class=\x22hljs-attr\x22\x3egetInitialState\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: { \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e } };\n  },\n\n  \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.value;\n    value.foo \x2b= \x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ANTI-PATTERN!\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: value });\n  },\n\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eInnerComponent\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.state.value}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.onClick}\x3c\/span\x3e\x26gt;\x3c\/span\x3eClick me\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    );\n  }\n});\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e内部组件第一次渲染的时候，它会获取 \x3ccode\x3e{ foo: \x27bar\x27 }\x3c\/code\x3e 作为 value 的值。如果用户点击了 a 标签，父组件的 state 会更新成 \x3ccode\x3e{ value: { foo: \x27barbar\x27 } }\x3c\/code\x3e，触发内部组件的重新渲染过程，内部组件会收到 \x3ccode\x3e{ foo: \x27barbar\x27 }\x3c\/code\x3e 作为 value 的新的值。\x3c\/p\x3e\n\x3cp\x3e这里的问题是因为父组件和内部组件共享同一个对象的引用，当对象在 \x3ccode\x3eonClick\x3c\/code\x3e 函数的第二行发生改变的时候，内部组件的属性也发生了改变，所以当重新渲染过程开始，\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 被调用的时候，\x3ccode\x3ethis.props.value.foo\x3c\/code\x3e 和 \x3ccode\x3enextProps.value.foo\x3c\/code\x3e 是相等的，因为实际上 \x3ccode\x3ethis.props.value\x3c\/code\x3e 和 \x3ccode\x3enextProps.value\x3c\/code\x3e 是同一个对象的引用。\x3c\/p\x3e\n\x3cp\x3e因此，我们会丢失 prop 的改变，缩短重新渲染过程，UI 也不会从 \x3ccode\x3e\x27bar\x27\x3c\/code\x3e 更新到 \x3ccode\x3e\x27barbar\x27\x3c\/code\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eImmutable-js 来救赎\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/facebook\/immutable-js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eImmutable-js\x3c\/a\x3e 是 Lee Byron 写的 JavaScript 集合类型的库，最近被 Facebook 开源，它通过\x3cem\x3e结构共享\x3c\/em\x3e提供\x3cem\x3e不可变持久化\x3c\/em\x3e集合类型。一起看下这些特性的含义:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cem\x3eImmutable\x3c\/em\x3e: 一旦创建，集合就不能再改变。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cem\x3ePersistent\x3c\/em\x3e: 新的集合类型可以通过之前的集合创建，比如 set 产生改变的集合。创建新的集合之后源集合仍然有效。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cem\x3eStructural Sharing\x3c\/em\x3e: 新的集合会使用尽量多的源集合的结构，减少复制来节省空间和性能友好。如果新的集合和源集合相等，一般会返回源结构。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e不可变让跟踪改变非常简单；每次改变都是产生新的对象，所以我们仅需要对象的引用是否改变，比如这段简单的 JavaScript 代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var x = { foo: \x26quot;bar\x26quot; };\nvar y = x;\ny.foo = \x26quot;baz\x26quot;;\nx === y; \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e x = { \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22bar\x22\x3c\/span\x3e };\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e y = x;\ny.foo = \x3cspan class=\x22hljs-string\x22\x3e\x22baz\x22\x3c\/span\x3e;\nx === y; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e尽管 \x3ccode\x3ey\x3c\/code\x3e 被改变，因为它和 \x3ccode\x3ex\x3c\/code\x3e 引用的是同一个对象，这个对比返回 \x3ccode\x3etrue\x3c\/code\x3e。然而，这个代码可以使用 immutable-js 改写如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var SomeRecord = Immutable.Record({ foo: null });\nvar x = new SomeRecord({ foo: \x27bar\x27  });\nvar y = x.set(\x27foo\x27, \x27baz\x27);\nx === y; \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e SomeRecord = Immutable.Record({ \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e });\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e x = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e SomeRecord({ \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e  });\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e y = x.set(\x3cspan class=\x22hljs-string\x22\x3e\x27foo\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27baz\x27\x3c\/span\x3e);\nx === y; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子中，因为改变 \x3ccode\x3ex\x3c\/code\x3e 的时候返回了新的引用，我们就可以安全的认为 \x3ccode\x3ex\x3c\/code\x3e 已经改变。\x3c\/p\x3e\n\x3cp\x3e脏检测可以作为另外的可行的方式追踪改变，给 setters 一个标示。这个方法的问题是，它强制你使用 setters，而且要写很多额外的代码，影响你的类。或者你可以在改变之前深拷贝对象，然后进行深对比来确定是不是发生了改变。这个方法的问题是，深拷贝和深对比都是很花性能的操作。\x3c\/p\x3e\n\x3cp\x3e因此，不可变数据结构给你提供了一个高效、简洁的方式来跟踪对象的改变，而跟踪改变是实现 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 的关键。所以，如果我们使用 immutable-js 提供的抽象创建 props 和 state 模型，我们就可以使用 \x3ccode\x3ePureRenderMixin\x3c\/code\x3e，而且能够获得很好的性能增强。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eImmutable-js 和 Flux\x3c\/h2\x3e\n\x3cp\x3e如果你在使用 \x3ca href=\x22https:\/\/facebook.github.io\/flux\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFlux\x3c\/a\x3e，你应该开始使用 immutable-js 写你的 stores，看一下 \x3ca href=\x22https:\/\/facebook.github.io\/immutable-js\/docs\/#\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3efull API\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e让我们看一个可行的方式，使用不可变数据结构来给消息示例创建数据结构。首先我们要给每个要建模的实体定义一个 \x3ccode\x3eRecord\x3c\/code\x3e。Records 仅仅是一个不可变容器，里面保存一系列具体数据:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var User = Immutable.Record({\n  id: undefined,\n  name: undefined,\n  email: undefined\n});\n\nvar Message = Immutable.Record({\n  timestamp: new Date(),\n  sender: undefined,\n  text: \x27\x27\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e User = Immutable.Record({\n  \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eemail\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Message = Immutable.Record({\n  \x3cspan class=\x22hljs-attr\x22\x3etimestamp\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e(),\n  \x3cspan class=\x22hljs-attr\x22\x3esender\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eRecord\x3c\/code\x3e 方法接收一个对象，来定义字段和对应的默认数据。\x3c\/p\x3e\n\x3cp\x3e消息的 \x3cem\x3estore\x3c\/em\x3e 可以使用两个 list 来跟踪 users 和 messages:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.users = Immutable.List();\nthis.messages = Immutable.List();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.users = Immutable.List();\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.messages = Immutable.List();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实现函数处理每个 \x3cem\x3epayload\x3c\/em\x3e 类型应该是比较简单的，比如，当 store 看到一个代表新消息的 payload 时，我们就创建一个新的 record，并放入消息列表:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.messages = this.messages.push(new Message({\n  timestamp: payload.timestamp,\n  sender: payload.sender,\n  text: payload.text\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.messages = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.messages.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Message({\n  \x3cspan class=\x22hljs-attr\x22\x3etimestamp\x3c\/span\x3e: payload.timestamp,\n  \x3cspan class=\x22hljs-attr\x22\x3esender\x3c\/span\x3e: payload.sender,\n  \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: payload.text\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意：因为数据结构不可变，我们需要把 push 方法的结果赋给 \x3ccode\x3ethis.messages\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e在 React 里，如果我们也使用 immutable-js 数据结构来保存组件的 state，我门可以把 \x3ccode\x3ePureRenderMixin\x3c\/code\x3e 混入到我门所有的组件来缩短重新渲染回路。\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e这篇文章是翻译React官方文档\x3c\/em\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React性能优化</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006254212">https://segmentfault.com/a/1190000006254212</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/zjb9v9zdgm/" target="_blank">https://alili.tech/archive/zjb9v9zdgm/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>