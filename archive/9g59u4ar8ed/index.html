<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从Mixin到hooks，谈谈对React16.7.0-alpha中即将引入的hooks的理解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从Mixin到hooks，谈谈对React16.7.0-alpha中即将引入的hooks的理解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9g59u4ar8ed/",
				"appid": "1613049289050283", 
				"title": "从Mixin到hooks，谈谈对React16.7.0-alpha中即将引入的hooks的理解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-15T02:30:44"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jk44qtqfsac/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/vo60tsafnk/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9g59u4ar8ed%2f&text=%e4%bb%8eMixin%e5%88%b0hooks%ef%bc%8c%e8%b0%88%e8%b0%88%e5%af%b9React16.7.0-alpha%e4%b8%ad%e5%8d%b3%e5%b0%86%e5%bc%95%e5%85%a5%e7%9a%84hooks%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9g59u4ar8ed%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9g59u4ar8ed%2f&text=%e4%bb%8eMixin%e5%88%b0hooks%ef%bc%8c%e8%b0%88%e8%b0%88%e5%af%b9React16.7.0-alpha%e4%b8%ad%e5%8d%b3%e5%b0%86%e5%bc%95%e5%85%a5%e7%9a%84hooks%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9g59u4ar8ed%2f&title=%e4%bb%8eMixin%e5%88%b0hooks%ef%bc%8c%e8%b0%88%e8%b0%88%e5%af%b9React16.7.0-alpha%e4%b8%ad%e5%8d%b3%e5%b0%86%e5%bc%95%e5%85%a5%e7%9a%84hooks%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9g59u4ar8ed%2f&is_video=false&description=%e4%bb%8eMixin%e5%88%b0hooks%ef%bc%8c%e8%b0%88%e8%b0%88%e5%af%b9React16.7.0-alpha%e4%b8%ad%e5%8d%b3%e5%b0%86%e5%bc%95%e5%85%a5%e7%9a%84hooks%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8eMixin%e5%88%b0hooks%ef%bc%8c%e8%b0%88%e8%b0%88%e5%af%b9React16.7.0-alpha%e4%b8%ad%e5%8d%b3%e5%b0%86%e5%bc%95%e5%85%a5%e7%9a%84hooks%e7%9a%84%e7%90%86%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9g59u4ar8ed%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9g59u4ar8ed%2f&title=%e4%bb%8eMixin%e5%88%b0hooks%ef%bc%8c%e8%b0%88%e8%b0%88%e5%af%b9React16.7.0-alpha%e4%b8%ad%e5%8d%b3%e5%b0%86%e5%bc%95%e5%85%a5%e7%9a%84hooks%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9g59u4ar8ed%2f&title=%e4%bb%8eMixin%e5%88%b0hooks%ef%bc%8c%e8%b0%88%e8%b0%88%e5%af%b9React16.7.0-alpha%e4%b8%ad%e5%8d%b3%e5%b0%86%e5%bc%95%e5%85%a5%e7%9a%84hooks%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9g59u4ar8ed%2f&title=%e4%bb%8eMixin%e5%88%b0hooks%ef%bc%8c%e8%b0%88%e8%b0%88%e5%af%b9React16.7.0-alpha%e4%b8%ad%e5%8d%b3%e5%b0%86%e5%bc%95%e5%85%a5%e7%9a%84hooks%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9g59u4ar8ed%2f&title=%e4%bb%8eMixin%e5%88%b0hooks%ef%bc%8c%e8%b0%88%e8%b0%88%e5%af%b9React16.7.0-alpha%e4%b8%ad%e5%8d%b3%e5%b0%86%e5%bc%95%e5%85%a5%e7%9a%84hooks%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从Mixin到hooks，谈谈对React16.7.0-alpha中即将引入的hooks的理解</h1><div class="meta"><div class="postdate"><time datetime="2019-02-15" itemprop="datePublished">2019-02-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3chr\x3e\n\x3cp\x3e  为了实现分离业务逻辑代码，实现组件内部相关业务逻辑的复用，在React的迭代中针对类组件中的代码复用依次发布了Mixin、HOC、Render props等几个方案。此外，针对函数组件，在React v16.7.0-alpha 中提出了hooks的概念，在本身无状态的函数组件，引入独立的状态空间，也就是说在函数组件中，也可以引入类组件中的state和组件生命周期，使得函数组件变得丰富多彩起来，此外，hooks也保证了逻辑代码的复用性和独立性。\x3c\/p\x3e\n\x3cp\x3e  本文从针对类组件的复用解决方案开始说起，先后介绍了从Mixin、HOC到Render props的演进，最后介绍了React v16.7.0-alpha 中的 hooks以及自定义一个hooks\x3c\/p\x3e\n\x3cblockquote\x3e\x3cul\x3e\n\x3cli\x3eMixin\x3c\/li\x3e\n\x3cli\x3eHOC\x3c\/li\x3e\n\x3cli\x3eRender props\x3c\/li\x3e\n\x3cli\x3eReact hooks的介绍以及如何自定义一个hooks\x3c\/li\x3e\n\x3c\/ul\x3e\x3c\/blockquote\x3e\n\x3cp\x3e原文地址在我的博客中：\x3ca href=\x22https:\/\/github.com\/forthealllight\/blog\/issues\/29\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/forthealll...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e欢迎star和fork～\x3c\/p\x3e\n\x3chr\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e一、Mixin\x3c\/h3\x3e\n\x3cp\x3eMixin是最早出现的复用类组件中业务逻辑代码的解决方案，首先来介绍以下如何适应Mixin。下面是一个Mixin的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const someMixins={\n  printColor(){\n    console.log(this.state.color);\n  }\n  setColor(newColor){\n    this.setState({color:newColor})\n  }\n  componentDidMount(){\n    ..\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e someMixins={\n  printColor(){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.color);\n  }\n  setColor(newColor){\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e:newColor})\n  }\n  componentDidMount(){\n    ..\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面是一个使用Mixin的组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Apple extends React.Component{\n  \/\/仅仅作为演示，mixins一般是通过React.createClass创建，并且ES6中没有这种写法\n  mixins:[someMixins]\n  constructor(props){\n    super(props);\n    this.state={\n      color:\x27red\x27\n    }\n    this.printColor=this.printColor.bind(this);\n  }\n  render(){\n    return \x3cdiv className=\x26quot;m-box\x26quot; onClick={this.printColor}\x3e\n                这是一个苹果\n           \x3c\/div\x3e\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApple\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/仅仅作为演示，mixins一般是通过React.createClass创建，并且ES6中没有这种写法\x3c\/span\x3e\n  mixins:[someMixins]\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props){\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state={\n      \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.printColor=\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.printColor.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22m-box\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.printColor}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                这是一个苹果\n           \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在类中mixin引入公共业务逻辑：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22mixins:[someMixins]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3emixins:[someMixins]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面的例子，我们来总结以下mixin的缺点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eMixin是可以存在多个的，是一个数组的形式，且Mixin中的函数是可以调用setState方法组件中的state的，因此如果有多处Mixin的模块中修改了相同的state，会无法确定state的更新来源\x3c\/li\x3e\n\x3cli\x3eES6 classes支持的是继承的模式，而不支持Mixins\x3c\/li\x3e\n\x3cli\x3eMixin会存在覆盖，比如说两个Mixin模块，存在相同生命周期函数或者相同函数名的函数，那么会存在相同函数的覆盖问题。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eMixin已经被废除，具体缺陷可以参考\x3ca href=\x22https:\/\/reactjs.org\/blog\/2016\/07\/13\/mixins-considered-harmful.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMixins Considered Harmful\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e二、HOC\x3c\/h3\x3e\n\x3cp\x3e  为了解决Mixin的缺陷，第二种解决方案是高阶组件（high order component,简称HOC）。\x3c\/p\x3e\n\x3ch4\x3e1、举例几种HOC的形式\x3c\/h4\x3e\n\x3cp\x3e  HOC简单理解就是组件工厂，接受原始组件作为参数，添加完功能与业务后，返回新的组件。下面来介绍HOC参数的几个例子。\x3c\/p\x3e\n\x3ch4\x3e(1)参数仅为原始组件\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const redApple = withFruit(Apple);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e redApple = withFruit(Apple);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e(2)参数为原始组件和一个对象\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const redApple = withFruit(Apple，{color:\x27red\x27,weight:\x27200g\x27});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e redApple = withFruit(Apple，{\x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-attr\x22\x3eweight\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27200g\x27\x3c\/span\x3e});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是这种情况比较少用，如果对象中仅仅传递的是属性，其实完全可以通过组件的props实现值的传递，我们用HOC的主要目的是分离业务，关于UI的展示，以及一些组件中的属性和状态，我们一般通过props来指定比较方便\x3c\/p\x3e\n\x3ch4\x3e(3)参数为原始组件和一个函数\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const redApp=withFruit(App,()=\x3e{console.log(\x27I am a fruit\x27)})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e redApp=withFruit(App,()=\x26gt;{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27I am a fruit\x27\x3c\/span\x3e)})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e(4)柯里化\x3c\/h4\x3e\n\x3cp\x3e最常见的是仅以一个原始组件作为参数，但是在外层包裹了业务逻辑，比如react-redux的conect函数中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Admin extends React.Component{\n\n}\nconst mapStateToProps=(state)=\x3e{\n  return {\n  };\n}\nconst mapDispatchToProps=(dispatch)=\x3e{\n  return {\n\n  }\n}\n\nconst connect(mapStateToProps,mapDispatchToProps)(Admin)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAdmin\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapStateToProps=\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n  };\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapDispatchToProps=\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edispatch\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e connect(mapStateToProps,mapDispatchToProps)(Admin)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e2、HOC的缺点\x3c\/h4\x3e\n\x3cp\x3eHOC解决了Mixin的一些缺陷，但是HOC本身也有一些缺点：\x3c\/p\x3e\n\x3ch4\x3e(1)难以溯源，且存在属性覆盖问题\x3c\/h4\x3e\n\x3cp\x3e  如果原始组件A，先后通过工厂函数1，工厂函数2，工厂函数3….构造，最后生成了组件B，我们知道组件B中有很多与A组件不同的props，但是我们仅仅通过组件B，并不能知道哪个组件来自于哪个工厂函数。同时，如果有2个工厂函数同时修改了组件A的某个同名属性，那么会有属性覆盖的问题，会使得前一个工厂函数的修改结果失效。\x3c\/p\x3e\n\x3ch4\x3e(2)HOC是静态构建的\x3c\/h4\x3e\n\x3cp\x3e  所谓静态构建，也就是说生成的是一个新的组件，并不会马上render，HOC组件工厂是静态构建一个组件，这类似于重新声明一个组件的部分。也就是说，HOC工厂函数里面的声明周期函数，也只有在新组件被渲染的时候才会执行。\x3c\/p\x3e\n\x3ch4\x3e(3)会产生无用的空组件\x3c\/h4\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e三、Render Prop\x3c\/h3\x3e\n\x3cp\x3e  Render Props从名知义，也是一种剥离重复使用的逻辑代码，提升组件复用性的解决方案。在被复用的组件中，通过一个名为“render”(属性名也可以不是render，只要值是一个函数即可)的属性，该属性是一个函数，这个函数接受一个对象并返回一个子组件，会将这个函数参数中的对象作为props传入给新生成的组件。\x3c\/p\x3e\n\x3cp\x3e  这种方法跟直接的在父组件中，将父组件中的state直接传给子组件的区别是，通过Render Props不用写死子组件，可以动态的决定父组件需要渲染哪一个子组件。\x3c\/p\x3e\n\x3cp\x3e或者再概括一点：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3eRender Props就是一个函数，做为一个属性被赋值给父组件，使得父组件可以根据该属性去渲染子组件。\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch4\x3e(1)标准父子组件通信方法\x3c\/h4\x3e\n\x3cp\x3e  首先来看常用的在类组件中常用的父子组件，父组件将自己的状态state，通过props传递给子组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Son extends React.Component{\n  render(){\n  const {feature} = this.props;\n   return \x3cdiv\x3e\n             \x3cspan\x3eMy hair is {feature.hair}\x3c\/span\x3e\n             \x3cspan\x3eMy nose is {feature.nose}\x3c\/span\x3e\n          \x3c\/div\x3e\n  }\n}\n\nclass FatherToSon extends React.Component{\n   constructor(){\n      this.state = {\n        hair:\x27black\x27,\n        nose:\x27high\x27\n      }\n   }\n  render(){\n    return \x3cSon feature = {this.state}\x3e\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSon\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n  render(){\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {feature} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n             \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3eMy hair is {feature.hair}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n             \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3eMy nose is {feature.nose}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFatherToSon\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(){\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n        \x3cspan class=\x22hljs-attr\x22\x3ehair\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3enose\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27high\x27\x3c\/span\x3e\n      }\n   }\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSon\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3efeature\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e{this.state}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e  我们定义了父组件FatherToSon，存在自身的state，并且将自身的state通过props的方式传递给了子组件。\x3c\/p\x3e\n\x3cp\x3e  这种就是常见的利用组件的props父子间传值的方式，这个值可以是变量，对象，也可以是方法，但是仅仅使用只能一次性的给特定的子组件使用。如果现在有个Daughter组件也想复用父组件中的方法或者状态，那么必须新构建一个新组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class FatherToDaughter extends React.Component{\n   constructor(){\n      this.state = {\n        hair:\x27black\x27,\n        nose:\x27high\x27\n      }\n   }\n  render(){\n    return \x3cDaughter feature = {this.state}\x3e\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFatherToDaughter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(){\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n        \x3cspan class=\x22hljs-attr\x22\x3ehair\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3enose\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27high\x27\x3c\/span\x3e\n      }\n   }\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eDaughter\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3efeature\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e{this.state}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面的例子可以看出通过标准模式的父子组件的通信方法，虽然能够传递父组件的状态和函数，但是无法实现复用。\x3c\/p\x3e\n\x3ch4\x3e(2)Render Props的引出\x3c\/h4\x3e\n\x3cp\x3e我们根据Render Props的特点：\x3c\/p\x3e\n\x3cp\x3eRender Props就是一个函数，做为一个属性被赋值给父组件，使得父组件可以根据该属性去渲染子组件。\x3c\/p\x3e\n\x3cp\x3e重新去实现上述的(1)中的例子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class FatherChild extends React.Component{\n   constructor(){\n      this.state = {\n        hair:\x27black\x27,\n        nose:\x27high\x27\n      }\n   }\n  render(){\n    \x3cReact.Fragment\x3e\n      {this.props.render}\n    \x3c\/React.Fragment\x3e\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFatherChild\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(){\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n        \x3cspan class=\x22hljs-attr\x22\x3ehair\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3enose\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27high\x27\x3c\/span\x3e\n      }\n   }\n  render(){\n    \x26lt;React.Fragment\x26gt;\n      {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.render}\n    \x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/React.Fragment\x26gt;\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时如果子组件要复用父组件中的属性或者函数，则可以直接使用，比如子组件Son现在可以直接调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cFatherChild render={(obj)=\x3e(\x3cSon feature={obj}\x3e)} \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;FatherChild render={(obj)=\x26gt;(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSon\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3efeature\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{obj}\x3c\/span\x3e\x26gt;\x3c\/span\x3e)} \/\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果子组件Daughter要复用父组件的方法，可以直接调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cFatherChild render={(obj)=\x3e(\x3cDaughter feature={obj}\x3e)} \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;FatherChild render={(obj)=\x26gt;(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eDaughter\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3efeature\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{obj}\x3c\/span\x3e\x26gt;\x3c\/span\x3e)} \/\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e  从这个例子中可以看出，通过Render Props我们实现同样实现了一个组件工厂，可以实现业务逻辑代码的复用，相比与HOC，Render Props有以下几个优点。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e不用担心props的命名问题\x3c\/li\x3e\n\x3cli\x3e可以溯源，子组件的props一定是来自于直接父组件\x3c\/li\x3e\n\x3cli\x3e是动态构建的\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eRender Props也有一个缺点：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e就是无法利用SCU这个生命周期，来实现渲染性能的优化。\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e四、React hooks的介绍以及如何自定义一个hooks\x3c\/h3\x3e\n\x3cp\x3e  hooks概念在React Conf 2018被提出来，并将在未来的版本中被引入，hooks遵循函数式编程的理念，主旨是在函数组件中引入类组件中的状态和生命周期，并且这些状态和生命周期函数也可以被抽离，实现复用的同时，减少函数组件的复杂性和易用性。\x3c\/p\x3e\n\x3cp\x3e  hooks相关的定义还在beta中，可以在React v16.7.0-alpha中体验，为了渲染hooks定义的函数组件，必须执行React-dom的版本也为v16.7.0-alpha，引入hooks必须先安装：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -s React@16.7.0-alpha\n\nnpm i -s React-dom@16.7.0-alpha\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3enpm i -s React@\x3cspan class=\x22hljs-number\x22\x3e16.7\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e-alpha\n\nnpm i -s React-dom@\x3cspan class=\x22hljs-number\x22\x3e16.7\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e-alpha\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e  hooks主要有三部分组成，State Hooks、Effect Hooks和Custom Hooks，下面分别来一一介绍。\x3c\/p\x3e\n\x3ch4\x3e(1)State Hooks\x3c\/h4\x3e\n\x3cp\x3e  跟类组件一样，这里的state就是状态的含义，将state引入到函数组件中，同时类组件中更新state的方法为setState，在State Hooks中也有相应的更新状态的方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function ExampleWithManyStates() {\n  \/\/ 声明各种state以及更新相应的state的方法\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState(\x27banana\x27);\n  const [todos, setTodos] = useState([{ text: \x27Learn Hooks\x27 }]);\n  \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleWithManyStates\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 声明各种state以及更新相应的state的方法\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [age, setAge] = useState(\x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [fruit, setFruit] = useState(\x3cspan class=\x22hljs-string\x22\x3e\x27banana\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [todos, setTodos] = useState([{ \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Learn Hooks\x27\x3c\/span\x3e }]);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e  上述就声明了3个State hooks，相应的方法为useState，该方法创建一个传入初始值，创建一个state。返回一个标识该state的变量，以及更新该state的方法。\x3c\/p\x3e\n\x3cp\x3e  从上述例子我们来看，一个函数组件是可以通过useState创建多个state的。此外State Hooks的定义必须在函数组件的最高一级，不能在嵌套，循环等语句中使用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function ExampleWithManyStates() {\n  \/\/ 声明各种state以及更新相应的state的方法\n  if(Math.random()\x3e1){\n    const [age, setAge] = useState(42);\n    const [todos, setTodos] = useState([{ text: \x27Learn Hooks\x27 }]);\n  }else{\n    const [fruit, setFruit] = useState(\x27banana\x27);\n    const [todos, setTodos] = useState([{ text: \x27Learn Hooks\x27 }]);\n  }\n  \n  \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExampleWithManyStates\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 声明各种state以及更新相应的state的方法\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random()\x26gt;\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e){\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [age, setAge] = useState(\x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [todos, setTodos] = useState([{ \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Learn Hooks\x27\x3c\/span\x3e }]);\n  }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [fruit, setFruit] = useState(\x3cspan class=\x22hljs-string\x22\x3e\x27banana\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [todos, setTodos] = useState([{ \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Learn Hooks\x27\x3c\/span\x3e }]);\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e  上述的方式是不被允许的，因为一个函数组件可以存在多个State Hooks，并且useState返回的是一个数组，数组的每一个元素是没有标识信息的，完全依靠调用useState的顺序来确定哪个状态对应于哪个变量，所以必须保证使用useState在函数组件的最外层，此外后面要介绍的Effect Hooks的函数useEffect也必须在函数组件的最外层，之后会详细解释。\x3c\/p\x3e\n\x3ch4\x3e(2)Effect Hooks\x3c\/h4\x3e\n\x3cp\x3e  通过State Hooks来定义组件的状态，同样通过Effect Hooks来引入生命周期，Effect hooks通过一个useEffect的方法，以一种极为简化的方式来引入生命周期。\x3cbr\x3e来看一个更新的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { useState, useEffect } from \x27react\x27;\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() =\x3e {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    \x3cdiv\x3e\n      \x3cp\x3eYou clicked {count} times\x3c\/p\x3e\n      \x3cbutton onClick={() =\x3e setCount(count \x2b 1)}\x3e\n        Click me\n      \x3c\/button\x3e\n    \x3c\/div\x3e\n  );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { useState, useEffect } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExample\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [count, setCount] = useState(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n  useEffect(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.title = \x3cspan class=\x22hljs-string\x22\x3e`You clicked \x3cspan class=\x22hljs-subst\x22\x3e${count}\x3c\/span\x3e times`\x3c\/span\x3e;\n  });\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eYou clicked {count} times\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e setCount(count \x2b 1)}\x26gt;\n        Click me\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述就是一个通过useEffect来实现组件中生命周期的例子，useEffect整合了componentDidMount和componentDidUpdate，也就是说在componentDidMount和componentDidUpdate的时候都会执行一遍useEffect的函数，此外为了实现componentWillUnmount这个生命周期函数，useEffect函数如果返回值是一个函数，这个函数就被定义成在componentWillUnmount这个周期内执行的函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22useEffect(() =\x3e {\n    \/\/componentDidMount和componentDidUpdate周期的函数体\n    return ()=\x3e{ \n       \/\/componentWillUnmount周期的函数体\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3euseEffect(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/componentDidMount和componentDidUpdate周期的函数体\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{ \n       \x3cspan class=\x22hljs-comment\x22\x3e\/\/componentWillUnmount周期的函数体\x3c\/span\x3e\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果存在多个useState和useEffect时，必须按顺序书写，定义一个useState后，紧接着就使用一个useEffect函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22useState(\x27Mary\x27)           \nuseEffect(persistForm)    \nuseState(\x27Poppins\x27)       \nuseEffect(updateTitle)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3euseState(\x3cspan class=\x22hljs-string\x22\x3e\x27Mary\x27\x3c\/span\x3e)           \nuseEffect(persistForm)    \nuseState(\x3cspan class=\x22hljs-string\x22\x3e\x27Poppins\x27\x3c\/span\x3e)       \nuseEffect(updateTitle)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此通useState一样，useEffect函数也必须位于函数组件的最高一级。\x3c\/p\x3e\n\x3ch4\x3e(3)Effect Hooks的补充\x3c\/h4\x3e\n\x3cp\x3e上述我们知道useEffect其实包含了componentDidMount和componentDidUpdate，如果我们的方法仅仅是想在componentDidMount的时候被执行，那么必须传递一个空数组作为第二个参数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22useEffect(() =\x3e {\n  \/\/仅在componentDidMount的时候执行\n},[]);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3euseEffect(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/仅在componentDidMount的时候执行\x3c\/span\x3e\n},[]);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述的方法会仅仅在componentDidMount，也就是函数组件第一次被渲染的时候执行，此后及时状态更新，也不会执行。\x3c\/p\x3e\n\x3cp\x3e此外，为了减少不必要的状态更新和渲染，可以如下操作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22useEffect(() =\x3e {\n  \/\/仅在componentDidMount的时候执行\n},[stateName]);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3euseEffect(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/仅在componentDidMount的时候执行\x3c\/span\x3e\n},[stateName]);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上述的这个例子中，只有stateName的值发生改变，才会去执行useEffect函数。\x3c\/p\x3e\n\x3ch4\x3e(4)Custom Hooks自定义hooks\x3c\/h4\x3e\n\x3cp\x3e可以将useState和useEffect的状态和生命周期函数抽离，组成一个新的函数，该函数就是一个自定义的封装完毕的hooks。\x3c\/p\x3e\n\x3cp\x3e这是我写的一个hooks ---\x26gt; \x3ca href=\x22https:\/\/github.com\/forthealllight\/dom-location\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edom-location\x3c\/a\x3e,\x3c\/p\x3e\n\x3cp\x3e可以这样引入：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm i -s dom-location \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3enpm i -s dom-location \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e并且可以在函数组件中使用。这个自定义的hooks也很简单，就是封装了状态和生命周期函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { useState, useEffect } from \x27react\x27\n\nconst useDomLocation = (element) =\x3e  {\n  let [elementlocation,setElementlocation] = useState(getlocation(element));\n  useEffect(()=\x3e{\n    element.addEventListener(\x27resize\x27,handleResize);\n    return ()=\x3e{\n      element.removeEventListener(\x27resize\x27, handleResize);\n    }\n  },[]);\n  function handleResize(){\n    setElementlocation(getlocation(element));\n  }\n  function getlocation(E){\n    let rect = E.getBoundingClientRect()\n    let top = document.documentElement.clientTop\n    let left= document.documentElement.clientLeft\n    return{\n        top    :   rect.top - top,\n        bottom :   rect.bottom - top,\n        left   :   rect.left - left,\n        right  :   rect.right - left\n    };\n  }\n  return elementlocation\n\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { useState, useEffect } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e useDomLocation = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eelement\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e  {\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e [elementlocation,setElementlocation] = useState(getlocation(element));\n  useEffect(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    element.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27resize\x27\x3c\/span\x3e,handleResize);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      element.removeEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27resize\x27\x3c\/span\x3e, handleResize);\n    }\n  },[]);\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleResize\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    setElementlocation(getlocation(element));\n  }\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetlocation\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eE\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e rect = E.getBoundingClientRect()\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e top = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.clientTop\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e left= \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.clientLeft\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-attr\x22\x3etop\x3c\/span\x3e    :   rect.top - top,\n        \x3cspan class=\x22hljs-attr\x22\x3ebottom\x3c\/span\x3e :   rect.bottom - top,\n        \x3cspan class=\x22hljs-attr\x22\x3eleft\x3c\/span\x3e   :   rect.left - left,\n        \x3cspan class=\x22hljs-attr\x22\x3eright\x3c\/span\x3e  :   rect.right - left\n    };\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e elementlocation\n\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后直接在函数中使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import useDomLocation from \x27dom-location\x27;\nfunction App() {\n  ....\n  let obj = useDomLocation(element);\n  \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e useDomLocation \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27dom-location\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  ....\n  let obj = useDomLocation(element);\n  \n}\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>从Mixin到hooks，谈谈对React16.7.0-alpha中即将引入的hooks的理解</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016876476">https://segmentfault.com/a/1190000016876476</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9g59u4ar8ed/" target="_blank">https://alili.tech/archive/9g59u4ar8ed/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>