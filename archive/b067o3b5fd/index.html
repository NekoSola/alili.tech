<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="为何 ES Module 如此姗姗来迟"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>为何 ES Module 如此姗姗来迟 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/b067o3b5fd/",
				"appid": "1613049289050283", 
				"title": "为何 ES Module 如此姗姗来迟 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-11T02:30:49"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/lc9nrd9w8cs/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/o0w4l8o5r5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fb067o3b5fd%2f&text=%e4%b8%ba%e4%bd%95%20ES%20Module%20%e5%a6%82%e6%ad%a4%e5%a7%97%e5%a7%97%e6%9d%a5%e8%bf%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fb067o3b5fd%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fb067o3b5fd%2f&text=%e4%b8%ba%e4%bd%95%20ES%20Module%20%e5%a6%82%e6%ad%a4%e5%a7%97%e5%a7%97%e6%9d%a5%e8%bf%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fb067o3b5fd%2f&title=%e4%b8%ba%e4%bd%95%20ES%20Module%20%e5%a6%82%e6%ad%a4%e5%a7%97%e5%a7%97%e6%9d%a5%e8%bf%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fb067o3b5fd%2f&is_video=false&description=%e4%b8%ba%e4%bd%95%20ES%20Module%20%e5%a6%82%e6%ad%a4%e5%a7%97%e5%a7%97%e6%9d%a5%e8%bf%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b8%ba%e4%bd%95%20ES%20Module%20%e5%a6%82%e6%ad%a4%e5%a7%97%e5%a7%97%e6%9d%a5%e8%bf%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fb067o3b5fd%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fb067o3b5fd%2f&title=%e4%b8%ba%e4%bd%95%20ES%20Module%20%e5%a6%82%e6%ad%a4%e5%a7%97%e5%a7%97%e6%9d%a5%e8%bf%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb067o3b5fd%2f&title=%e4%b8%ba%e4%bd%95%20ES%20Module%20%e5%a6%82%e6%ad%a4%e5%a7%97%e5%a7%97%e6%9d%a5%e8%bf%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb067o3b5fd%2f&title=%e4%b8%ba%e4%bd%95%20ES%20Module%20%e5%a6%82%e6%ad%a4%e5%a7%97%e5%a7%97%e6%9d%a5%e8%bf%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb067o3b5fd%2f&title=%e4%b8%ba%e4%bd%95%20ES%20Module%20%e5%a6%82%e6%ad%a4%e5%a7%97%e5%a7%97%e6%9d%a5%e8%bf%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">为何 ES Module 如此姗姗来迟</h1><div class="meta"><div class="postdate"><time datetime="2019-02-11" itemprop="datePublished">2019-02-11</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cem\x3e说明：本文发布之后，此问题的推进峰回路转，不停有新内容。文末新增一节 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004940294#articleHeader5\x22\x3eUpdates\x3c\/a\x3e，跟进本文发布之后的 ES Module 标准化进展情况。\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e浏览器大战多年了热度依旧高涨，大家终于在 JS 新特性的部署上达成一致纷纷追赶最新标准，然而 ES2015 中的 ES Module 这个万众期待的重要特性却始终迟迟未能实现。\x3c\/p\x3e\n\x3cblockquote\x3e等 2020 年回望历史，倘若我们错过了 ES Module 这艘船而 Node.js 死在汪洋大海之中，没有任何其他技术问题的重要性可以与此相比。\x3cbr\x3e-- \x3ca href=\x22https:\/\/twitter.com\/izs\/status\/766697131646201858\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eissac\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3eModule 的规范是完工了的，只是对于模块如何加载和解析留给了“实现环境决定”——按历史经验，问题往往就出现在这一环。当然了不是烫手山芋 W3C 也不会就这么轻松甩开对吧，事实上这也不是 W3C 一家的事情，牵涉到 TC39、Node 技术委员会、Node 和前端两个开发社群，以及 npm 公司。\x3c\/p\x3e\n\x3cp\x3e故事很长，我们从头说起。\x3ccode\x3eimport\x3c\/code\x3e 和 \x3ccode\x3eexport\x3c\/code\x3e 的语法规范很明确，模块的解析器 V8 早已实现，万事俱备只欠加载。区区加载能有多麻烦？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eModule 的特性\x3c\/h2\x3e\n\x3cp\x3e在新规范下，JavaScript 程序划分成两种类型：脚本（我们以前写的传统JS）和模块（ES规范中新定义的 Module），模块有四项于脚本不同的特性：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e强制严格模式（无法取消）\x3c\/li\x3e\n\x3cli\x3e执行环境在一个非全局的作用域中\x3c\/li\x3e\n\x3cli\x3e可以使用 \x3ccode\x3eimport\x3c\/code\x3e 导入其他 Module 的 binding\x3c\/li\x3e\n\x3cli\x3e可以使用 \x3ccode\x3eexport\x3c\/code\x3e 导出本 Module 的 binding\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e看上去规则简单明白，但是要让一个解析器（parser）区分兼容这两种模式还挺复杂的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e解析器的难题\x3c\/h2\x3e\n\x3cblockquote\x3e看看代码中是否包含 \x3ccode\x3eimport\x3c\/code\x3e 和 \x3ccode\x3eexport\x3c\/code\x3e 关键字不就可以判断它的类型了么？\x3c\/blockquote\x3e\n\x3cp\x3e不行。首先猜测用户意图是个危险行为，如果你猜对了，就更加掩盖了猜错可能会造成的风险。\x3c\/p\x3e\n\x3cp\x3e而严格模式，除了运行时的一些要求之外还定义了几个语法错误：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e使用 \x3ccode\x3ewith\x3c\/code\x3e 关键字；\x3c\/li\x3e\n\x3cli\x3e使用八进制字面量（如 \x3ccode\x3e010\x3c\/code\x3e）；\x3c\/li\x3e\n\x3cli\x3e函数参数重名；\x3c\/li\x3e\n\x3cli\x3e对象属性重名（仅在 ES5 环境。ES6 取消了此错误）；\x3c\/li\x3e\n\x3cli\x3e使用 \x3ccode\x3eimplements\x3c\/code\x3e、\x3ccode\x3einterface\x3c\/code\x3e、\x3ccode\x3elet\x3c\/code\x3e、\x3ccode\x3epackage\x3c\/code\x3e、\x3ccode\x3eprivate\x3c\/code\x3e、\x3ccode\x3eprotected\x3c\/code\x3e、\x3ccode\x3epublic\x3c\/code\x3e、\x3ccode\x3estatic\x3c\/code\x3e 或 \x3ccode\x3eyield\x3c\/code\x3e 作为标识符。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这些语法错误需要在解析时就抛出来。所以如果以脚本模式解析到了文件末尾才发现有 \x3ccode\x3eexport\x3c\/code\x3e，就得从头重新解析整个文件来捕捉上述语法错误。\x3c\/p\x3e\n\x3cp\x3e那我们换一条路，开始先假定为模块进行解析代码。既然 Module 语法相当于严格模式 \x2b 导入导出 (\x3ccode\x3eimport\x3c\/code\x3e 和 \x3ccode\x3eexport\x3c\/code\x3e)，我们可以用脚本模式 \x2b 导入导出的语法来解析整个文件。然而这种解析规则已经超越了规范定义，这么扭曲的路线可以预见它成为 Bug 源泉的样子。\x3c\/p\x3e\n\x3cp\x3e危险但不是不可能。OK 真正的麻烦来了：按照规范 \x3ccode\x3eimport\x3c\/code\x3e 和 \x3ccode\x3eexport\x3c\/code\x3e 都是可选的——你可以写一个 Module，既不导入也不导出任何东西，它只是对全局作用域做些小动作，比如这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 一个合法的 Module\nwindow.addEventListener(\x26quot;load\x26quot;, function() {\n    console.log(\x26quot;Window is loaded\x26quot;);\n});\n\/\/ WAT!\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个合法的 Module\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22load\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Window is loaded\x22\x3c\/span\x3e);\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ WAT!\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e总的来说，包含 \x3ccode\x3eimport\x3c\/code\x3e 或 \x3ccode\x3eexport\x3c\/code\x3e 表明它一定是个 Module，但没有这两个关键字却不能证明它不是 Module。 ╮(╯_╰)╭\x3c\/p\x3e\n\x3cp\x3e区分 JavaScript 文件类型的任务没法放在解析器里自动完成，我们需要在解析文件之前就知道它的类型。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e浏览器的办法\x3c\/h2\x3e\n\x3cp\x3e这就是为什么浏览器的模块引用是这个写法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript type=\x26quot;module\x26quot; src=\x26quot;foo.js\x26quot;\x3e\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22module\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22foo.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当浏览器开始加载这个 \x3ccode\x3efoo.js\x3c\/code\x3e，它会边加载边解析，碰到 \x3ccode\x3eimport { bar } from \x27.\/bar.js\x27\x3c\/code\x3e 的第一时间开始加载依赖的 \x3ccode\x3ebar.js\x3c\/code\x3e，加载完之后对其解析，检查其中是否导出了 \x3ccode\x3ebar\x3c\/code\x3e。如此往复完成整个 Module 的解析。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eNode.js 呢\x3c\/h2\x3e\n\x3cp\x3e到了 Node.js，新的问题来了。\x3c\/p\x3e\n\x3cp\x3e作为\x3ca href=\x22http:\/\/www.modulecounts.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e世界上最大的\x3c\/a\x3e软件包仓库，npm 中现有的软件包都是 CommonJS 规范。ES Module 需要能够与 CommonJS 模块共存，允许开发者们逐步转向新的语法。\x3c\/p\x3e\n\x3cp\x3e所谓的共存，主要是指 \x3ccode\x3eimport { foobar } from \x27foobar\x27\x3c\/code\x3e 语法要支持 CJS Module 和 ES Module 两种包格式——如果 \x3ccode\x3eimport\x3c\/code\x3e 只能用来导入 ES Module 而 \x3ccode\x3erequire\x3c\/code\x3e 可以导入任意模块，那么所有人都会用 \x3ccode\x3erequire\x3c\/code\x3e；如果 \x3ccode\x3eimport\x3c\/code\x3e 和 \x3ccode\x3erequire\x3c\/code\x3e 各自负责导入各自的格式，那么开发者就需要知道所有依赖的库的格式，使用相应语法来导入它，并且在依赖的库们更换到新格式的时候修改自己的代码去兼容……在可预见的 CommonJS -\x26gt; ES Module 漫长过渡期里这样的负担对社区而言不可接受。\x3c\/p\x3e\n\x3cp\x3e为此社区提出了不少方案，（好消息）经过大量的讨论之后现在已经集中到两个选择还在讨论：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cstrong\x3e解析器自动检测\x3c\/strong\x3e。最大的好处是对用户而言透明，可惜原因如前所述，此方案已否定。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e使用\x3c\/strong\x3e \x3ccode\x3e\x22use module\x22\x3c\/code\x3e \x3cstrong\x3e标注\x3c\/strong\x3e。一想到 JS 的未来永远都要在文件开头贴这么个膏药大家就不能忍了。否定。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e新的文件后缀\x3c\/strong\x3e \x3ccode\x3e.jsm\x3c\/code\x3e。主要问题是现有社区工具链全部需要更新才能支持，另外和浏览器实现的统一也要考虑。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e在\x3c\/strong\x3e \x3ccode\x3epackage.json\x3c\/code\x3e \x3cstrong\x3e上发挥\x3c\/strong\x3e。这个门类下的提议就更多了，比如添加一个 \x3ccode\x3emodule\x3c\/code\x3e 字段逐步替代掉 \x3ccode\x3emain\x3c\/code\x3e：\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    \/\/ ...\n    \x26quot;module\x26quot;: \x26quot;lib\/index.js\x26quot;,\n    \x26quot;main\x26quot;: \x26quot;old\/index.js\x26quot;,\n    \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e\x22module\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22lib\/index.js\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x22main\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22old\/index.js\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个方案只适用单入口的情况，对多文件（比如 \x3ccode\x3erequire(\x27foo\/bar.js\x27)\x3c\/code\x3e的场景）就不行了。那就改成 \x3ccode\x3emodules\x3c\/code\x3e 字段（复杂度陡升）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    \/\/ ...\n    \/\/ files:\n    \x26quot;modules\x26quot;: [\x26quot;lib\/hello.js\x26quot;, \x26quot;bin\/hello.js\x26quot;],\n\n    \/\/ directories:\n    \x26quot;modules\x26quot;: [\x26quot;lib\x26quot;, \x26quot;bin\x26quot;],\n\n    \/\/ files and directories:\n    \x26quot;modules\x26quot;: [\x26quot;lib\x26quot;, \x26quot;bin\x26quot;, \x26quot;special.js\x26quot;],\n\n    \/\/ if package never uses CJS Modules\n    \x26quot;modules\x26quot;: [\x26quot;.\x26quot;],\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vim\x22\x3e\x3ccode\x3e{\n    \/\/ ...\n    \/\/ \x3cspan class=\x22hljs-keyword\x22\x3efile\x3c\/span\x3e\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e\x22modules\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22lib\/hello.js\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22bin\/hello.js\x22\x3c\/span\x3e],\n\n    \/\/ directorie\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e\x22modules\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22lib\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22bin\x22\x3c\/span\x3e],\n\n    \/\/ \x3cspan class=\x22hljs-keyword\x22\x3efiles\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eand\x3c\/span\x3e directorie\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e\x22modules\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22lib\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22bin\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22special.js\x22\x3c\/span\x3e],\n\n    \/\/ \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e package never uses CJS Modules\n    \x3cspan class=\x22hljs-string\x22\x3e\x22modules\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22.\x22\x3c\/span\x3e],\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这还没完，更多方案就不详述了，大家可以到 \x3ca href=\x22https:\/\/github.com\/nodejs\/node\/wiki\/ES6-Module-Detection-in-Node#option-4-meta-in-packagejson\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNode.js Wiki\x3c\/a\x3e 上查看。\x3c\/p\x3e\n\x3cp\x3e就个人偏好而言，尽管所有的方案都有利有弊，而 \x3ccode\x3epackage.json\x3c\/code\x3e 这条路为了兼容各种需求，修改版的提案已经越来越复杂，比较起来 \x3ccode\x3e.jsm\x3c\/code\x3e 后缀倒是愈发显得简单清晰了。我更喜欢这个干净的解决方案。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e现在的进展（2016.04.15）\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;script type=\x22module\x22 \/\x26gt;\x3c\/code\x3e 已经\x3ca href=\x22https:\/\/github.com\/whatwg\/html\/pull\/443\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e加入 HTML 规范\x3c\/a\x3e，WhatWG 刚刚发了\x3ca href=\x22https:\/\/blog.whatwg.org\/js-modules\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e一篇文章\x3c\/a\x3e讲述他们如何经过艰苦卓绝的努力达成这一目标，接下来就看浏览器厂商实现了。\x3c\/p\x3e\n\x3cp\x3e除此之外 WhatWG 手上还有一个 ES Module loader 规范，用于指定 Module 的动态加载方式。它曾经是 \x3ca href=\x22http:\/\/wiki.ecmascript.org\/doku.php?id=harmony:specification_drafts#august_24_2014_draft_rev_27\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eES6 草案的一部分\x3c\/a\x3e，但因为 ES2015 “要赶着发布来不及了”不幸被砍，目前\x3ca href=\x22https:\/\/github.com\/whatwg\/loader\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e归属 WhatWG\x3c\/a\x3e \x3ca href=\x22https:\/\/github.com\/ModuleLoader\/es6-module-loader\/issues\/381\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e推进\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3eNode.js 这边，在相当一段时间里我们还要借助 transpiler 来体验 ES Module。这件事需要 V8、Node.js、WhatWG 共同协调完成。\x3c\/p\x3e\n\x3cp\x3e\x3cdel\x3e按计划\x3c\/del\x3e本月 Node.js 发布 6.0，\x3cdel\x3e顺利的话可以\x3c\/del\x3e 确定\x3ca href=\x22https:\/\/github.com\/nodejs\/node\/issues\/5355\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e集成 V8 5.0\x3c\/a\x3e（BTW，一天后 V8 发布了 5.1），对 ES2015 的特性支持\x3ca href=\x22http:\/\/v8project.blogspot.com\/2016\/03\/v8-release-50.html?showComment=1458404287701#c475074936038102803\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e达到 93%\x3c\/a\x3e——看来 ES Module 很可能会成为 “The last ES2015 feature” 了。\x3c\/p\x3e\n\x3cp\x3e关注 ES Module 的进展，还可以看看几个地方：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eNode 社区提案和讨论：\x3ca href=\x22https:\/\/github.com\/nodejs\/node-eps\/pull\/3\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/nodejs\/nod...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eV8 的实现：\x3ca href=\x22https:\/\/bugs.chromium.org\/p\/v8\/issues\/detail?id=1569\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/bugs.chromium.org\/p\/v...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eBlink 的实现：\x3ca href=\x22https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=594639\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/bugs.chromium.org\/p\/c...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e愿 ES Module 早日到来。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eUpdates\x3c\/h2\x3e\n\x3cp\x3e关于 ES Module 在 Node.js 环境下的识别方案，从一月份 bmeck 提出提案开始社区就持续沟通和争论，以下是相关进展更新。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e2016.01.08\x3c\/strong\x3e\x3cbr\x3ebmeck 提出关于 \x3ca href=\x22https:\/\/github.com\/nodejs\/node-eps\/commit\/1beb6c7548f70da4de67daa7a7c8f54d6bebe651\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eES Module 的提案\x3c\/a\x3e（增加新后缀\x3ccode\x3e.mjs\x3c\/code\x3e），社区讨论开始。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2016.02.06\x3c\/strong\x3e\x3cbr\x3e社区提的方案归纳起来，有\x3ca href=\x22https:\/\/github.com\/nodejs\/node-eps\/pull\/3#issuecomment-180426207\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e四个方向\x3c\/a\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2016.04.15\x3c\/strong\x3e\x3cbr\x3e本文发布的日子。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2016.04.20\x3c\/strong\x3e\x3cbr\x3e经过两个月的密集讨论，四个方向只剩下两个存活：\x3ccode\x3e.mjs\x3c\/code\x3e 派和 \x3ccode\x3epackage.json\x3c\/code\x3e 派，然而这两派的争论非常激烈。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2016.04.27\x3c\/strong\x3e\x3cbr\x3e鉴于 \x3ccode\x3e.mjs\x3c\/code\x3e 已经在正式提案中，倘若讨论持续僵持不下，不出意外 \x3ccode\x3e.mjs\x3c\/code\x3e 将会随着时间推移而正式成为规范。怀着这样的危机感，\x3ccode\x3epackage.json\x3c\/code\x3e 派发起了 \x3ca href=\x22https:\/\/github.com\/dherman\/defense-of-dot-js\/blob\/master\/proposal.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIn defense of dot js\x3c\/a\x3e 来抗衡 \x3ccode\x3e.mjs\x3c\/code\x3e 的提案，要求保持 \x3ccode\x3e.js\x3c\/code\x3e 后缀不变而使用 \x3ccode\x3epackage.json\x3c\/code\x3e 来识别 ES Module。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2016.06.14\x3c\/strong\x3e\x3cbr\x3e重大转折！bmeck 提出一个新的方案 \x3ca href=\x22https:\/\/github.com\/bmeck\/UnambiguousJavaScriptGrammar\/commit\/7a17303054aef09e6079cdd0b0f910e3f7eedbdf\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUnambiguousJavaScriptGrammar\x3c\/a\x3e：既然两边的纠结都是因为无法从文件本身识别 ES Module 而起，不妨调整一点语法细节（ES Module 中的 \x3ccode\x3eexports\x3c\/code\x3e 语句不再是可选的，至少有一句 \x3ccode\x3eexports {}\x3c\/code\x3e 来表明该文件是个 ES Module），两派的争论就这么迎刃而解了！\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2016.07.06\x3c\/strong\x3e\x3cbr\x3e经过 Node.js TSC 的讨论，Unambiguous JavaScript Grammar 方案\x3ca href=\x22https:\/\/github.com\/bmeck\/UnambiguousJavaScriptGrammar\/commit\/abee4845471f12706e2b208f3163253f8c582d97\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e正式加入提议（proposal）\x3c\/a\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2016.07.07\x3c\/strong\x3e\x3cbr\x3e虽然 Unambiguous JavaScript Grammar \x3ca href=\x22https:\/\/github.com\/nodejs\/node-eps\/blob\/master\/002-es6-modules.md#51-determining-if-source-is-an-es-module\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e加入了 Node.js 的草案提案(5.1章)\x3c\/a\x3e，但是考虑到距离 TC39 的七月会议只剩下一周时间，而 Node.js 这边希望做更充分的调研和测试再进行讨论，所以\x3ca href=\x22https:\/\/github.com\/tc39\/agendas\/pull\/198\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从这次 TC39 的议程中拿掉了\x3c\/a\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2016.09.06\x3c\/strong\x3e\x3cbr\x3eDomenic 提了 \x3ca href=\x22https:\/\/github.com\/tc39\/proposal-dynamic-import\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eimport()\x3c\/code\x3e\x3c\/a\x3e 作为动态加载的方案，有望取代 \x3ccode\x3eSystem.import()\x3c\/code\x3e 或 \x3ccode\x3eSystem.loader.import()\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2016.09.17\x3c\/strong\x3e\x3cbr\x3eES Module 再次\x3ca href=\x22https:\/\/github.com\/tc39\/agendas\/pull\/214#issuecomment-243929423\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e提上 TC39 的议事日程\x3c\/a\x3e，相关的还有\x3ca href=\x22https:\/\/github.com\/tc39\/ecma262\/issues\/395\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e内建模块\x3c\/a\x3e和 \x3ccode\x3eimport()\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e2016.09.30\x3c\/strong\x3e\x3cbr\x3eTC39 9月碰头会的与会者纷纷表示这次会议进展令人愉快，\x3ca href=\x22https:\/\/hackernoon.com\/node-js-tc-39-and-modules-a1118aecf95e\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e会议内容汇总在此\x3c\/a\x3e，以及\x3ca href=\x22https:\/\/medium.com\/@awbjs\/follow-up-tc39-meets-node-js-modules-76fdea278370\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e一些补充\x3c\/a\x3e。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eNode.js 开发者想要提出一些修改规范的建议，也不知道合适不合适，沟通之后发现 TC39 是非常关心和在意每个社区的需求的（大家相谈甚欢）。\x3c\/li\x3e\n\x3cli\x3e原本的 ES 规范要求模块加载过程需要先完成静态 parse 然后再 evaluate，但是现在的 Node.js CommonJS 模块无法满足这个要求（CJS 模块必须 evaluate 之后才知道 exports 的是什么）。讨论下来规范将会改为允许 parse 过程在碰到 import CJS 模块时进入一个挂起的状态，等待依赖树中的 CJS 模块 evaluate 之后再完成 parse。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e对模块类型的检测目前是三个方案选项：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eUnambiguous JavaScript Grammar 看上去比较简单，但实现起来还是有不少坑；\x3c\/li\x3e\n\x3cli\x3epackage.json 的办法比较累赘，局限也多；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.mjs\x3c\/code\x3e 的方案最简单，看来是最可行的，而且也跟 Node.js 现有方式一致（用后缀 \x3ccode\x3e.node\x3c\/code\x3e、\x3ccode\x3e.json\x3c\/code\x3e、\x3ccode\x3e.js\x3c\/code\x3e来区分加载类型）。除非 Unambiguous JavaScript Grammar 的实现问题都解决掉，否则最终方案就是它了。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eimport()\x3c\/code\x3e 大家都觉得没问题，稳步推进中。\x3c\/li\x3e\n\x3cli\x3e由于 ES Module 的静态特性，以前给 CJS 模块做动态 Mock、MonkeyPatch 的方式都不行了。不过解决办法也有，一是在加载阶段提供钩子，二是允许对已经加载的模块做热替换。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e2017.02.12\x3c\/strong\x3e\x3cbr\x3eNode.js CTC 和 TC39 的讨论：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e由于 ES6 模块的异步特性，require() 将无法加载 ES6 模块。\x3c\/li\x3e\n\x3cli\x3eBabel 目前支持的 \x3ccode\x3eimport { foo } from \x27node-cjs-module\x27\x3c\/code\x3e 也不符合规范，想 \x3ccode\x3eimport\x3c\/code\x3e 一个 NCJS 模块的话只能 \x3ccode\x3eimport m from \x27node-cjs-module\x27\x3c\/code\x3e 然后 \x3ccode\x3em.foo()\x3c\/code\x3e 调用。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e.mjs\x3c\/code\x3e 是问题最少的选择。\x3c\/li\x3e\n\x3cli\x3e（悲伤的消息来了）就目前剩余的工作内容估计，距离 ES6 Module 最终实现大约还有至少一年的时间（往好的一面想，终于看得到 timeline 了）。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2017.05.10\x3c\/strong\x3e\x3cbr\x3ebmeck \x3ca href=\x22https:\/\/twitter.com\/bradleymeck\/status\/862059788359827456\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e在 Twitter 表示\x3c\/a\x3e已经实现了 \x3ccode\x3e.mjs\x3c\/code\x3e 加载器的原型，在 Node.js v9 中可以用 flag 的方式启用，（希望）在 v10 中正式推出。也就是还有一年的时间，一切顺利的话 2018 年 4 月就能看到 ES Module 正式加入 Node.js LTS。\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e2017.05.11\x3c\/strong\x3e\x3cbr\x3e工具链对 \x3ccode\x3e.mjs\x3c\/code\x3e 后缀的支持都在推进中：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eBabel: \x3ca href=\x22https:\/\/github.com\/babel\/babel\/pull\/5624\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/babel\/babe...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eBabili\/babel-minify already supports .mjs: \x3ca href=\x22https:\/\/github.com\/babel\/babili\/blob\/2b1b16ac05596e65ec77c56a1e3e1b7882991341\/packages\/babili\/src\/fs.js#L6\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/babel\/babi...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eAVA: \x3ca href=\x22https:\/\/github.com\/avajs\/ava\/issues\/631#issuecomment-299106074\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/avajs\/ava\/...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eVisual Studio Code: \x3ca href=\x22https:\/\/github.com\/Microsoft\/vscode\/pull\/25747\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/Microsoft\/...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2018.03.30\x3c\/strong\x3e\x3cbr\x3eNode.js 项目中\x3ca href=\x22https:\/\/github.com\/nodejs\/node\/labels\/ES%20Modules\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e和 ES Module 实现相关的 Issue 和 PR\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e2018.04.25\x3c\/strong\x3e\x3cbr\x3eNode.js 10.0.0 发布，加入了对 ES Module 的实验性支持（需要 \x3ccode\x3e--experimental-modules\x3c\/code\x3e 开启）\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/nodejs\/node\/blob\/master\/doc\/api\/esm.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/nodejs\/nod...\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e参考资料\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.nczonline.net\/blog\/2016\/04\/es6-module-loading-more-complicated-than-you-think\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.nczonline.net\/blo...\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/nodejs\/node\/wiki\/ES6-Module-Detection-in-Node\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/nodejs\/nod...\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/awal.js.org\/blog\/es6\/2015\/09\/10\/state-of-es6-modules.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/awal.js.org\/blog\/es6\/2...\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/es2015-node.js.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/es2015-node.js.org\/\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/medium.com\/@jasnell\/an-update-on-es6-modules-in-node-js-42c958b890c\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/medium.com\/@jasnell\/a...\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/2ality.com\/2017\/05\/es-module-specifiers.html#support-for-mjs-in-tools\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/2ality.com\/2017\/05\/es-...\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>为何 ES Module 如此姗姗来迟</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000004940294">https://segmentfault.com/a/1190000004940294</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/b067o3b5fd/" target="_blank">https://alili.tech/archive/b067o3b5fd/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>