<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="1625行，解开 underscore.js 的面纱 - 第六章"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>1625行，解开 underscore.js 的面纱 - 第六章 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/23ackmd55ay/",
				"appid": "1613049289050283", 
				"title": "1625行，解开 underscore.js 的面纱 - 第六章 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-09T02:30:58"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/dio9qspdezo/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/8oumfi5boo/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f23ackmd55ay%2f&text=1625%e8%a1%8c%ef%bc%8c%e8%a7%a3%e5%bc%80%20underscore.js%20%e7%9a%84%e9%9d%a2%e7%ba%b1%20-%20%e7%ac%ac%e5%85%ad%e7%ab%a0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f23ackmd55ay%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f23ackmd55ay%2f&text=1625%e8%a1%8c%ef%bc%8c%e8%a7%a3%e5%bc%80%20underscore.js%20%e7%9a%84%e9%9d%a2%e7%ba%b1%20-%20%e7%ac%ac%e5%85%ad%e7%ab%a0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f23ackmd55ay%2f&title=1625%e8%a1%8c%ef%bc%8c%e8%a7%a3%e5%bc%80%20underscore.js%20%e7%9a%84%e9%9d%a2%e7%ba%b1%20-%20%e7%ac%ac%e5%85%ad%e7%ab%a0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f23ackmd55ay%2f&is_video=false&description=1625%e8%a1%8c%ef%bc%8c%e8%a7%a3%e5%bc%80%20underscore.js%20%e7%9a%84%e9%9d%a2%e7%ba%b1%20-%20%e7%ac%ac%e5%85%ad%e7%ab%a0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=1625%e8%a1%8c%ef%bc%8c%e8%a7%a3%e5%bc%80%20underscore.js%20%e7%9a%84%e9%9d%a2%e7%ba%b1%20-%20%e7%ac%ac%e5%85%ad%e7%ab%a0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f23ackmd55ay%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f23ackmd55ay%2f&title=1625%e8%a1%8c%ef%bc%8c%e8%a7%a3%e5%bc%80%20underscore.js%20%e7%9a%84%e9%9d%a2%e7%ba%b1%20-%20%e7%ac%ac%e5%85%ad%e7%ab%a0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f23ackmd55ay%2f&title=1625%e8%a1%8c%ef%bc%8c%e8%a7%a3%e5%bc%80%20underscore.js%20%e7%9a%84%e9%9d%a2%e7%ba%b1%20-%20%e7%ac%ac%e5%85%ad%e7%ab%a0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f23ackmd55ay%2f&title=1625%e8%a1%8c%ef%bc%8c%e8%a7%a3%e5%bc%80%20underscore.js%20%e7%9a%84%e9%9d%a2%e7%ba%b1%20-%20%e7%ac%ac%e5%85%ad%e7%ab%a0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f23ackmd55ay%2f&title=1625%e8%a1%8c%ef%bc%8c%e8%a7%a3%e5%bc%80%20underscore.js%20%e7%9a%84%e9%9d%a2%e7%ba%b1%20-%20%e7%ac%ac%e5%85%ad%e7%ab%a0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">1625行，解开 underscore.js 的面纱 - 第六章</h1><div class="meta"><div class="postdate"><time datetime="2019-02-09" itemprop="datePublished">2019-02-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e北京的雨已经断断续续下了好久，昏昏欲睡的躲在家里不愿意出门，火影忍者快要结束了，一拳超人第二季据说还要等好多年，勇者大冒险貌似断更了，我又是在不喜欢海贼王的画风，所以，我该看什么好呢。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e executeBound = function(sourceFunc, boundFunc, \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e, callingContext, \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(callingContext instanceof boundFunc)) \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e sourceFunc.\x3cspan class=\x22hljs-built_in\x22\x3eapply\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e self = baseCreate(sourceFunc.prototype);\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e result = sourceFunc.\x3cspan class=\x22hljs-built_in\x22\x3eapply\x3c\/span\x3e(self, \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.isObject(result)) \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e result;\n    \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e self;\n  };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eexecuteBound 用来构成 \x3ccode\x3e_.bind\x3c\/code\x3e 和 \x3ccode\x3e_.partial\x3c\/code\x3e 两个函数，主要针对的是为了将函数调用模式更改为构造器调用和方法调用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.bind = restArgs(function(func, context, args) {\n    if (!_.isFunction(func)) throw new TypeError(\x27Bind must be called on a function\x27);\n    var bound = restArgs(function(callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-literal\x22\x3e_\x3c\/span\x3e.bind = restArgs(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e(func, context, args) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-literal\x22\x3e_\x3c\/span\x3e.isFunction(func)) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Bind must be called on a function\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bound = restArgs(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e(callArgs) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e executeBound(func, bound, context, \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e, args.concat(callArgs));\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bound;\n  });\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也许我们可以参考下 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Function\/bind\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFunction.prototype.bind()\x3c\/a\x3e，\x3ccode\x3e_.bind\x3c\/code\x3e 函数这个需要仔细讲一下了，先化简：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    _.bind = function(func, context, args) {\n        var length = arguments.length - 2;\n        args = Array(length);\n        for (var index = 0; index \x3c length; index\x2b\x2b) {\n            args[index] = arguments[index \x2b startIndex];\n        }\n        if (!_.isFunction(func)) throw new TypeError(\x27Bind must be called on a function\x27);\n        var bound = function(args_2){\n            args_2 = Array(arguments.length);\n            for (var index = 0; index \x3c arguments.length; index\x2b\x2b) {\n                args_2[index] = arguments[index];\n            }\n            (function(sourceFunc, boundFunc, context, callingContext, args) {\n                if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n                var self = baseCreate(sourceFunc.prototype);\n                var result = sourceFunc.apply(self, args);\n                if (_.isObject(result)) return result;\n                return self;\n          })(func, bound, context, this, args.concat(args_2));\n        };\n        return bound;\n    };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.bind = function(func, \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e = arguments.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e = Array(\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; index \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; index\x2b\x2b) {\n            \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e[index] = arguments[index \x2b startIndex];\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.isFunction(func)) \x3cspan class=\x22hljs-built_in\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e TypeError(\x27Bind must be called on a function\x27);\n        \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e bound = function(args_2){\n            args_2 = Array(arguments.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e);\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; index \x26lt; arguments.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; index\x2b\x2b) {\n                args_2[index] = arguments[index];\n            }\n            (function(sourceFunc, boundFunc, \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e, callingContext, \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e) {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(callingContext instanceof boundFunc)) \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e sourceFunc.\x3cspan class=\x22hljs-built_in\x22\x3eapply\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e);\n                \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e self = baseCreate(sourceFunc.prototype);\n                \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e result = sourceFunc.\x3cspan class=\x22hljs-built_in\x22\x3eapply\x3c\/span\x3e(self, \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e);\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.isObject(result)) \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e result;\n                \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e self;\n          })(func, bound, \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e, this, \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3econcat\x3c\/span\x3e(args_2));\n        };\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e bound;\n    };\x3c\/code\x3e\x3c\/pre\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这样看上去是不是直白很多，官网给它的定义是：\x3ccode\x3e绑定函数 function 到对象 object 上, 也就是无论何时调用函数, 函数里的 this 都指向这个 object.任意可选参数 arguments 可以传递给函数 function , 可以填充函数所需要的参数,这也被称为 partial application。对于没有结合上下文的partial application绑定，请使用partial。\x3c\/code\x3e，怎么听怎么别扭，我们可以这样理解：\x3ccode\x3e_.bind\x3c\/code\x3e 函数是为其传参中的 function 的 this 上绑定相应对象属性，并且同时进行 function 的参数传入，而其中最关键的就是在执行这一系列动作的同时将传入参数 context 绑定到了指向它的 Function 对象本身的 this 身上（可参考函数调用模式与方法调用模式的区别）。官网有个栗子：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   var func = function(greeting){ return greeting \x2b \x27: \x27 \x2b this.name };\n   func = _.bind(func, {name: \x27moe\x27}, \x27hi\x27);\n   func();\n   {\x27hi: moe\x27}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autoit\x22\x3e\x3ccode\x3e   var \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(greeting)\x3c\/span\x3e{ \x3cspan class=\x22hljs-title\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egreeting\x3c\/span\x3e \x2b \x27: \x27 \x2b \x3cspan class=\x22hljs-title\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ename\x3c\/span\x3e };\x3c\/span\x3e\n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3e_\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ebind\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(func, {name: \x3cspan class=\x22hljs-string\x22\x3e\x27moe\x27\x3c\/span\x3e}, \x3cspan class=\x22hljs-string\x22\x3e\x27hi\x27\x3c\/span\x3e)\x3c\/span\x3e;\x3c\/span\x3e\n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;\x3c\/span\x3e\n   {\x3cspan class=\x22hljs-string\x22\x3e\x27hi: moe\x27\x3c\/span\x3e}\x3c\/code\x3e\x3c\/pre\x3e\x3c\/blockquote\x3e\n\x3cp\x3e实际上呢它等同于：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   var func = _.bind(function(greeting){\n           return greeting \x2b \x27: \x27 \x2b this.name;\n       },\n       {name: \x27moe\x27},\n       \x27hi\x27\n   );\n   func();\n   {\x27hi: moe\x27}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs go\x22\x3e\x3ccode\x3e   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e = _.\x3cspan class=\x22hljs-title\x22\x3ebind\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(function(greeting)\x3c\/span\x3e\x3c\/span\x3e{\n           \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e greeting \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27: \x27\x3c\/span\x3e \x2b this.name;\n       },\n       {name: \x3cspan class=\x22hljs-string\x22\x3e\x27moe\x27\x3c\/span\x3e},\n       \x3cspan class=\x22hljs-string\x22\x3e\x27hi\x27\x3c\/span\x3e\n   );\n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;\x3c\/span\x3e\n   {\x3cspan class=\x22hljs-string\x22\x3e\x27hi: moe\x27\x3c\/span\x3e}\x3c\/code\x3e\x3c\/pre\x3e\x3c\/blockquote\x3e\n\x3cp\x3e结合前面简化的 \x3ccode\x3e_.bind\x3c\/code\x3e 代码示例可知这个函数的核心思想就是先通过 \x3ccode\x3e_.bind\x3c\/code\x3e 初始化的时候优化第3\x2b个参数 args，为什么叫 \x3ccode\x3e3\x2b\x3c\/code\x3e 呢，因为从第三个参数开始，可能是不限定的参数数量，所以从第三个开始到最后一个参数同一处理为一个数组 args。\x3cbr\x3e紧接着就是执行刚才初始化过后的函数了，当 \x3ccode\x3efunc();\x3c\/code\x3e 的时候也就是开始执行 \x3ccode\x3e_.bind\x3c\/code\x3e 中的 bound 函数。bound 允许传递参数并且其参数会被 push 到 args 中，具体实现参看上面的简化代码 \x3ccode\x3eargs.concat(args_2)\x3c\/code\x3e。这里我们有几个需要注意的点，其一是 \x3ccode\x3ecallingContext instanceof boundFunc\x3c\/code\x3e，之前我们讲过 instanceof 的神奇用法，在这里它用与判断 \x3ccode\x3ebound\x3c\/code\x3e 中的 this 的指向是否继承于 bound。我们一定知道 this 指向的四个情况，如下：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var obj = {};\nvar func = function (){console.log(this);};\nfunc();\nnew func();\nobj.func = func;\nobj.func();\nfunc.apply([\x27this is parameter\x27]);\nfunc.call([\x27this is parameter\x27]);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autoit\x22\x3e\x3ccode\x3evar obj = {}\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nvar \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e{\x3cspan class=\x22hljs-title\x22\x3econsole\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3elog\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(this)\x3c\/span\x3e;};\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;\x3c\/span\x3e\nnew \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;\x3c\/span\x3e\nobj.\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e;\x3c\/span\x3e\nobj.\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e()\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eapply\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e([\x3cspan class=\x22hljs-string\x22\x3e\x27this is parameter\x27\x3c\/span\x3e])\x3c\/span\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ecall\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e([\x3cspan class=\x22hljs-string\x22\x3e\x27this is parameter\x27\x3c\/span\x3e])\x3c\/span\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3c\/blockquote\x3e\n\x3cp\x3e输出结果为：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Window {external: Object, chrome: Object, document: document, alogObjectConfig: Object, alogObjectName: \x26quot;alog\x26quot;…}\nfunc {}\nObject {}\n[\x26quot;this is parameter\x26quot;]\n[\x26quot;this is parameter\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3eWindow {\x3cspan class=\x22hljs-keyword\x22\x3eexternal\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e, chrome: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e, alogObjectConfig: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e, alogObjectName: \x3cspan class=\x22hljs-string\x22\x3e\x22alog\x22\x3c\/span\x3e…}\nfunc {}\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e {}\n[\x3cspan class=\x22hljs-string\x22\x3e\x22this is parameter\x22\x3c\/span\x3e]\n[\x3cspan class=\x22hljs-string\x22\x3e\x22this is parameter\x22\x3c\/span\x3e]\x3c\/code\x3e\x3c\/pre\x3e\x3c\/blockquote\x3e\n\x3cp\x3e分别代表四种情况：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e函数调用模式：指向 \x3ccode\x3eGlobal\x3c\/code\x3e，浏览器客户端即 window；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e方法调用模式：指向对象本身；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e构造器调用模式：指向为新构造的对象，继承自原 Function 对象；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eapply 或 call 调用模式：指向传入的参数。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里还有一些非常好的资料：\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Operators\/this\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ethis\x3c\/a\x3e、\x3ca href=\x22http:\/\/yehudakatz.com\/2011\/08\/11\/understanding-javascript-function-invocation-and-this\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUnderstanding JavaScript Function Invocation and \x22this\x22\x3c\/a\x3e，在这里我要说一下我在推库上看到一篇关于 this 的介绍文章说：\x3ccode\x3e“比较系统的分类是《JavaScript语言精粹》中的，分为函数调用模式（this绑定全局对象window）和方法调用模式（this绑定调用方法的主体）”\x3c\/code\x3e，我把《\x3ca href=\x22https:\/\/www.amazon.cn\/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%E2%80%A2%E5%85%8B%E7%BD%97%E5%85%8B%E7%A6%8F%E5%BE%B7\/dp\/B0097CON2S\/ref=sr_1_1?ie=UTF8\x26amp;qid=1465722328\x26amp;sr=8-1\x26amp;keywords=JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript语言精粹\x3c\/a\x3e》这本书从头到尾翻看了好几遍，实际上它原文是这样说的：\x3ccode\x3e“在 JAVASCRIPT 中一共有4种调用模式：方法调用模式、函数调用模式、构造器调用模式和 apply 调用模式。”\x3c\/code\x3e，具体叙述在原书的P27～P30页，感兴趣的朋友可以看下，在给大家看一个彩蛋，\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch07.html#strict_mode\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e严格模式下的 this\x3c\/a\x3e。紧接上文，当 \x3ccode\x3ebound\x3c\/code\x3e 中的 this 的指向是否继承于 bound 函数的时候说明是使用了 \x3ccode\x3enew\x3c\/code\x3e 关键字的构造器调用模式调用了 \x3ccode\x3e_.bind\x3c\/code\x3e 函数，则继续执行 executeBound 函数中的 baseCreate 创建基本函数然后进行一系列的操作，其实说到底 baseCreate 的目的就是为了保证传入参数 Function 的 this 的干净。\x3cbr\x3e另外一个需要注意的地方是官网示例的暗示（特蛋疼的暗示），我扩展了一下：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   var func = function(){ return JSON.stringify(arguments) \x2b \x27: \x27 \x2b this.name };\n   func = _.bind(func, {name: \x27moe\x27}, \x27hi\x27);\n   func();\n   func = _.bind(func, {name: \x27moe2\x27}, \x27hi2\x27);\n   func();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autoit\x22\x3e\x3ccode\x3e   var \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e{ \x3cspan class=\x22hljs-title\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eJSON\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3estringify\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(arguments)\x3c\/span\x3e \x2b \x27: \x27 \x2b \x3cspan class=\x22hljs-title\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ename\x3c\/span\x3e };\x3c\/span\x3e\n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3e_\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ebind\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(func, {name: \x3cspan class=\x22hljs-string\x22\x3e\x27moe\x27\x3c\/span\x3e}, \x3cspan class=\x22hljs-string\x22\x3e\x27hi\x27\x3c\/span\x3e)\x3c\/span\x3e;\x3c\/span\x3e\n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;\x3c\/span\x3e\n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3e_\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ebind\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(func, {name: \x3cspan class=\x22hljs-string\x22\x3e\x27moe2\x27\x3c\/span\x3e}, \x3cspan class=\x22hljs-string\x22\x3e\x27hi2\x27\x3c\/span\x3e)\x3c\/span\x3e;\x3c\/span\x3e\n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3c\/blockquote\x3e\n\x3cp\x3e输出结果：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   \x26quot;{\x26quot;0\x26quot;:\x26quot;hi\x26quot;}: moe\x26quot;\n   \x26quot;{\x26quot;0\x26quot;:\x26quot;hi\x26quot;,\x26quot;1\x26quot;:\x26quot;hi2\x26quot;}: moe\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e   \x3cspan class=\x22hljs-string\x22\x3e\x22{\x22\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22:\x22\x3c\/span\x3ehi\x3cspan class=\x22hljs-string\x22\x3e\x22}: moe\x22\x3c\/span\x3e\n   \x3cspan class=\x22hljs-string\x22\x3e\x22{\x22\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22:\x22\x3c\/span\x3ehi\x3cspan class=\x22hljs-string\x22\x3e\x22,\x22\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22:\x22\x3c\/span\x3ehi2\x3cspan class=\x22hljs-string\x22\x3e\x22}: moe\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3c\/blockquote\x3e\n\x3cp\x3e可能有些不明就里的同学会问这是为什么啊，怎么 \x3ccode\x3ethis.name\x3c\/code\x3e 的值没有变化呢。实际上我们第一个 \x3ccode\x3e_.bind\x3c\/code\x3e 是正常的函数绑定，而第二个 \x3ccode\x3efunc = _.bind(func, {name: \x27moe2\x27}, \x27hi2\x27);\x3c\/code\x3e 是将上一个 \x3ccode\x3e_.bind\x3c\/code\x3e 作为了 Function 参数传入到了新的 \x3ccode\x3e_.bind\x3c\/code\x3e 中，而本来的函数 func 作为第一个 \x3ccode\x3e_.bind\x3c\/code\x3e 的 func 参数一直传递到第二个 \x3ccode\x3e_.bind\x3c\/code\x3e 中，但是中间的 this.name 却被绑定到了第一个 \x3ccode\x3e_.bind\x3c\/code\x3e 上面而不是第一个 \x3ccode\x3e_.bind\x3c\/code\x3e 中的 func 上。有一点绕口。用个代码介绍下，第二个 \x3ccode\x3e_.bind\x3c\/code\x3e 的情况是这样子的：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 func = _.bind(function(\n       function(greeting){\n           return greeting \x2b \x27: \x27 \x2b this.name;\n      },\n       context,\n       args\n   ) {\n        var length = arguments.length - 2;\n        args = Array(length);\n        for (var index = 0; index \x3c length; index\x2b\x2b) {\n            args[index] = arguments[index \x2b startIndex];\n        }\n        if (!_.isFunction(func)) throw new TypeError(\x27Bind must be called on a function\x27);\n        var bound = function(args_2){\n            args_2 = Array(arguments.length);\n            for (var index = 0; index \x3c arguments.length; index\x2b\x2b) {\n                args_2[index] = arguments[index];\n            }\n            (function(sourceFunc, boundFunc, context, callingContext, args) {\n                if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n                var self = baseCreate(sourceFunc.prototype);\n                var result = sourceFunc.apply(self, args);\n                if (_.isObject(result)) return result;\n                return self;\n          })(func, bound, context, this, args.concat(args_2));\n        };\n        return bound;\n    },\n       {name: \x27moe2\x27},\n       \x27hi2\x27\n   );\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e func = _.bind(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\n       function(greeting\x3c\/span\x3e)\x3c\/span\x3e{\n           \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e greeting \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27: \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;\n      },\n       context,\n       args\n   ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e length = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length - \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n        args = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(length);\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; index \x26lt; length; index\x2b\x2b) {\n            args[index] = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e[index \x2b startIndex];\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!_.isFunction(func)) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eTypeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Bind must be called on a function\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bound = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eargs_2\x3c\/span\x3e)\x3c\/span\x3e{\n            args_2 = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length);\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; index \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length; index\x2b\x2b) {\n                args_2[index] = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e[index];\n            }\n            (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esourceFunc, boundFunc, context, callingContext, args\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(callingContext \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e boundFunc)) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e sourceFunc.apply(context, args);\n                \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e self = baseCreate(sourceFunc.prototype);\n                \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = sourceFunc.apply(self, args);\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_.isObject(result)) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e self;\n          })(func, bound, context, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args.concat(args_2));\n        };\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bound;\n    },\n       {\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27moe2\x27\x3c\/span\x3e},\n       \x3cspan class=\x22hljs-string\x22\x3e\x27hi2\x27\x3c\/span\x3e\n   );\x3c\/code\x3e\x3c\/pre\x3e\x3c\/blockquote\x3e\n\x3cp\x3e所以 \x3ccode\x3e_.bind\x3c\/code\x3e 一定要遵循正确的用法，不然真的出错了可能调试都不好发现问题，多层回调嵌套的时候一层套一层，很麻烦。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.partial = restArgs(function(func, boundArgs) {\n    var placeholder = _.partial.placeholder;\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i \x3c length; i\x2b\x2b) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position\x2b\x2b] : boundArgs[i];\n      }\n      while (position \x3c arguments.length) args.push(arguments[position\x2b\x2b]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.partial = restArgs(function(func, boundArgs) {\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e placeholder = \x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.partial.placeholder;\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e bound = function() {\n      \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eposition\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e = boundArgs.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e = Array(\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e[i] = boundArgs[i] === placeholder ? arguments[\x3cspan class=\x22hljs-built_in\x22\x3eposition\x3c\/span\x3e\x2b\x2b] : boundArgs[i];\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eposition\x3c\/span\x3e \x26lt; arguments.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e) \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3epush\x3c\/span\x3e(arguments[\x3cspan class=\x22hljs-built_in\x22\x3eposition\x3c\/span\x3e\x2b\x2b]);\n      \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e executeBound(func, bound, this, this, \x3cspan class=\x22hljs-built_in\x22\x3eargs\x3c\/span\x3e);\n    };\n    \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e bound;\n  });\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.partial\x3c\/code\x3e 函数的核心思想与 \x3ccode\x3e_.bind\x3c\/code\x3e 相同，都是为了解决 this 指向的问题，区别在于 \x3ccode\x3e_.partial\x3c\/code\x3e 不需要对 this 上的值做什么处理。用法上我觉得 \x3ccode\x3e_.partial\x3c\/code\x3e 看上去更怪异一些，也许用来做一些特定的计算可能更合适些。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.partial.placeholder = _;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coq\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-keyword\x22\x3e_\x3c\/span\x3e.partial.placeholder = \x3cspan class=\x22hljs-keyword\x22\x3e_\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e设置 \x3ccode\x3e_.partial.placeholder\x3c\/code\x3e 为 \x3ccode\x3e_\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.bindAll = restArgs(function(obj, keys) {\n    keys = flatten(keys, false, false);\n    var index = keys.length;\n    if (index \x3c 1) throw new Error(\x27bindAll must be passed function names\x27);\n    while (index--) {\n      var key = keys[index];\n      obj[key] = _.bind(obj[key], obj);\n    }\n  });\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.bindAll = restArgs(function(obj, keys) {\n    keys = \x3cspan class=\x22hljs-built_in\x22\x3eflatten\x3c\/span\x3e(keys, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e index = keys.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (index \x26lt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) \x3cspan class=\x22hljs-built_in\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e Error(\x27bindAll must be passed function names\x27);\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (index--) {\n      \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e = keys[index];\n      obj[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e] = \x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.bind(obj[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e], obj);\n    }\n  });\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们看到 \x3ccode\x3e_.bindAll\x3c\/code\x3e 函数官网的示例就有点糊涂了：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   var buttonView = {\n     label  : \x27underscore\x27,\n     onClick: function(){ console.log(\x27clicked: \x27 \x2b this.label); },\n     onHover: function(){ console.log(\x27hovering: \x27 \x2b this.label); }\n   };\n   _.bindAll(buttonView, \x27onClick\x27, \x27onHover\x27);\n   buttonView.onClick（);\n   clicked: underscore\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e buttonView = {\n     \x3cspan class=\x22hljs-attr\x22\x3elabel\x3c\/span\x3e  : \x3cspan class=\x22hljs-string\x22\x3e\x27underscore\x27\x3c\/span\x3e,\n     \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27clicked: \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.label); },\n     \x3cspan class=\x22hljs-attr\x22\x3eonHover\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27hovering: \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.label); }\n   };\n   _.bindAll(buttonView, \x3cspan class=\x22hljs-string\x22\x3e\x27onClick\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27onHover\x27\x3c\/span\x3e);\n   buttonView.onClick（);\n   clicked: underscore\x3c\/code\x3e\x3c\/pre\x3e\x3c\/blockquote\x3e\n\x3cp\x3e我们当然知道结果是 \x3ccode\x3eclicked: underscore\x3c\/code\x3e，那么执行 \x3ccode\x3e_.bindAll(buttonView, \x27onClick\x27, \x27onHover\x27);\x3c\/code\x3e 的意义在哪呢，所以说这又是官网坑人的地方了，\x3ccode\x3e_.bindAll\x3c\/code\x3e 的本意是将其传入的第二个及以后的参数放到一个共同的上下文环境里面执行，从而达到 this 指向其第一个参数的本身的目的，而官网的示例为\x3ccode\x3e方法调用模式\x3c\/code\x3e，this 指向已经是 Object 本身了所以看不到变化，但是我们在浏览器控制台查看的话应该能知道 this 上多了 \x3ccode\x3e[[TargetFunction]]: function ()\x3c\/code\x3e、\x3ccode\x3e[[BoundThis]]: Object\x3c\/code\x3e、\x3ccode\x3e[[BoundArgs]]: Array[0]\x3c\/code\x3e 三个参数并且 \x3ccode\x3e[[BoundThis]]\x3c\/code\x3e 恰好是 Object。闲来无事这好看到有人也写了这个问题并举证了一个示例，详见 \x3ca href=\x22http:\/\/blog.bigbinary.com\/2011\/08\/18\/understanding-bind-and-bindall-in-backbone.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUnderstanding bind and bindAll in Backbone.js\x3c\/a\x3e。我 cope 一下：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   function Developer(skill) {\n     this.skill = skill;\n     this.says = function(){\n       console.log(this.skill \x2b \x27 rocks!\x27);\n     }\n   }\n   var john = new Developer(\x27Ruby\x27);\n   _.bindAll(john, \x27says\x27);\n   var func = john.says;\n   func(); \/\/Ruby rocks!\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDeveloper\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eskill\x3c\/span\x3e) \x3c\/span\x3e{\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.skill = skill;\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.says = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n       \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.skill \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 rocks!\x27\x3c\/span\x3e);\n     }\n   }\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e john = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Developer(\x3cspan class=\x22hljs-string\x22\x3e\x27Ruby\x27\x3c\/span\x3e);\n   _.bindAll(john, \x3cspan class=\x22hljs-string\x22\x3e\x27says\x27\x3c\/span\x3e);\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e func = john.says;\n   func(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/Ruby rocks!\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这个\x3ccode\x3e函数调用模式\x3c\/code\x3e的示例正好答疑了 this 指向已经被改变的这个问题。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = \x27\x27 \x2b (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  _.memoize = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efunc, hasher\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e memoize = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cache = memoize.cache;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e address = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e \x2b (hasher ? hasher.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e) : key);\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!_.has(cache, address)) cache[address] = func.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cache[address];\n    };\n    memoize.cache = {};\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e memoize;\n  };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.memoize\x3c\/code\x3e 函数更像是一个可以缓存第一次执行结果的递归函数，我们从源码中可以看到 \x3ccode\x3ememoize.cache = {};\x3c\/code\x3e 就是用来存储计算结果的容器，这里面比较有意思的是 hasher 这个参数，官网释义： \x3ccode\x3ehashFunction\x3c\/code\x3e，实际上就是通过 hashFunction 对传入的 key 值进行处理然后放到 \x3ccode\x3ememoize.cache = {};\x3c\/code\x3e 中，至于怎么处理 hash 也好、md5 也好、或者什么其他的计算加密真值判断增加对象等等都可以通过 hasher 这个传入的回调进行扩展。\x3c\/p\x3e\n\x3cp\x3e————————— 疲惫的分割线 ———————————\x3cbr\x3e这几天北京总在下雨，身体特别的疲惫，状态也不怎么好，所以今天才开始继续更新。\x3cbr\x3e————————— END ———————————\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.delay = restArgs(function(func, wait, args) {\n    return setTimeout(function() {\n      return func.apply(null, args);\n    }, wait);\n  });\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e  _.delay = restArgs(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(func, wait, args)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e func.apply(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, args);\n    }, wait);\n  });\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.delay\x3c\/code\x3e 函数用于处理定时器相关函数，原理是通过 setTimeout 进行二次封装，比较关键的就是 args 参数通过 restArgs 函数处理为一个数组，方便了下一步的 \x3ccode\x3efunc.apply(null, args);\x3c\/code\x3e 传值。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.defer = _.partial(_.delay, _, 1);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.defer = \x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.partial(\x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3edelay\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3e_\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.defer\x3c\/code\x3e 这个函数我们首先可以看到内部应用了 \x3ccode\x3e_.partial\x3c\/code\x3e 并且中间传入参数 \x3ccode\x3e_\x3c\/code\x3e，这意味着当 \x3ccode\x3e_.defer\x3c\/code\x3e 执行的时候传入的参数会被补全到 \x3ccode\x3e_.partial\x3c\/code\x3e 内部 bound 中的 \x3ccode\x3eargs[0]\x3c\/code\x3e 位置，而此时 \x3ccode\x3eargs\x3c\/code\x3e 的值为 \x3ccode\x3e[func, 1]\x3c\/code\x3e并将它传给 \x3ccode\x3e_.delay\x3c\/code\x3e 函数，即 \x3ccode\x3e_.delay.apply(null, args);\x3c\/code\x3e，用着这种方式曲线的设置 setTimeout 函数的 \x3ccode\x3ewait = 1\x3c\/code\x3e，目的就是处理代码复用问题，不然的话完全可以改装一下 \x3ccode\x3e_.delay\x3c\/code\x3e 函数可以更简单的实现这一功能。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    var throttled = function() {\n      var now = _.now();\n      if (!previous \x26amp;\x26amp; options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining \x3c= 0 || remaining \x3e wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout \x26amp;\x26amp; options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n    return throttled;\n  };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nix\x22\x3e\x3ccode\x3e  _.\x3cspan class=\x22hljs-attr\x22\x3ethrottle\x3c\/span\x3e = function(func, wait, options) {\n    var timeout, context, args, result;\n    var \x3cspan class=\x22hljs-attr\x22\x3eprevious\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!options) \x3cspan class=\x22hljs-attr\x22\x3eoptions\x3c\/span\x3e = {};\n    var \x3cspan class=\x22hljs-attr\x22\x3elater\x3c\/span\x3e = function() {\n      \x3cspan class=\x22hljs-attr\x22\x3eprevious\x3c\/span\x3e = options.\x3cspan class=\x22hljs-attr\x22\x3eleading\x3c\/span\x3e === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e ? \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e : _.now();\n      \x3cspan class=\x22hljs-attr\x22\x3etimeout\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-attr\x22\x3eresult\x3c\/span\x3e = func.apply(context, args);\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!timeout) \x3cspan class=\x22hljs-attr\x22\x3econtext\x3c\/span\x3e = \x3cspan class=\x22hljs-attr\x22\x3eargs\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    };\n    var \x3cspan class=\x22hljs-attr\x22\x3ethrottled\x3c\/span\x3e = function() {\n      var \x3cspan class=\x22hljs-attr\x22\x3enow\x3c\/span\x3e = _.now();\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!previous \x26amp;\x26amp; options.\x3cspan class=\x22hljs-attr\x22\x3eleading\x3c\/span\x3e === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e) \x3cspan class=\x22hljs-attr\x22\x3eprevious\x3c\/span\x3e = now;\n      var \x3cspan class=\x22hljs-attr\x22\x3eremaining\x3c\/span\x3e = wait - (now - previous);\n      \x3cspan class=\x22hljs-attr\x22\x3econtext\x3c\/span\x3e = this;\n      \x3cspan class=\x22hljs-attr\x22\x3eargs\x3c\/span\x3e = arguments;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (remaining \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e || remaining \x26gt; wait) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (timeout) {\n          clearTimeout(timeout);\n          \x3cspan class=\x22hljs-attr\x22\x3etimeout\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        }\n        \x3cspan class=\x22hljs-attr\x22\x3eprevious\x3c\/span\x3e = now;\n        \x3cspan class=\x22hljs-attr\x22\x3eresult\x3c\/span\x3e = func.apply(context, args);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!timeout) \x3cspan class=\x22hljs-attr\x22\x3econtext\x3c\/span\x3e = \x3cspan class=\x22hljs-attr\x22\x3eargs\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!timeout \x26amp;\x26amp; options.trailing !== \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-attr\x22\x3etimeout\x3c\/span\x3e = setTimeout(later, remaining);\n      }\n      return result;\n    };\n    throttled.\x3cspan class=\x22hljs-attr\x22\x3ecancel\x3c\/span\x3e = function() {\n      clearTimeout(timeout);\n      \x3cspan class=\x22hljs-attr\x22\x3eprevious\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-attr\x22\x3etimeout\x3c\/span\x3e = \x3cspan class=\x22hljs-attr\x22\x3econtext\x3c\/span\x3e = \x3cspan class=\x22hljs-attr\x22\x3eargs\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    };\n    return throttled;\n  };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.throttle\x3c\/code\x3e 函数可以限制和控制其参数 func 的执行次数和执行时间，思想就是通过 wait、now、previous 和 remaining 进行判断然后分别执行相应的策略。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ewait：使用 \x3ccode\x3e_.throttle\x3c\/code\x3e 函数时传入的时间标识，在每个 wait 毫秒时间段内最多且一定调用一次该函数。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3enow：使用 \x3ccode\x3e_.now()\x3c\/code\x3e 函数获取当前时间戳。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eprevious：用来缓存函数执行时的时间戳，用于后面与下一次执行时的时间戳进行相关判断。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eremaining：缓存 \x3ccode\x3ewait - (now - previous)\x3c\/code\x3e 的差值。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们在看官网介绍可以知道 \x3ccode\x3e_.throttle\x3c\/code\x3e 传递的 options 分四种情况（默认是 \x3ccode\x3e{leading:false,trailing:false}\x3c\/code\x3e）：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e{leading:true,trailing:true}\x3c\/code\x3e：从实例化 \x3ccode\x3e_.throttle\x3c\/code\x3e 的时间开始到执行实例化的函数的时间为止，中间的差值定义为 \x3ccode\x3enow - previous\x3c\/code\x3e，进而得出设定的时间 wait 与 \x3ccode\x3enow - previous\x3c\/code\x3e 的差值 remaining，从而决定怎么执行函数。参考 \x3ca href=\x22http:\/\/www.easyui.info\/third\/underscore\/throttle.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e世纪之光\x3c\/a\x3e 的很有趣的说法，就是第一次可以立即执行，第二次开始将在每 wait 时间内只允许执行一次，为什么会第一次立即执行呢，因为大家设置的 wait 一般都不会太大，所以页面加载过程中一般已经执行了 \x3ccode\x3e_.throttle\x3c\/code\x3e 的实例化，也就是说其 \x3ccode\x3eremaining \x26lt;= 0\x3c\/code\x3e，而后面如果一直执行函数，那么就开始 \x3ccode\x3e0 \x26lt; remaining \x26lt;= wait\x3c\/code\x3e 模式了，\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e{leading:false,trailing:false}\x3c\/code\x3e：这种情况下比较有意思的是 previous 这个参数，在实例化 \x3ccode\x3e_.throttle\x3c\/code\x3e 的时候，\x3ccode\x3eprevious = 0\x3c\/code\x3e，利用了 \x3ccode\x3e!0 === true\x3c\/code\x3e 的特性使 \x3ccode\x3e_.throttle\x3c\/code\x3e 内部并没有执行回调函数 func，所以第一次函数调用失败，在第二次开始 \x3ccode\x3eprevious = now\x3c\/code\x3e （now 为第一次调用的时间戳），所以它也分为两种情况：\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e{leading:true,trailing:false}\x3c\/code\x3e：这种情况下是没有 setTimeout 函数的，因为 \x3ccode\x3eleading:true\x3c\/code\x3e，所以 previous 初始化为 \x3ccode\x3e0\x3c\/code\x3e，意味着第一次执行函数会立即执行，儿后面就要遵循 \x3ccode\x3eremaining \x26lt;= 0 || remaining \x26gt; wait\x3c\/code\x3e 才能执行，也就是说只有第一执行完毕后的时间超过了 wait 才能继续调用函数才能执行（调用是重点），以此类推。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e{leading:false,trailing:true}\x3c\/code\x3e：这种情况由于 \x3ccode\x3eleading:false\x3c\/code\x3e，所以每次 previous 都等于当前调用函数时的时间戳，所以完美的不存在 \x3ccode\x3eremaining \x26lt;= 0 || remaining \x26gt; wait\x3c\/code\x3e 的情况，由此只能通过 setTimeout 执行回调，所以遵循通过 setTimeout 函数设定时间为 remaining 毫秒后执行 \x3ccode\x3e_.throttle\x3c\/code\x3e 函数的回调函数 func，用以达到在规定时间 wait 毫秒时执行函数的目的，并且规定 wait 时间内只执行一次函数。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e其实总结一下就是大概一下两种都存在或者只存在其一的情况：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eremaining \x26lt;= 0\x3c\/code\x3e：立即执行 \x3ccode\x3e_.throttle\x3c\/code\x3e 函数的回调函数 func。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3ccode\x3e0 \x26lt; remaining \x26lt;= wait\x3c\/code\x3e：通过 setTimeout 函数设定时间为 remaining 毫秒后执行 \x3ccode\x3e_.throttle\x3c\/code\x3e 函数的回调函数 func，用以达到在规定时间 wait 毫秒时执行函数的目的，并且规定 wait 时间内只执行一次函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 _.debounce = function(func, wait, immediate) {\n   var timeout, result;\n   var later = function(context, args) {\n     timeout = null;\n     if (args) result = func.apply(context, args);\n   };\n   var debounced = restArgs(function(args) {\n     if (timeout) clearTimeout(timeout);\n     if (immediate) {\n       var callNow = !timeout;\n       timeout = setTimeout(later, wait);\n       if (callNow) result = func.apply(this, args);\n     } else {\n       timeout = _.delay(later, wait, this, args);\n     }\n     return result;\n   });\n   debounced.cancel = function() {\n     clearTimeout(timeout);\n     timeout = null;\n   };\n   return debounced;\n };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e _.debounce = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(func, wait, immediate)\x3c\/span\x3e \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e timeout, result;\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e later = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(context, args)\x3c\/span\x3e \x3c\/span\x3e{\n     timeout = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n     \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (args) result = func.apply(context, args);\n   };\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e debounced = restArgs(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(args)\x3c\/span\x3e \x3c\/span\x3e{\n     \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (timeout) clearTimeout(timeout);\n     \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (immediate) {\n       \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callNow = !timeout;\n       timeout = setTimeout(later, wait);\n       \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (callNow) result = func.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args);\n     } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n       timeout = _.delay(later, wait, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args);\n     }\n     \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n   });\n   debounced.cancel = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n     clearTimeout(timeout);\n     timeout = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n   };\n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e debounced;\n };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3e_.debounce\x3c\/code\x3e 更像是 \x3ccode\x3e_.delay\x3c\/code\x3e 的方言版，当 \x3ccode\x3eimmediate = true\x3c\/code\x3e 的时候通过 \x3ccode\x3evar callNow = !timeout = false\x3c\/code\x3e 达到立即执行回调函数 func 的目的，并用 later 函数限制 规定 wait 时间内不允许在调用函数（later 函数内部 context = args = underfind，其实我们知道 \x3ccode\x3evar later = function(context, args)\x3c\/code\x3e 这个条件是为 \x3ccode\x3e_.delay(later, wait, this, args)\x3c\/code\x3e 准备的）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autoit\x22\x3e\x3ccode\x3e  _.wrap = function(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e, \x3cspan class=\x22hljs-title\x22\x3ewrapper\x3c\/span\x3e) {\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _.partial(wrapper, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e);\x3c\/span\x3e\n  }\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.wrap\x3c\/code\x3e 的两个参数理论上都要求是 Function，我们已经知道 \x3ccode\x3e_.partial\x3c\/code\x3e 是用来在 this 上下功夫的，虽然这里和 this 也没什么太大关系，之所以这里应用了 \x3ccode\x3e_.partial\x3c\/code\x3e 是为了让 func 作为 wrapper 的第一个参数执行，并且通过 executeBound 函数对\x3ccode\x3e函数调用模式\x3c\/code\x3e和\x3ccode\x3e方法调用模式\x3c\/code\x3e做处理。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  _.negate = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epredicate\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !predicate.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n    };\n  };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.negate\x3c\/code\x3e 用来做真值判断。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  _.compose = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e start = args.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = start;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = args[start].apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) result = args[i].call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, result);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n    };\n  };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.compose\x3c\/code\x3e 用于将函数执行结果进行传递，需要注意的是 \x3ccode\x3evar args = arguments;\x3c\/code\x3e 中的 arguments 和 \x3ccode\x3eargs[start].apply(this, arguments);\x3c\/code\x3e 中的 arguments 并不相同就可以了。这个涉及到函数的执行，当每一个函数执行的时候都会形成一个内部的上下文执行环境（传说叫 \x3ccode\x3eExecutionContext\x3c\/code\x3e，这个我还没有考证过），在构建环境的同时生成 arguments 变量和作用域链表等等，这里不像叙述了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.after = function(times, func) {\n    return function() {\n      if (--times \x3c 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  _.after = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etimes, func\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (--times \x26lt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e func.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n      }\n    };\n  };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.after\x3c\/code\x3e 接受两个参数，Number 参数用来限定 \x3ccode\x3e_.after\x3c\/code\x3e 实例化函数的执行次数，说白了就是只有当第 Number 次执行实例化函数的时候才会继续执行 func 回调，这个用来处理遍历 \x3ccode\x3e_.each\x3c\/code\x3e 时某些情况很有用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times \x3e 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times \x3c= 1) func = null;\n      return memo;\n    };\n  };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  _.before = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etimes, func\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e memo;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (--times \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        memo = func.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (times \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) func = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e memo;\n    };\n  };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.before\x3c\/code\x3e，与 \x3ccode\x3e_.after\x3c\/code\x3e 相反，只在规定 Number 参数的次数内以此执行 \x3ccode\x3e_.before\x3c\/code\x3e，超过之后结束。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.once = _.partial(_.before, 2);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coq\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-keyword\x22\x3e_\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eonce\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3e_\x3c\/span\x3e.partial(\x3cspan class=\x22hljs-keyword\x22\x3e_\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3ebefore\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.once\x3c\/code\x3e 创建一个只能调用一次的函数。到这里关于函数相关的源码就结束了，说心里话很多地方看得懂不一定说的懂，说的懂也不一定用的懂，就拿这个 \x3ccode\x3e_.once\x3c\/code\x3e 来讲，它只用了 \x3ccode\x3e_.partial\x3c\/code\x3e 和 \x3ccode\x3e_.before\x3c\/code\x3e 来做文章，用 \x3ccode\x3e_.before\x3c\/code\x3e 限定只能执行一次还好理解，那么为什么一定要用 \x3ccode\x3e_.partial\x3c\/code\x3e 坐下处理呢，其目的真的只是为了让 \x3ccode\x3e2\x3c\/code\x3e 作为 \x3ccode\x3e_.before\x3c\/code\x3e 的第一个参数进行传递过去并将 \x3ccode\x3e_.once\x3c\/code\x3e 的传参作为 \x3ccode\x3earguments[1\x2b]\x3c\/code\x3e 传入么，更深一层考虑，\x3ccode\x3e_.partial\x3c\/code\x3e 函数是不是有处理过 \x3ccode\x3e_.once\x3c\/code\x3e 传递过来的函数的作用域链和 this 相关的情况呢。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  _.restArgs = restArgs;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs abnf\x22\x3e\x3ccode\x3e  _.restArgs = restArgs\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_.restArgs\x3c\/code\x3e 将 restArgs 函数绑定到 \x3ccode\x3e_\x3c\/code\x3e 对象上。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>1625行，解开 underscore.js 的面纱 - 第六章</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005710444">https://segmentfault.com/a/1190000005710444</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/23ackmd55ay/" target="_blank">https://alili.tech/archive/23ackmd55ay/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>