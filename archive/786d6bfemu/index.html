<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="理解Javascript中的事件绑定与事件委托"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>理解Javascript中的事件绑定与事件委托 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/786d6bfemu/",
				"appid": "1613049289050283", 
				"title": "理解Javascript中的事件绑定与事件委托 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/0e76az9j3swp/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/qcoy9pzc5z/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f786d6bfemu%2f&text=%e7%90%86%e8%a7%a3Javascript%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a%e4%b8%8e%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f786d6bfemu%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f786d6bfemu%2f&text=%e7%90%86%e8%a7%a3Javascript%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a%e4%b8%8e%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f786d6bfemu%2f&title=%e7%90%86%e8%a7%a3Javascript%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a%e4%b8%8e%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f786d6bfemu%2f&is_video=false&description=%e7%90%86%e8%a7%a3Javascript%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a%e4%b8%8e%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%90%86%e8%a7%a3Javascript%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a%e4%b8%8e%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f786d6bfemu%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f786d6bfemu%2f&title=%e7%90%86%e8%a7%a3Javascript%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a%e4%b8%8e%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f786d6bfemu%2f&title=%e7%90%86%e8%a7%a3Javascript%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a%e4%b8%8e%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f786d6bfemu%2f&title=%e7%90%86%e8%a7%a3Javascript%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a%e4%b8%8e%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f786d6bfemu%2f&title=%e7%90%86%e8%a7%a3Javascript%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%bb%91%e5%ae%9a%e4%b8%8e%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">理解Javascript中的事件绑定与事件委托</h1><div class="meta"><div class="postdate"><time datetime="2019-02-05" itemprop="datePublished">2019-02-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e最近在深入实践js中，遇到了一些问题，比如我需要为动态创建的DOM元素绑定事件，那么普通的事件绑定就不行了，于是通过上网查资料了解到事件委托，因此想总结一下js中的事件绑定与事件委托。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e事件绑定\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e最直接的事件绑定：HTML事件处理程序\x3c\/h3\x3e\n\x3cp\x3e如下示例代码，通过节点属性显式声明，直接在HTML中，显式地为按钮绑定了click事件，当该按钮有用户点击行为时，便会触发myClickFunc方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* html *\/\n\x3cbutton id=\x26quot;btn\x26quot; onclick=\x26quot;myClickFunc()\x26quot;\x3e\n    ClickMe\n\x3c\/button\x3e\n\n\/* js *\/\n\/\/ 事件处理程序\nvar myClickFunc = function(evt){\n    \/\/ TODO..\n};\n\n\/\/ 移除事件处理程序\nmyClickFunc = function(){};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* html *\/\x3c\/span\x3e\n\x26lt;button id=\x3cspan class=\x22hljs-string\x22\x3e\x22btn\x22\x3c\/span\x3e onclick=\x3cspan class=\x22hljs-string\x22\x3e\x22myClickFunc()\x22\x3c\/span\x3e\x26gt;\n    ClickMe\n\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/button\x26gt;\n\n\/\x3c\/span\x3e* js *\x3cspan class=\x22hljs-regexp\x22\x3e\/\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 事件处理程序\nvar myClickFunc = function(evt){\n    \/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ TODO..\n};\n\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 移除事件处理程序\nmyClickFunc = function(){};\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e显而易见，这种绑定方式非常不友好，HTML代码和JS代码严重耦合在一起，比如当要修改一个函数名时候，就要修改两次，\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eDOM 0 级事件处理程序\x3c\/h3\x3e\n\x3cp\x3e通过DOM操作动态绑定事件，是一种比较传统的方式，把一个函数赋值给事件处理程序。这种方式也是应用较多的方式，比较简单。看下面例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* html *\/\n\x3cbutton id=\x26quot;btn\x26quot;\x3eClickMe\x3c\/button\x3e\n\n\/* js *\/\n\/\/ 事件处理程序\nvar myClickFunc = function(evt){\n    \/\/ TODO ...\n};\n\n\/\/ 直接给DOM节点的 onclick 方法赋值，注意这里接收的是一个function\ndocument.getElementById(\x27btn\x27).onclick = myClickFunc;\n\n\/\/ 移除事件处理程序\ndocument.getElementById(\x27btn\x27).onclick = null;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* html *\/\x3c\/span\x3e\n\x26lt;button id=\x3cspan class=\x22hljs-string\x22\x3e\x22btn\x22\x3c\/span\x3e\x26gt;ClickMe\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/button\x26gt;\n\n\/\x3c\/span\x3e* js *\x3cspan class=\x22hljs-regexp\x22\x3e\/\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 事件处理程序\nvar myClickFunc = function(evt){\n    \/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ TODO ...\n};\n\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 直接给DOM节点的 onclick 方法赋值，注意这里接收的是一个function\ndocument.getElementById(\x27btn\x27).onclick = myClickFunc;\n\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 移除事件处理程序\ndocument.getElementById(\x27btn\x27).onclick = null;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eDOM 2 级事件处理程序\x3c\/h3\x3e\n\x3cp\x3e通过事件监听的方式绑定事件，DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ event: 事件名称\n\/\/ function: 事件函数\n\/\/ boolean: false | true, true 为事件捕获, false 为事件冒泡(默认);\nEle.addEventListener(event,function[,boolean]); \/\/ 添加句柄\nELe.removeEventListener(event,function[,boolean]); \/\/ 移除句柄\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ event: 事件名称\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ function: 事件函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ boolean: false | true, true 为事件捕获, false 为事件冒泡(默认);\x3c\/span\x3e\nEle.addEventListener(event,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e[,\x3cspan class=\x22hljs-title\x22\x3eboolean\x3c\/span\x3e]); \/\/ 添加句柄\n\x3cspan class=\x22hljs-title\x22\x3eELe\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eremoveEventListener\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent,function[,boolean]\x3c\/span\x3e); \/\/ 移除句柄\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* html *\/\n\x3cbutton id=\x26quot;btn\x26quot;\x3eClickMe\x3c\/button\x3e\n\n\/* js *\/\n\/\/ 通过DOM操作进行动态绑定：\n\/\/ 获取btnHello节点\nvar oBtn = document.getElementById(\x27btn\x27);\n \n\/\/ 增加第一个 click 事件监听处理程序\noBtn.addEventListener(\x27click\x27,function(evt){\n    \/\/ TODO sth 1...\n});\n \n\/\/ 增加第二个 click 事件监听处理程序\noBtn.addEventListener(\x27click\x27,function(evt){\n    \/\/ TODO sth 2...\n});\n\n\/\/ ps：通过这种形式，可以给btn按钮绑定任意多个click监听；注意，执行顺序与添加顺序相关。\n\n\/\/ 移除事件处理程序\noBtn.removeEventListener(\x27click\x27,function(evt){..});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* html *\/\x3c\/span\x3e\n\x26lt;button id=\x3cspan class=\x22hljs-string\x22\x3e\x22btn\x22\x3c\/span\x3e\x26gt;ClickMe\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/button\x26gt;\n\n\/\x3c\/span\x3e* js *\x3cspan class=\x22hljs-regexp\x22\x3e\/\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 通过DOM操作进行动态绑定：\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 获取btnHello节点\nvar oBtn = document.getElementById(\x27btn\x27);\n \n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 增加第一个 click 事件监听处理程序\noBtn.addEventListener(\x27click\x27,function(evt){\n    \/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ TODO sth 1...\n});\n \n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 增加第二个 click 事件监听处理程序\noBtn.addEventListener(\x27click\x27,function(evt){\n    \/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ TODO sth 2...\n});\n\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ ps：通过这种形式，可以给btn按钮绑定任意多个click监听；注意，执行顺序与添加顺序相关。\n\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 移除事件处理程序\noBtn.removeEventListener(\x27click\x27,function(evt){..});\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eIE事件处理程序\x3c\/h3\x3e\n\x3cp\x3eDOM 2级事件处理程序在IE是行不通的，IE有自己的事件处理程序方法：\x3ccode\x3eattachEvent()\x3c\/code\x3e和\x3ccode\x3edetachEvent()\x3c\/code\x3e。这两个方法的用法与\x3ccode\x3eaddEventListener()\x3c\/code\x3e是一样的，但是只接收两个参数，一个是事件名称，另一个是事件处理程序的函数。为什么不使用第三个参数的原因呢？因为IE8以及更早的浏览器版本只支持事件冒泡。看个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* html *\/\n\x3cbutton id=\x26quot;btn\x26quot;\x3eClickMe\x3c\/button\x3e\n\n\/* js *\/\nvar oBtn = document.getElementById(\x27btn\x27);\n\/\/ 事件处理函数\nfunction evtFn(){ \n    console.log(this);\n}\n\/\/ 添加句柄\noBtn.attachEvent(\x27onclick\x27,evtFn);\n\n\/\/ 移除句柄\noBtn.detachEvent(\x27onclick\x27,evtFn);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* html *\/\x3c\/span\x3e\n\x26lt;button id=\x3cspan class=\x22hljs-string\x22\x3e\x22btn\x22\x3c\/span\x3e\x26gt;ClickMe\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/button\x26gt;\n\n\/\x3c\/span\x3e* js *\x3cspan class=\x22hljs-regexp\x22\x3e\/\nvar oBtn = document.getElementById(\x27btn\x27);\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 事件处理函数\nfunction evtFn(){ \n    console.log(this);\n}\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 添加句柄\noBtn.attachEvent(\x27onclick\x27,evtFn);\n\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 移除句柄\noBtn.detachEvent(\x27onclick\x27,evtFn);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e简易的跨浏览器解决方法\x3c\/h3\x3e\n\x3cp\x3e如果我们既要支持IE的事件处理方法，又要支持 DOM 2级事件，那么就要封装一个跨浏览器的事件处理函数，如果支持 DOM 2级事件，就用\x3ccode\x3eaddEventListener\x3c\/code\x3e，否则就用\x3ccode\x3eattachEvent\x3c\/code\x3e。例子如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/跨浏览器事件处理程序\nvar eventUtil = {\n    \/\/ 添加句柄\n    addHandler: function(element, type, handler){\n        if(element.addEventListener){\n            element.addEventListener(type, handler, false);\n        }else if(element.attachEvent){\n            element.attachEvent(\x27on\x27 \x2b type, handler);\n        }else{\n            element[\x27on\x27 \x2b type] = handler;\n        }\n    },\n    \/\/ 删除句柄\n    removeHandler: function(element, type, handler){\n        if(element.removeEventListener){\n            element.removeEventListener(type, handler, false);\n        }else if(element.detachEvent){\n            element.detachEvent(\x27on\x27 \x2b type, handler);\n        }else{\n            element[\x27on\x27 \x2b type] = null;\n        }\n    }\n};\n\nvar oBtn = document.getElementById(\x27btn\x27);\nfunction evtFn(){\n    alert(\x27hello world\x27);\n}\neventUtil.addHandler(oBtn, \x27click\x27, evtFn);\neventUtil.removeHandler(oBtn, \x27click\x27, evtFn);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/跨浏览器事件处理程序\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e eventUtil = {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加句柄\x3c\/span\x3e\n    addHandler: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eelement, type, handler\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(element.addEventListener){\n            element.addEventListener(type, handler, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n        }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(element.attachEvent){\n            element.attachEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27on\x27\x3c\/span\x3e \x2b type, handler);\n        }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n            element[\x3cspan class=\x22hljs-string\x22\x3e\x27on\x27\x3c\/span\x3e \x2b type] = handler;\n        }\n    },\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除句柄\x3c\/span\x3e\n    removeHandler: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eelement, type, handler\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(element.removeEventListener){\n            element.removeEventListener(type, handler, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n        }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(element.detachEvent){\n            element.detachEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27on\x27\x3c\/span\x3e \x2b type, handler);\n        }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n            element[\x3cspan class=\x22hljs-string\x22\x3e\x27on\x27\x3c\/span\x3e \x2b type] = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        }\n    }\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oBtn = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27btn\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eevtFn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    alert(\x3cspan class=\x22hljs-string\x22\x3e\x27hello world\x27\x3c\/span\x3e);\n}\neventUtil.addHandler(oBtn, \x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, evtFn);\neventUtil.removeHandler(oBtn, \x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, evtFn);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e事件冒泡和事件捕获\x3c\/h2\x3e\n\x3cp\x3e在了解事件委托之前，要先了解下事件冒泡和事件捕获。\x3c\/p\x3e\n\x3cp\x3e早期的web开发，浏览器厂商很难回答一个哲学上的问题：当你在页面上的一个区域点击时，你真正感兴趣的是哪个元素。这个问题带来了交互的定义。在一个元素的界限内点击，显得有点含糊。毕竟，在一个元素上的点击同时也发生在另一个元素的界限内。例如单击一个按钮。你实际上点击了按钮区域、body元素的区域以及html元素的区域。\x3c\/p\x3e\n\x3cp\x3e伴随着这个问题，两种主流的浏览器Netscape和IE有不同的解决方案。Netscape定义了一种叫做事件捕获的处理方法，事件首先发生在DOM树的最高层对象(document)然后往最深层的元素传播。在图例中，事件捕获首先发生在document上，然后是html元素，body元素，最后是button元素。\x3c\/p\x3e\n\x3cp\x3eIE的处理方法正好相反。他们定义了一种叫事件冒泡的方法。事件冒泡认为事件促发的最深层元素首先接收事件。然后是它的父元素，依次向上，知道document对象最终接收到事件。尽管相对于html元素来说，document没有独立的视觉表现，他仍然是html元素的父元素并且事件能冒泡到document元素。所以图例中噢噢那个button元素先接收事件，然后是body、html最后是document。如下图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006760658\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006760658\x22 alt=\x22事件.png\x22 title=\x22事件.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e事件冒泡\x3c\/h3\x3e\n\x3cp\x3e简单点说，事件冒泡就是事件触发时，会从目标DOM元素向上传播，直到文档根节点，一般情况下，会是如下形式传播：\x3c\/p\x3e\n\x3cp\x3etargetDOM → parentNode → ... → body → document → window\x3c\/p\x3e\n\x3cp\x3e如果希望一次事件触发能在整个DOM树上都得到响应，那么就需要用到事件冒泡的机制。看下面示例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* html *\/\n\x3cbutton id=\x26quot;btn\x26quot;\x3eClickMe\x3c\/button\x3e\n\n\/* js *\/\n\/\/ 给按钮增加click监听\ndocument.getElementById(\x27btn\x27).addEventListener(\x27click\x27,function(evt){\n    alert(\x27button clicked\x27);\n},false);\n \n\/\/ 给body增加click监听\ndocument.body.addEventListener(\x27click\x27,function(evt){\n    alert(\x27body clicked\x27);\n},false);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* html *\/\x3c\/span\x3e\n\x26lt;button id=\x3cspan class=\x22hljs-string\x22\x3e\x22btn\x22\x3c\/span\x3e\x26gt;ClickMe\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/button\x26gt;\n\n\/\x3c\/span\x3e* js *\x3cspan class=\x22hljs-regexp\x22\x3e\/\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 给按钮增加click监听\ndocument.getElementById(\x27btn\x27).addEventListener(\x27click\x27,function(evt){\n    alert(\x27button clicked\x27);\n},false);\n \n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 给body增加click监听\ndocument.body.addEventListener(\x27click\x27,function(evt){\n    alert(\x27body clicked\x27);\n},false);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这种情况下，点击按钮“ClickMe”后，其自身的click事件会被触发，同时，该事件将会继续向上传播， 所有的祖先节点都将得到事件的触发命令，并立即触发自己的click事件；所以如上代码，将会连续弹出两个alert.\x3c\/p\x3e\n\x3cp\x3e在有些时候，我们想让事件独立触发，所以我们必须阻止冒泡，用\x3ccode\x3eevent\x3c\/code\x3e的\x3ccode\x3estopPropagation()\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cbutton id=\x26quot;btn\x26quot;\x3eClickMe\x3c\/button\x3e\n\n\/* js *\/\n\/\/ 给按钮增加click监听\ndocument.getElementById(\x27btn\x27).addEventListener(\x27click\x27,function(evt){\n    alert(\x27button clicked\x27);\n    evt.stopPropagation(); \/\/阻止事件冒泡\n},false);\n \n\/\/ 给body增加click监听\ndocument.body.addEventListener(\x27click\x27,function(evt){\n    alert(\x27body clicked\x27);\n},false);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x26lt;button id=\x3cspan class=\x22hljs-string\x22\x3e\x22btn\x22\x3c\/span\x3e\x26gt;ClickMe\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/button\x26gt;\n\n\/\x3c\/span\x3e* js *\x3cspan class=\x22hljs-regexp\x22\x3e\/\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 给按钮增加click监听\ndocument.getElementById(\x27btn\x27).addEventListener(\x27click\x27,function(evt){\n    alert(\x27button clicked\x27);\n    evt.stopPropagation(); \/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/阻止事件冒泡\n},false);\n \n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 给body增加click监听\ndocument.body.addEventListener(\x27click\x27,function(evt){\n    alert(\x27body clicked\x27);\n},false);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时，点击按钮后，只会触发按钮本身的click事件，得到一个alert效果；该按钮的点击事件，不会向上传播，body节点就接收不到此次事件命令。\x3c\/p\x3e\n\x3cp\x3e需要注意的是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e不是所有的事件都能冒泡，如：blur、focus、load、unload都不能\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不同的浏览器，阻止冒泡的方式也不一样，在w3c标准中，通过\x3ccode\x3eevent.stopPropagation()\x3c\/code\x3e完成， 在IE中则是通过自身的\x3ccode\x3eevent.cancelBubble=true\x3c\/code\x3e来完成。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e事件委托\x3c\/h2\x3e\n\x3cp\x3e事件委托看起来挺难理解，但是举个生活的例子。比如，有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。举个例子\x3c\/p\x3e\n\x3cp\x3eHTML结构：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cul id=\x26quot;ul-item\x26quot;\x3e\n    \x3cli\x3eitem1\x3c\/li\x3e\n    \x3cli\x3eitem2\x3c\/li\x3e\n    \x3cli\x3eitem3\x3c\/li\x3e\n    \x3cli\x3eitem4\x3c\/li\x3e\n\x3c\/ul\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22ul-item\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3eitem1\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3eitem2\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3eitem3\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3eitem4\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们要点击li标签，弹出里面的内容，我们就需要为每个li标签绑定事件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(function(){\n    var oUlItem = document.getElementById(\x27ul-item\x27);\n    var oLi = oUlItem.getElementsByTagName(\x27li\x27);\n    for(var i=0, l = oLi.length; i \x3c l; i\x2b\x2b){\n        oLi[i].addEventListener(\x27click\x27,show);\n    };\n    function show(e){\n        e = e || window.event;\n        alert(e.target.innerHTML);\n    };\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oUlItem = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27ul-item\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oLi = oUlItem.getElementsByTagName(\x3cspan class=\x22hljs-string\x22\x3e\x27li\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = oLi.length; i \x26lt; l; i\x2b\x2b){\n        oLi[i].addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e,show);\n    };\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshow\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n        e = e || \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.event;\n        alert(e.target.innerHTML);\n    };\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然这样子能够实现我们想要的功能，但是如果这个UL中的LI子元素频繁的添加或删除，我们就需要在每次添加LI的时候为它绑定事件。这就添加了复杂度，并且造成内存开销较大。\x3c\/p\x3e\n\x3cp\x3e更简单的方法是利用事件委托，当事件被掏到更上层的父节点的时候，通过检查事件的目标对象（target）来判断并获取事件源LI。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(function(){\n    var oUlItem = document.getElementById(\x27ul-item\x27);\n    oUlItem.addEventListener(\x27click\x27,show);\n    function show(e){\n        e = e || window.event;\n        var src = e.target;\n        if(src \x26amp;\x26amp; src.nodeName.toLowerCase() === \x27li\x27){\n            alert(src.innerHTML);\n        }\n    }\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oUlItem = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27ul-item\x27\x3c\/span\x3e);\n    oUlItem.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e,show);\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshow\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n        e = e || \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.event;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e src = e.target;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(src \x26amp;\x26amp; src.nodeName.toLowerCase() === \x3cspan class=\x22hljs-string\x22\x3e\x27li\x27\x3c\/span\x3e){\n            alert(src.innerHTML);\n        }\n    }\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们为父节点UL添加了点击事件，当点击子节点LI标签的时候，点击事件会冒泡到父节点。父节点捕获到事件之后，通过判断\x3ccode\x3ee.target.nodeName\x3c\/code\x3e来判断是否为我们需要处理的节点，并且通过\x3ccode\x3ee.target\x3c\/code\x3e拿到了被点击的Li节点。从而可以获取到相应的信息，并做处理。\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e优点：\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e通过上面的介绍，大家应该能够体会到使用事件委托对于web应用程序带来的几个优点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eJavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e参考资料\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.diguage.com\/archives\/71.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.diguage.com\/archives\/71.html\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/owenchen.net\/?p=15\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/owenchen.net\/?p=15\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>理解Javascript中的事件绑定与事件委托</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006667581">https://segmentfault.com/a/1190000006667581</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/786d6bfemu/" target="_blank">https://alili.tech/archive/786d6bfemu/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>