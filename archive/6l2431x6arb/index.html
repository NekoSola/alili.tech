<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【译】 React 性能工程（上）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【译】 React 性能工程（上） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6l2431x6arb/",
				"appid": "1613049289050283", 
				"title": "【译】 React 性能工程（上） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-04T02:30:58"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/qjpub8ochad/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/1vgz64ydx0f/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6l2431x6arb%2f&text=%e3%80%90%e8%af%91%e3%80%91%20React%20%e6%80%a7%e8%83%bd%e5%b7%a5%e7%a8%8b%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6l2431x6arb%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6l2431x6arb%2f&text=%e3%80%90%e8%af%91%e3%80%91%20React%20%e6%80%a7%e8%83%bd%e5%b7%a5%e7%a8%8b%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6l2431x6arb%2f&title=%e3%80%90%e8%af%91%e3%80%91%20React%20%e6%80%a7%e8%83%bd%e5%b7%a5%e7%a8%8b%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6l2431x6arb%2f&is_video=false&description=%e3%80%90%e8%af%91%e3%80%91%20React%20%e6%80%a7%e8%83%bd%e5%b7%a5%e7%a8%8b%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90%e8%af%91%e3%80%91%20React%20%e6%80%a7%e8%83%bd%e5%b7%a5%e7%a8%8b%ef%bc%88%e4%b8%8a%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6l2431x6arb%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6l2431x6arb%2f&title=%e3%80%90%e8%af%91%e3%80%91%20React%20%e6%80%a7%e8%83%bd%e5%b7%a5%e7%a8%8b%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6l2431x6arb%2f&title=%e3%80%90%e8%af%91%e3%80%91%20React%20%e6%80%a7%e8%83%bd%e5%b7%a5%e7%a8%8b%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6l2431x6arb%2f&title=%e3%80%90%e8%af%91%e3%80%91%20React%20%e6%80%a7%e8%83%bd%e5%b7%a5%e7%a8%8b%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6l2431x6arb%2f&title=%e3%80%90%e8%af%91%e3%80%91%20React%20%e6%80%a7%e8%83%bd%e5%b7%a5%e7%a8%8b%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【译】 React 性能工程（上）</h1><div class="meta"><div class="postdate"><time datetime="2019-02-04" itemprop="datePublished">2019-02-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e04 February 2016  on \x3ca href=\x22http:\/\/benchling.engineering\/tag\/react\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e本文是 React 性能工程系列文章的第一篇（共两篇） \x3ca href=\x22http:\/\/benchling.engineering\/deep-dive-react-perf-debugging\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e第二篇 深入探讨React性能调试\x3c\/a\x3e \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006911917\x22\x3e译文\x3c\/a\x3e 现在已经推出!\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e这篇文章适用于复杂的React应用。如果只是构建一些简单的、小型的应用，你还不用考虑性能问题。不必过早地优化，去构建吧！\x3c\/p\x3e\n\x3cp\x3e然而，如果你是在构建一个DNA设计工具、一个胶体图片分析器、一个富文本编辑器，或者一个全能的电子数据表，你就会触碰到性能的瓶颈了。这时候，就有必要来解决这个问题了。在构建Benchling这个项目的过程中，我们遇到了很多问题。所以，本文的目的是给那些网络开发者和关注Benchling的粉丝分享我们学到的一些方法。（当然，如果你喜欢这类问题，我们正在\x3ca href=\x22http:\/\/grnh.se\/wt7plq\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e招聘\x3c\/a\x3e!）\x3c\/p\x3e\n\x3cp\x3e在这篇文章中，我将会讲述使用React性能工具的一些基础知识、一些会导致React渲染瓶颈的常见问题，以及一些需要谨记的调试方法。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e基准\x3c\/h2\x3e\n\x3cp\x3e浏览器性能可以用三句话来概述：理想中你期望浏览器每秒渲染60帧，每帧16.7毫秒。当你的app运行缓慢的时候，经常需要很长时间才能响应用户事件、处理数据或者重新渲染新的数据。大多数情况下，你并没有时刻在处理复杂的数据，只是浪费时间在重绘而已。\x3c\/p\x3e\n\x3cp\x3e使用React, 不需要做额外的工作，就可以取得性能上的优势：\x3c\/p\x3e\n\x3cp\x3e因为React会处理所有的DOM操作，很大程度上免去了DOM解析和布局所带来的问题。在后台，React会在JavaScript中维持虚拟DOM, 这样便于快速地把文档更新到期望状态。\x3c\/p\x3e\n\x3cp\x3e我们要避免直接操作DOM，因为React组件的状态是储存在JS中的。一个传统的性能问题就是在不恰当的时刻操作DOM，这样会导致像\x3ca href=\x22https:\/\/developers.google.com\/web\/tools\/chrome-devtools\/profile\/rendering-tools\/analyze-runtime#how-to-identify-layout-bottlenecks\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e被迫同步布局\x3c\/a\x3e这样的问题（例如：为了获取某节点的样式 \x3ccode\x3esomeNode.style.left\x3c\/code\x3e， 使得浏览器被迫渲染画面）。为了不用以下这种做法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22`someNode.style.left = parseInt(someNode.style.left) \x2b 10 \x2b \x26quot;px\x26quot;;` \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e`someNode.style.left = parseInt(someNode.style.left) \x2b \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22px\x22\x3c\/span\x3e;` \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以声明式地调用 `` 来触发组件，不需要从DOM元素读取数据，就可以简单地更新状态了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22`this.setState({left: this.state.left \x2b 10}).` \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e`this.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3eState({left: this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.left \x2b \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e}).` \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e说明一点，这些优化不用React也是可以实现的，我只是简单地指出React趋向于提前解决这些问题。\x3c\/p\x3e\n\x3cp\x3e对于简单的应用，React 所带来的这些性能优化就足够了。我认为这些是使框架变得可行的最小工作量了。然而，当你开发的页面越来越多、越复杂时，维护和对比虚拟DOM就会变成一项昂贵的操作了。幸运的是，React提供了一些工具，可以检测哪里有性能问题，便于你及时地避开这些问题。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e调试带来的性能问题\x3c\/h2\x3e\n\x3cp\x3e请注意 -- 调试本身也会带来一些问题，导致混淆调试部分，以为这部分不会留在生产中。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e元素窗口\x3c\/h3\x3e\n\x3cp\x3e元素窗口是观察DOM元素是否被重新渲染的一个简单好用的途径，当一个属性改变或者一个DOM节点更新、插入、替换时，它都会闪现一个颜色。然而，元素面板的闪现，或者说是重新渲染也将影响到性能！经常我会从元素窗口切换到控制台，来更准确地感知每秒的帧数。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3ePropTypes\x3c\/h3\x3e\n\x3cp\x3e在用进行React开发时，当一个组件被渲染时，经常要进行\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/reusable-components.html#prop-validation\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePropType 校验\x3c\/a\x3e。组件所接收到的 \x3ccode\x3eprop\x3c\/code\x3e 先被检测来帮助调试和开发。使用 Chrome 提供的 \x3ccode\x3eJS Profiler\x3c\/code\x3e ，你可以发现React组件在这个校验的方法上花费了很长一段时间。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006846317?w=1526\x26amp;h=500\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006846317?w=1526\x26amp;h=500\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e尽管开发环境的警告提示有助于调试，但它们是会有一些性能方面的代价的，这些代价则不会反映在生产环境。有时我会使用切换到生产构建环境来忽略这种迟缓的错觉。（只要把\x3ccode\x3eNODE_ENV\x3c\/code\x3e 改为 \x3ccode\x3eproduction\x3c\/code\x3e，就可以启动生产环境构建模式了：\x3ca href=\x22https:\/\/facebook.github.io\/react\/downloads.html#npm\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/facebook.github.io\/react\/downloads.html#npm\x3c\/a\x3e.）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e通过React.addons.Perf来识别性能问题\x3c\/h2\x3e\n\x3cp\x3e在深入讲解常见问题的修复前，重点强调一下，你必须只花时间来修复你所能把控的那些问题。如果你毫无约束地乱优化是很容易走进死胡同的。啰嗦一下，应该专注于构建，并且只把时间花在修复主要的性能瓶颈上。\x3c\/p\x3e\n\x3cp\x3e使用标准的调试工具来识别性能瓶颈仍然是可行的，但是经常很难来解释数据，因为实际应用的代码会比在React-land中的代码花费更多的时间（例如：你写的一个复杂的渲染方式运行得很快，但是其带来的虚拟DOM计算却是相当昂贵的）。这使我们很难在React-land中识别哪些应用代码导致了明显的瓶颈问题。\x3c\/p\x3e\n\x3cp\x3e幸运的是，React自带一些性能检测工具，可以在React的非生产构建环境中使用(\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/perf.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e文档\x3c\/a\x3e)。通过\x3ccode\x3ereact\/addons\x3c\/code\x3e，你可以找到对应的\x3ccode\x3eReact.addons.Perf\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e我们可以这样写:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cIntermediateBinder\n  deleteItem={this.deleteItem}\n  boundArg={item.id}\x3e\n  {(boundProps) =\x3e \x3cTodoItem deleteItem={boundProps.deleteItem} \/\x3e}\n\x3c\/IntermediateBinder\x3e \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eIntermediateBinder\x3c\/span\x3e\n  \x3cspan class=\x22hljs-attr\x22\x3edeleteItem\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.deleteItem}\x3c\/span\x3e\n  \x3cspan class=\x22hljs-attr\x22\x3eboundArg\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{item.id}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  {(boundProps) =\x26gt; \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eTodoItem\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3edeleteItem\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{boundProps.deleteItem}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e}\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eIntermediateBinder\x3c\/span\x3e\x26gt;\x3c\/span\x3e \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e（我们探索的另一个可能的做法是，使用一个自定义的绑定函数，这个函数本身储存了元数据, 它和一个更高端的检测函数结合使用，就可以检测到功能的结合实际上还没有改变。这似乎不能满足我们的需求。）\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e构造数组、对象字面量\x3c\/h3\x3e\n\x3cp\x3e这很简单，只是经常被忽略了。数组字面量会破坏 \x3ccode\x3ePureRenderMixin\x3c\/code\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3e [\x27important\x27, \x27starred\x27] === [\x27important\x27, \x27starred\x27]\nfalse \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs prolog\x22\x3e\x3ccode\x3e\x26gt; [\x3cspan class=\x22hljs-string\x22\x3e\x27important\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27starred\x27\x3c\/span\x3e] === [\x3cspan class=\x22hljs-string\x22\x3e\x27important\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27starred\x27\x3c\/span\x3e]\nfalse \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你不希望这个对象被改变，你就可以把它放到一个模块常量或者组件静态变量中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22`const TAGS = [\x27important\x27, \x27starred\x27];` \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e`const TAGS = [\x3cspan class=\x22hljs-string\x22\x3e\x27important\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27starred\x27\x3c\/span\x3e];` \x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e子组件\x3c\/h3\x3e\n\x3cp\x3e在一个组件和它的子组件之间定义内容界限有利于性能优化----接口封装性良好的组件可以自然地促进性能更新。重构中间的组件可以帮助提高性能，你也可以使用 \x3ccode\x3ePureRenderMixin \x3c\/code\x3e 来保存更新。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv\x3e\n  \x3cComplexForm props={this.props.complexFormProps} \/\x3e\n  \x3cul\x3e\n    \x3cli prop={this.props.items[0]}\x3eitem A\x3c\/li\x3e\n    ...1000 items...\n  \x3c\/ul\x3e\n\x3c\/div\x3e \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eComplexForm\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eprops\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.complexFormProps}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eprop\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.items[0]}\x3c\/span\x3e\x26gt;\x3c\/span\x3eitem A\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    ...1000 items...\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上面这个例子中，如果 \x3ccode\x3ecomplexFormProps\x3c\/code\x3e 和 \x3ccode\x3eitems\x3c\/code\x3e 来自同一个 store 的话，那么在 \x3ccode\x3ecomplexFormProps\x3c\/code\x3e 里面输入，就会引发 store 的更新，而每个 store 的更新又会导致上面这整个实例的重新渲染。虚拟 DOM 的差异是很棒的，但仍然需要每次都检测。 然而，重构它的子组件，采用 \x3ccode\x3ethis.props.items\x3c\/code\x3e，这样就只有当 \x3ccode\x3ethis.props.items\x3c\/code\x3e 变化时才会更新状态。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv\x3e\n  \x3cCustomList items={this.props.items} \/\x3e\n  \x3cComplexForm props={this.props.complexFormProps} \/\x3e\n\x3c\/div\x3e \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCustomList\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eitems\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.items}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eComplexForm\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eprops\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.complexFormProps}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e缓存昂贵的计算\x3c\/h3\x3e\n\x3cp\x3e这个跟 \x3ccode\x3e状态来源单一性\x3c\/code\x3e 原则有些相悖，但是如果 \x3ccode\x3eprop\x3c\/code\x3e 中的计算是昂贵的，你就可以把它缓存在组件中。我们不必在渲染的方法中，直接地调用 \x3ccode\x3edoExpensiveComputation(this.prop.someProp)\x3c\/code\x3e ，可以把这个函数进行封装，在prop 状态没改变的时候，把它缓存起来。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22getCachedExpensiveComputation() {\n  if (this._cachedSomeProp !== this.prop.someProp) {\n    this._cachedSomeProp = this.prop.someProp;\n    this._cachedComputation = doExpensiveComputation(this.prop.someProp);\n  }\n  return this._cachedComputation;\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3egetCachedExpensiveComputation() {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._cachedSomeProp !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.prop.someProp) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._cachedSomeProp = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.prop.someProp;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._cachedComputation = doExpensiveComputation(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.prop.someProp);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._cachedComputation;\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e后续的优化人员使用JS分析器，将可以很好地发现这个问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e状态链接\x3c\/h3\x3e\n\x3cp\x3eReact 的双向数据绑定对于简单的控制反转(IoC)非常有用，它允许子组件向父组件传递新的状态。如果对React表单组件只是使用 \x3ccode\x3evalueLink\x3c\/code\x3e 的话是没那么糟糕的，因为 React 的表单输入是很简单的。但如果你像我们一样，在多个组件之间串联，那就会遇到问题了。状态链接实施如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22linkState(key) {\n  return new ReactLink(\n    this.state[key],\n    ReactStateSetters.createStateKeySetter(this, key)\n  );\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3elinkState(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ReactLink(\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e],\n    ReactStateSetters.createStateKeySetter(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e)\n  );\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e尽管状态没有改变，每调用一次 \x3ccode\x3elinkState\x3c\/code\x3e 都会返回一个新的对象！这意味着 \x3ccode\x3eshallowCompare\x3c\/code\x3e 永远不会起作用。不幸的是，我们的变通方案就是干脆不使用 \x3ccode\x3elinkState\x3c\/code\x3e。 如果不是要把一个 \x3ccode\x3elinkState\x3c\/code\x3e 变成一个 \x3ccode\x3egetter prop\x3c\/code\x3e 和一个 \x3ccode\x3esetter prop\x3c\/code\x3e 的话，我们要避免创建一个新的对象。例如：\x3ccode\x3enameLink={this.linkState(‘name\x27)}\x3c\/code\x3e 可以被替换成 \x3ccode\x3ename={this.state.name} setName={this.setName}\x3c\/code\x3e。（我们已经考虑写一个可以对自身进行缓存的 \x3ccode\x3elinkState\x3c\/code\x3e了）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e编译程序的优化\x3c\/h2\x3e\n\x3cp\x3e新版的 Bebel 和 React 支持\x3ca href=\x22https:\/\/facebook.github.io\/react\/blog\/2015\/10\/07\/react-v0.14.html#compiler-optimizations\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e内联React元素并且自动提升常量\x3c\/a\x3e。不幸的是，我们还没有用过这方面的技术，但它们将有助于减少 \x3ccode\x3eReact.createElement\x3c\/code\x3e 的调用, 以及加速DOM的更新和解。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e刚刚我们看了很多 (你应该看过原列表的!)， 但是关键的两点就是你要习惯 \x3ccode\x3eprofiling\x3c\/code\x3e 和 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e。 我希望这些都能够帮到你！\x3c\/p\x3e\n\x3cp\x3e任何建议、评论等，如果我们错过了，欢迎通过 benchling.com 让我们知悉。\x3c\/p\x3e\n\x3cp\x3e请继续关注本系列文章的第二篇，我们将讨论 React 的调试工作流，深入存在性能问题的代码实例，进而示范如何修复。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/news.ycombinator.com\/item?id=11036007\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHacker News的讨论\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e更新: 第二篇已经出来啦! \x3ca href=\x22http:\/\/benchling.engineering\/deep-dive-react-perf-debugging\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCheck it out - A Deep Dive into React Perf Debugging.\x3c\/a\x3e\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e我们一如既往地欢迎喜欢我们产品的朋友来加入\x3ca href=\x22http:\/\/grnh.se\/wt7plq\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这个团队\x3c\/a\x3e. :)\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【译】 React 性能工程（上）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006846314">https://segmentfault.com/a/1190000006846314</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/6l2431x6arb/" target="_blank">https://alili.tech/archive/6l2431x6arb/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>