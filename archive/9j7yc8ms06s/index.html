<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【译】关于Webpack中一些让人困惑的地方的解答"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【译】关于Webpack中一些让人困惑的地方的解答 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9j7yc8ms06s/",
				"appid": "1613049289050283", 
				"title": "【译】关于Webpack中一些让人困惑的地方的解答 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-06T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/bfsffledmar/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/fksofk0s2mm/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9j7yc8ms06s%2f&text=%e3%80%90%e8%af%91%e3%80%91%e5%85%b3%e4%ba%8eWebpack%e4%b8%ad%e4%b8%80%e4%ba%9b%e8%ae%a9%e4%ba%ba%e5%9b%b0%e6%83%91%e7%9a%84%e5%9c%b0%e6%96%b9%e7%9a%84%e8%a7%a3%e7%ad%94"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9j7yc8ms06s%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9j7yc8ms06s%2f&text=%e3%80%90%e8%af%91%e3%80%91%e5%85%b3%e4%ba%8eWebpack%e4%b8%ad%e4%b8%80%e4%ba%9b%e8%ae%a9%e4%ba%ba%e5%9b%b0%e6%83%91%e7%9a%84%e5%9c%b0%e6%96%b9%e7%9a%84%e8%a7%a3%e7%ad%94"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9j7yc8ms06s%2f&title=%e3%80%90%e8%af%91%e3%80%91%e5%85%b3%e4%ba%8eWebpack%e4%b8%ad%e4%b8%80%e4%ba%9b%e8%ae%a9%e4%ba%ba%e5%9b%b0%e6%83%91%e7%9a%84%e5%9c%b0%e6%96%b9%e7%9a%84%e8%a7%a3%e7%ad%94"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9j7yc8ms06s%2f&is_video=false&description=%e3%80%90%e8%af%91%e3%80%91%e5%85%b3%e4%ba%8eWebpack%e4%b8%ad%e4%b8%80%e4%ba%9b%e8%ae%a9%e4%ba%ba%e5%9b%b0%e6%83%91%e7%9a%84%e5%9c%b0%e6%96%b9%e7%9a%84%e8%a7%a3%e7%ad%94"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90%e8%af%91%e3%80%91%e5%85%b3%e4%ba%8eWebpack%e4%b8%ad%e4%b8%80%e4%ba%9b%e8%ae%a9%e4%ba%ba%e5%9b%b0%e6%83%91%e7%9a%84%e5%9c%b0%e6%96%b9%e7%9a%84%e8%a7%a3%e7%ad%94&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9j7yc8ms06s%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9j7yc8ms06s%2f&title=%e3%80%90%e8%af%91%e3%80%91%e5%85%b3%e4%ba%8eWebpack%e4%b8%ad%e4%b8%80%e4%ba%9b%e8%ae%a9%e4%ba%ba%e5%9b%b0%e6%83%91%e7%9a%84%e5%9c%b0%e6%96%b9%e7%9a%84%e8%a7%a3%e7%ad%94"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9j7yc8ms06s%2f&title=%e3%80%90%e8%af%91%e3%80%91%e5%85%b3%e4%ba%8eWebpack%e4%b8%ad%e4%b8%80%e4%ba%9b%e8%ae%a9%e4%ba%ba%e5%9b%b0%e6%83%91%e7%9a%84%e5%9c%b0%e6%96%b9%e7%9a%84%e8%a7%a3%e7%ad%94"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9j7yc8ms06s%2f&title=%e3%80%90%e8%af%91%e3%80%91%e5%85%b3%e4%ba%8eWebpack%e4%b8%ad%e4%b8%80%e4%ba%9b%e8%ae%a9%e4%ba%ba%e5%9b%b0%e6%83%91%e7%9a%84%e5%9c%b0%e6%96%b9%e7%9a%84%e8%a7%a3%e7%ad%94"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9j7yc8ms06s%2f&title=%e3%80%90%e8%af%91%e3%80%91%e5%85%b3%e4%ba%8eWebpack%e4%b8%ad%e4%b8%80%e4%ba%9b%e8%ae%a9%e4%ba%ba%e5%9b%b0%e6%83%91%e7%9a%84%e5%9c%b0%e6%96%b9%e7%9a%84%e8%a7%a3%e7%ad%94"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【译】关于Webpack中一些让人困惑的地方的解答</h1><div class="meta"><div class="postdate"><time datetime="2019-02-06" itemprop="datePublished">2019-02-06</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e原文连接：\x3ca href=\x22https:\/\/medium.com\/@rajaraodv\/webpack-the-confusing-parts-58712f8fcad9#.jvse0h7j5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWebpack — The Confusing Parts\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cp\x3eWebpack是React和Redux项目的主要模块加载器。我认为使用Angular2和其他的框架的人在如今也大量使用Webpack进行开发。\x3c\/p\x3e\n\x3cp\x3e当我第一次查看Webpack的配置文件时，我是懵逼的。在使用过一段时间以后，我觉得这是因为Webpack有着独一无二的语法和标新立异的哲学思想，所以在刚开始使用的时候可能会造成一定的困惑。凑巧的是，这些哲学思想也是让它如此受欢迎的原因。\x3c\/p\x3e\n\x3cp\x3e正因为Webpack的起步比较容易产生困惑，所以我希望写一些什么出来，好让更多人更容易上手并且体验它强大的特性。\x3c\/p\x3e\n\x3cp\x3e接下来是第一部分。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3eWebpack的核心哲学思想\x3c\/h1\x3e\n\x3cp\x3e两个核心哲学思想是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e一切都是模块\x3c\/strong\x3e——就像JS文件可以视作“模块”一样，其他所有的一切（CSS，图片，HTML）都可以被视作模块。也就是说，你可以\x3ccode\x3erequire(“myJSfile.js”)\x3c\/code\x3e或者\x3ccode\x3erequire(“myCSSfile.css”)\x3c\/code\x3e。这意味着我们可以把任何静态资源分割成可控的模块，以供重复使用等不同的操作。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e只加载“你需要的”和“你何时需要”的\x3c\/strong\x3e——典型的模块加载器会把所有的模块最终打包生成一个巨大的“bundle.js”文件。\x3cstrong\x3e但在很多实际的项目当中，这个“bundle.js”文件体积可能会达到10MB~15MB，并且会一直不停进行加载！\x3c\/strong\x3e所以Webpack通过大量的特性去\x3cstrong\x3e分割你的代码\x3c\/strong\x3e，生成多个“bundle”片段，并且\x3cstrong\x3e异步地加载项目的不同部分\x3c\/strong\x3e，因此只会为你加载“你需要的”和“你何时需要”的部分。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eOK，让我们一起来看看那些“让人困惑”的部分吧。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e1. 开发环境 VS 生产环境\x3c\/h1\x3e\n\x3cp\x3e第一件需要意识到的事情是Webpack拥有着大量的特性。有一些是“开发环境专用”的，一些是“生产环境专用”的，还有一些是“通用”的。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzXIH\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzXIH\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e一般来说，大部分的项目都使用了许多Webpack的特性，所以它们通常有两个大的\x3ccode\x3ewebpack config\x3c\/code\x3e文件，用于区分开发环境和生产环境。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e2. webpack CLI Vs webpack-dev-server\x3c\/h1\x3e\n\x3cp\x3e明白Webpack这个模块加载器拥有两个接口是非常重要的：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eWebpack CLI tool ——默认的接口（和Webpack一并被安装）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ewebpack-dev-server tool ——这个工具通过来自CLI和配置文件（默认：\x3ccode\x3ewebpack.config.js\x3c\/code\x3e）的配置项来控制Webpack的打包动作。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cblockquote\x3e\x3cp\x3e你刚开始学习Webpack的时候可能是从CLI入手的，但你接下来很可能只会用它去建立生产环境的项目。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e使用方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22OPTION 1: \n\/\/全局安装\nnpm install webpack --g\n\n\/\/在终端使用\n$ webpack \/\/\x3c--通过webpack.bundle.js进行打包\n\nOPTION 2 :\n\/\/本地安装并写入package.json依赖\nnpm install webpack --save\n\n\/\/添加到package.json的script内\n“scripts”: {\n “build”: “webpack --config webpack.config.prod.js -p”,\n ...\n }\n\n\/\/开始构建\nnpm run build\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3eOPTION \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e: \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/全局安装\x3c\/span\x3e\nnpm install webpack --g\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/在终端使用\x3c\/span\x3e\n$ webpack \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;--通过webpack.bundle.js进行打包\x3c\/span\x3e\n\nOPTION \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e :\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/本地安装并写入package.json依赖\x3c\/span\x3e\nnpm install webpack --save\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/添加到package.json的script内\x3c\/span\x3e\n“scripts”: {\n “build”: “webpack --config webpack\x3cspan class=\x22hljs-selector-class\x22\x3e.config\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.prod\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e -p”,\n ...\n }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/开始构建\x3c\/span\x3e\nnpm run build\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eWebpack-dev-server (有利于开发环境使用)\x3c\/h3\x3e\n\x3cp\x3e这是一个运行在8080端口的基于Express的node.js服务器。这个服务器会在内部调用Webpack。它的优势是提供了额外的能力——类似可以刷新浏览器的“\x3cstrong\x3eLive Reloading\x3c\/strong\x3e”，以及（或者）局部更新模块的\x3cstrong\x3e“模块热重载”功能（HMR）\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e使用方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22OPTION 1:\n\/\/全局安装\nnpm install webpack-dev-server --save\n\n\/\/终端使用\n$ webpack-dev-server --inline --hot\n\nOPTION 2:\n\/\/添加到package.json的script内\n“scripts”: {\n “start”: “webpack-dev-server --inline --hot”,\n ...\n }\n\n\/\/输入下列命令行进行使用\n$ npm start\n\n浏览器打开下列地址\nhttp:\/\/localhost:8080\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sql\x22\x3e\x3ccode\x3eOPTION 1:\n\/\/全局安装\nnpm \x3cspan class=\x22hljs-keyword\x22\x3einstall\x3c\/span\x3e webpack-dev-\x3cspan class=\x22hljs-keyword\x22\x3eserver\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e--save\x3c\/span\x3e\n\n\/\/终端使用\n$ webpack-dev-\x3cspan class=\x22hljs-keyword\x22\x3eserver\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e--inline --hot\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eOPTION\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e:\n\/\/添加到package.json的script内\n“scripts”: {\n “\x3cspan class=\x22hljs-keyword\x22\x3estart\x3c\/span\x3e”: “webpack-dev-\x3cspan class=\x22hljs-keyword\x22\x3eserver\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e--inline --hot”,\x3c\/span\x3e\n ...\n }\n\n\/\/输入下列命令行进行使用\n$ npm \x3cspan class=\x22hljs-keyword\x22\x3estart\x3c\/span\x3e\n\n浏览器打开下列地址\n\x3cspan class=\x22hljs-keyword\x22\x3ehttp\x3c\/span\x3e:\/\/localhost:\x3cspan class=\x22hljs-number\x22\x3e8080\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eWebpack Vs webpack-dev-server options\x3c\/h3\x3e\n\x3cp\x3e值得注意的是，有一些选项比如“inline”和“hot”仅用于webpack-dev-server，而比如“hide-modules”仅用于CLI。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3ewebpack-dev-server CLI options Vs config options\x3c\/h3\x3e\n\x3cp\x3e另外一件需要知道的事情是你可以通过两种方式对webpack-dev-server进行配置：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e通过\x3ccode\x3ewebpack.config.js\x3c\/code\x3e的“devServer”对象。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e通过CLI选项。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/使用CLI\nwebpack-dev-server --hot --inline\n\n\/\/使用webpack.config.js\ndevServer: {\n inline: true,\n hot:true\n }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs yaml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e\/\/使用CLI\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3ewebpack-dev-server\x3c\/span\x3e \x3cspan class=\x22hljs-bullet\x22\x3e--hot\x3c\/span\x3e \x3cspan class=\x22hljs-bullet\x22\x3e--inline\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-string\x22\x3e\/\/使用webpack.config.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3edevServer:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e inline:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e hot:\x3c\/span\x3e\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e我发现有时候devServer的配置并不管用！所以我更倾向于把这些选项以CLI的方式写入\x3ccode\x3epackage.json\x3c\/code\x3e里面：\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/package.json\n{\nscripts: \n   {“start”: “webpack-dev-server --hot --inline”}\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3e\/\/\x3cspan class=\x22hljs-keyword\x22\x3epackage\x3c\/span\x3e.json\n{\nscripts: \n   {“start”: “webpack-dev-server \x3cspan class=\x22hljs-comment\x22\x3e--hot --inline”}\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e注意：确保你木有把\x3ccode\x3ehot:true\x3c\/code\x3e和\x3ccode\x3e-hot\x3c\/code\x3e写在一块儿。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e“hot” Vs “inline” webpack-dev-server options\x3c\/h3\x3e\n\x3cp\x3e“inline”选项为整个页面提供了“Live reloading”功能。“hot”选项提供了“模块热重载”功能，它会尝试仅仅更新组件被改变的部分（而不是整个页面）。如果我们把这两个选项都写上，那么当文件被改动时，webpack-dev-server会先尝试HMR，如果这不管用，它就会重新加载整个页面。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/当文件被改动后，下面的三个选项都会生成新的bundle，但是，\n \n\/\/1. 页面不会刷新\n$ webpack-dev-server\n\n\/\/2. 刷新整个页面\n$ webpack-dev-server --inline\n\n\/\/3. 仅仅刷新被改动的部分（HMR），如果HMR失败则刷新整个页面\n$ webpack-dev-server  --inline --hot\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs axapta\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/当文件被改动后，下面的三个选项都会生成新的bundle，但是，\x3c\/span\x3e\n \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/1. 页面不会刷新\x3c\/span\x3e\n$ webpack-dev-\x3cspan class=\x22hljs-keyword\x22\x3eserver\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/2. 刷新整个页面\x3c\/span\x3e\n$ webpack-dev-\x3cspan class=\x22hljs-keyword\x22\x3eserver\x3c\/span\x3e --inline\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/3. 仅仅刷新被改动的部分（HMR），如果HMR失败则刷新整个页面\x3c\/span\x3e\n$ webpack-dev-\x3cspan class=\x22hljs-keyword\x22\x3eserver\x3c\/span\x3e  --inline --hot\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader7\x22\x3e“entry”——字符串VS数组VS对象\x3c\/h1\x3e\n\x3cp\x3e\x3cstrong\x3eentry\x3c\/strong\x3e告诉Webpack入口文件或者起点在哪里。它可以是一个字符串，一个数组或者一个对象。这可能会使你感到困惑，但不同的类型适用于不同的场合。\x3c\/p\x3e\n\x3cp\x3e如果你使用的是单个起点（大部分项目都是如此），那么你可以使用任意的类型，它们的结果都会是一样的。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzXOB\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzXOB\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3eentry——数组\x3c\/h3\x3e\n\x3cp\x3e但是，如果你想要添加互不依赖的多个文件，你可以使用数组的格式。\x3c\/p\x3e\n\x3cp\x3e举个栗子，你的HTML可能需要“googleAnalytics.js”。你可以告诉Webpack在bundle.js的后面把它添加进去：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzXOV\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzXOV\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eentry——对象\x3c\/h3\x3e\n\x3cp\x3e现在，当你有一个包含多个HTML文件的多页应用，而不是单页应用的项目的时候（index.html和profile.html），你可以通过对象格式告诉Webpack去一次性生成多个bundle文件。\x3c\/p\x3e\n\x3cp\x3e下面的配置会生成两个JS文件：\x3ccode\x3eindexEntry.js\x3c\/code\x3e和\x3ccode\x3eprofileEntry.js\x3c\/code\x3e，你可以在\x3ccode\x3eindex.html\x3c\/code\x3e和\x3ccode\x3eprofile.html\x3c\/code\x3e\x3cstrong\x3e分别使用它们\x3c\/strong\x3e：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzXPs\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzXPs\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e使用方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/profile.html\n\x3cscript src=”dist\/profileEntry.js”\x3e\x3c\/script\x3e\n\n\/\/index.html\n\x3cscript src=”dist\/indexEntry.js”\x3e\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\/\/profile.html\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e”dist\/profileEntry.js”\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\/\/index.html\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e”dist\/indexEntry.js”\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e注意：文件名来自“entry”对象的key。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eentry——组合格式\x3c\/h3\x3e\n\x3cp\x3e你也可以在entry对象中使用数组。下面的例子会生成三个文件：一个包含三个文件的\x3ccode\x3evendor.js\x3c\/code\x3e，一个\x3ccode\x3eindex.js\x3c\/code\x3e和一个\x3ccode\x3eprofile.js\x3c\/code\x3e。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzXP3\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzXP3\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader11\x22\x3e4. output — “path” Vs “publicPath”\x3c\/h1\x3e\n\x3cp\x3e\x3cstrong\x3eoutput\x3c\/strong\x3e告诉Webpack应该在哪里以怎样的方式去放置打包好的文件。它有两个属性：“path”和“publicPath”，这也许会对用户造成一定的困惑。\x3c\/p\x3e\n\x3cp\x3e“path”会简单地告诉Webpack生成文件输出位置。“publicPath”多被一些Webpack的插件使用，在HTML文件以\x3cstrong\x3e生产环境\x3c\/strong\x3e方式被构建的时候，更新CSS文件内的URL地址。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzXQX\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzXQX\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e举个栗子，在你的CSS文件里面，你可能会在URL里面加载\x3ccode\x3e.\/test.png\x3c\/code\x3e。但是在生产环境中，\x3ccode\x3etest.png\x3c\/code\x3e很可能放在CDN内——比如当你的node.js服务器运行在Heroku的时候。\x3cstrong\x3e这意味着，你可能在生产环境内不得不手动更新文件内的URL指向\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e相反，你可以使用Webpack的\x3ccode\x3epublicPath\x3c\/code\x3e以及其他适用于这个属性的插件在生产环境中自动地更新文件内部的URL指向。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzXRl\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzXRl\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/开发环境：服务器和图片都放在本地\n.image { \n  background-image: url(‘.\/test.png’);\n }\n\n\/\/生产环境：服务器在Heroku而图片在CDN\n.image { \n  background-image: url(‘https:\/\/someCDN\/test.png’);\n }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/开发环境：服务器和图片都放在本地\x3c\/span\x3e\n.\x3cspan class=\x22hljs-built_in\x22\x3eimage\x3c\/span\x3e { \n  \x3cspan class=\x22hljs-built_in\x22\x3ebackground\x3c\/span\x3e-\x3cspan class=\x22hljs-built_in\x22\x3eimage\x3c\/span\x3e: url(‘.\/test.png’);\n }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/生产环境：服务器在Heroku而图片在CDN\x3c\/span\x3e\n.\x3cspan class=\x22hljs-built_in\x22\x3eimage\x3c\/span\x3e { \n  \x3cspan class=\x22hljs-built_in\x22\x3ebackground\x3c\/span\x3e-\x3cspan class=\x22hljs-built_in\x22\x3eimage\x3c\/span\x3e: url(‘https:\x3cspan class=\x22hljs-comment\x22\x3e\/\/someCDN\/test.png’);\x3c\/span\x3e\n }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader12\x22\x3e5. 加载器和链式加载器\x3c\/h1\x3e\n\x3cp\x3e加载器是额外的node模块，用于“加载”或者“引入”不同类型的文件，并把他们转化成浏览器能够识别的格式——比如JS文件、内联样式表或其他格式。另外，加载器也允许以“require”或者ES6的“import”的方式把这些文件引入到JS文件当中。\x3c\/p\x3e\n\x3cp\x3e例如，你可以使用\x3ccode\x3ebabel-loader\x3c\/code\x3e把ES6代码转化成ES5代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module: {\n loaders: [{\n  test: \/\\.js$\/, \/\/ 判断文件格式，若为“.js”文件则调用loader\n  exclude: \/node_modules\/, \/\/ 排除node_modules文件夹\n  loader: ‘babel’ \/\/ 使用babel（babel-loader的缩写）\n }]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-symbol\x22\x3emodule:\x3c\/span\x3e {\n\x3cspan class=\x22hljs-symbol\x22\x3e loaders:\x3c\/span\x3e [{\n\x3cspan class=\x22hljs-symbol\x22\x3e  test:\x3c\/span\x3e \/\\.js$\/, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断文件格式，若为“.js”文件则调用loader\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3e  exclude:\x3c\/span\x3e \/node_modules\/, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 排除node_modules文件夹\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3e  loader:\x3c\/span\x3e ‘babel’ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用babel（babel-loader的缩写）\x3c\/span\x3e\n }]\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e链式加载器（从右到左的顺序进行工作）\x3c\/h3\x3e\n\x3cp\x3e不同的加载器可以链式地在针对同一个文件类型进行工作。\x3cstrong\x3e链式加载器的工作顺序是从右到左的，并且通过“！”分割\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e举个栗子，我们有一个叫做\x3ccode\x3emyCssFile.css\x3c\/code\x3e的CSS文件，现在想把它以\x3ccode\x3e\x26lt;style\x26gt;\x26lt;\/style\x26gt;\x3c\/code\x3e的方式在我们的HTML文件中使用，可以通过两个加载器去完成这个需求：\x3ccode\x3ecss-loader\x3c\/code\x3e和\x3ccode\x3estyle-loader\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module: {\n loaders: [{\n  test: \/\\.css$\/,\n  loader: ‘style!css’ \/\/ style-loader!css-loader的缩写\n }]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-symbol\x22\x3emodule:\x3c\/span\x3e {\n\x3cspan class=\x22hljs-symbol\x22\x3e loaders:\x3c\/span\x3e [{\n\x3cspan class=\x22hljs-symbol\x22\x3e  test:\x3c\/span\x3e \/\\.css$\/,\n\x3cspan class=\x22hljs-symbol\x22\x3e  loader:\x3c\/span\x3e ‘style!css’ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ style-loader!css-loader的缩写\x3c\/span\x3e\n }]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是运行原理：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzXR1\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzXR1\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eWebpack搜寻被模块所引用的CSS文件。意思是Webpack会检查一个JS文件内是否有\x3ccode\x3erequire(myCssFile.css)\x3c\/code\x3e，如果有这句话并且找到了这个依赖，它会首先把这个文件交给\x3ccode\x3ecss-loader\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecss-loader\x3c\/code\x3e加载所有的CSS文件及其依赖包（例如通过\x3ccode\x3e@import\x3c\/code\x3e引入的其他CSS文件）到一个JSON文件中。随后Webpack会把结果交给\x3ccode\x3estyle-loader\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3estyle-loader\x3c\/code\x3e拿到这个JSON文件并把它注入到\x3ccode\x3e\x26lt;style\x26gt;\x26lt;\/style\x26gt;\x3c\/code\x3e标签当中，并把这个标签添加到\x3ccode\x3eindex.html\x3c\/code\x3e文件内。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader14\x22\x3e6.加载器自身是可配置的\x3c\/h1\x3e\n\x3cp\x3e加载器其自身可以通过配置不同的参数实现不同的功能。\x3c\/p\x3e\n\x3cp\x3e在下面的例子中，我们配置了\x3ccode\x3eurl-loader\x3c\/code\x3e，当图片小于1024byte的时候使用DataURL，当图片大雨1024byte的时候使用URL。我们通过下面两个传入\x3ccode\x3elimit\x3c\/code\x3e参数的方法来实现这个功能：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzXT5\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzXT5\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader15\x22\x3e7. babelrc文件\x3c\/h1\x3e\n\x3cp\x3e\x3ccode\x3ebabel-loader\x3c\/code\x3e使用\x3ccode\x3epresets\x3c\/code\x3e去规定如何把ES6代码转化为ES5代码，以及如何把React的JSX转化为JS。我们可以通过\x3ccode\x3equery\x3c\/code\x3e方法进行配置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module: {\n  loaders: [\n    {\n      test: \/\\.jsx?$\/,\n      exclude: \/(node_modules|bower_components)\/,\n      loader: \x27babel\x27,\n      query: {\n        presets: [\x27react\x27, \x27es2015\x27]\n      }\n    }\n  ]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3emodule\x3c\/span\x3e: {\n  \x3cspan class=\x22hljs-attribute\x22\x3eloaders\x3c\/span\x3e: [\n    {\n      test: \/\\.jsx?$\/,\n      exclude: \/(node_modules|bower_components)\/,\n      loader: \x3cspan class=\x22hljs-string\x22\x3e\x27babel\x27\x3c\/span\x3e,\n      query: {\n        presets: [\x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27es2015\x27\x3c\/span\x3e]\n      }\n    }\n  ]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然而，在许多项目中babel的配置项会非常巨大。所以作为替代，你可以把这些配置项写入一个叫做\x3ccode\x3e.babelrc\x3c\/code\x3e的文件中。如果这个文件存在的话\x3ccode\x3ebable-loader\x3c\/code\x3e会自动的加载这个文件。\x3c\/p\x3e\n\x3cp\x3e所以在许多例子中，你会看到：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/webpack.config.js \nmodule: {\n  loaders: [\n    {\n      test: \/\\.jsx?$\/,\n      exclude: \/(node_modules|bower_components)\/,\n      loader: \x27babel\x27\n    }\n  ]\n}\n\n\/\/.bablerc\n{\n “presets”: [“react”, “es2015”]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/webpack.config.js \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n  loaders: [\n    {\n      test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.jsx?$\/\x3c\/span\x3e,\n      exclude: \x3cspan class=\x22hljs-regexp\x22\x3e\/(node_modules|bower_components)\/\x3c\/span\x3e,\n      loader: \x3cspan class=\x22hljs-string\x22\x3e\x27babel\x27\x3c\/span\x3e\n    }\n  ]\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/.bablerc\x3c\/span\x3e\n{\n “presets”: [“react”, “es2015”]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader16\x22\x3e8. 插件\x3c\/h1\x3e\n\x3cp\x3e插件是额外的node模块，多用于处理输出文件。\x3c\/p\x3e\n\x3cp\x3e例如，\x3ccode\x3euglifyJSPlugin\x3c\/code\x3e会压缩并混淆JS代码，使其体积减小。\x3c\/p\x3e\n\x3cp\x3e同样的，\x3ccode\x3eextract-text-webpack-plugin\x3c\/code\x3e会在内部使用\x3ccode\x3ecss-loader\x3c\/code\x3e和\x3ccode\x3estyle-loader\x3c\/code\x3e去把所有的CSS合并为一个文件，并且最终把结果提取到一个分离在外部的\x3ccode\x3estyle.css\x3c\/code\x3e文件中，最后在\x3ccode\x3eindex.html\x3c\/code\x3e中引用这个CSS文件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/webpack.config.js\n\/\/Take all the .css files, combine their contents and it extract them to a single \x26quot;styles.css\x26quot;\nvar ETP = require(\x26quot;extract-text-webpack-plugin\x26quot;);\n\nmodule: {\n loaders: [\n  {test: \/\\.css$\/, loader:ETP.extract(\x26quot;style-loader\x26quot;,\x26quot;css-loader\x26quot;) }\n  ]\n},\nplugins: [\n    new ExtractTextPlugin(\x26quot;styles.css\x26quot;) \/\/Extract to styles.css file\n  ]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/webpack.config.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/Take all the .css files, combine their contents and it extract them to a single \x22styles.css\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ETP = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22extract-text-webpack-plugin\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n loaders: [\n  {test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.css$\/\x3c\/span\x3e, loader:ETP.extract(\x3cspan class=\x22hljs-string\x22\x3e\x22style-loader\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22css-loader\x22\x3c\/span\x3e) }\n  ]\n},\nplugins: [\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ExtractTextPlugin(\x3cspan class=\x22hljs-string\x22\x3e\x22styles.css\x22\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/Extract to styles.css file\x3c\/span\x3e\n  ]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意，如果你只打算把CSS以行内样式的形式在HTML中引用，你可以仅仅使用\x3ccode\x3ecss-loader\x3c\/code\x3e和\x3ccode\x3estyle-loader\x3c\/code\x3e，像下面的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module: {\n loaders: [{\n  test: \/\\.css$\/,\n  loader: ‘style!css’ \/\/ style-loader!css-loader的缩写\n }]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-symbol\x22\x3emodule:\x3c\/span\x3e {\n\x3cspan class=\x22hljs-symbol\x22\x3e loaders:\x3c\/span\x3e [{\n\x3cspan class=\x22hljs-symbol\x22\x3e  test:\x3c\/span\x3e \/\\.css$\/,\n\x3cspan class=\x22hljs-symbol\x22\x3e  loader:\x3c\/span\x3e ‘style!css’ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ style-loader!css-loader的缩写\x3c\/span\x3e\n }]\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader17\x22\x3e9. 加载器 VS 插件\x3c\/h1\x3e\n\x3cp\x3e正如你可能已经弄明白的，\x3cstrong\x3e加载器在单个文件的程度上，在打包结束之前或者打包的过程中运行\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e而\x3cstrong\x3e插件是在打包或者数据块的程度上，在输出打包文件的过程中进行运作\x3c\/strong\x3e。一些插件比如commonsChunksPlugins甚至在更早的阶段开始运作，可以用来修改打包的方式。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader18\x22\x3e10. 解析文件扩展名\x3c\/h1\x3e\n\x3cp\x3e一些Webpack配置文件带有解析扩展文件名的属性，它们像下面的例子一样，包含了一些\x3cstrong\x3e空字符串\x3c\/strong\x3e。这些空字符串被用于帮助加载一些没有扩展名的文件，比如\x3ccode\x3erequire(\x22.\/myJSFile\x22)\x3c\/code\x3e或者\x3ccode\x3eimport myJSFile from \x27.\/myJSFile\x27\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n resolve: {\n   extensions: [‘’, ‘.js’, ‘.jsx’]\n }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e{\n \x3cspan class=\x22hljs-attribute\x22\x3eresolve\x3c\/span\x3e: {\n   extensions: [‘’, ‘.js’, ‘.jsx’]\n }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e全文完。\x3c\/p\x3e\n\x3cp\x3e感谢Tobias Koppers（Webpack的作者）帮我审阅这篇文章！\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e感谢你的阅读。我是Jrain，欢迎关注\x3ca href=\x22https:\/\/segmentfault.com\/blog\/jrain\x22\x3e我的专栏\x3c\/a\x3e，将不定期分享自己的学习体验，开发心得，搬运墙外的干货。下次见啦！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【译】关于Webpack中一些让人困惑的地方的解答</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006151512">https://segmentfault.com/a/1190000006151512</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9j7yc8ms06s/" target="_blank">https://alili.tech/archive/9j7yc8ms06s/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>