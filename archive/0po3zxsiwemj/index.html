<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 移动 web 极致优化"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 移动 web 极致优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/0po3zxsiwemj/",
				"appid": "1613049289050283", 
				"title": "React 移动 web 极致优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-09T02:30:59"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/xngdlbl5vmm/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/sk00k02rnu9/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f0po3zxsiwemj%2f&text=React%20%e7%a7%bb%e5%8a%a8%20web%20%e6%9e%81%e8%87%b4%e4%bc%98%e5%8c%96"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f0po3zxsiwemj%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f0po3zxsiwemj%2f&text=React%20%e7%a7%bb%e5%8a%a8%20web%20%e6%9e%81%e8%87%b4%e4%bc%98%e5%8c%96"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f0po3zxsiwemj%2f&title=React%20%e7%a7%bb%e5%8a%a8%20web%20%e6%9e%81%e8%87%b4%e4%bc%98%e5%8c%96"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f0po3zxsiwemj%2f&is_video=false&description=React%20%e7%a7%bb%e5%8a%a8%20web%20%e6%9e%81%e8%87%b4%e4%bc%98%e5%8c%96"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e7%a7%bb%e5%8a%a8%20web%20%e6%9e%81%e8%87%b4%e4%bc%98%e5%8c%96&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f0po3zxsiwemj%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f0po3zxsiwemj%2f&title=React%20%e7%a7%bb%e5%8a%a8%20web%20%e6%9e%81%e8%87%b4%e4%bc%98%e5%8c%96"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0po3zxsiwemj%2f&title=React%20%e7%a7%bb%e5%8a%a8%20web%20%e6%9e%81%e8%87%b4%e4%bc%98%e5%8c%96"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0po3zxsiwemj%2f&title=React%20%e7%a7%bb%e5%8a%a8%20web%20%e6%9e%81%e8%87%b4%e4%bc%98%e5%8c%96"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0po3zxsiwemj%2f&title=React%20%e7%a7%bb%e5%8a%a8%20web%20%e6%9e%81%e8%87%b4%e4%bc%98%e5%8c%96"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 移动 web 极致优化</h1><div class="meta"><div class="postdate"><time datetime="2019-02-09" itemprop="datePublished">2019-02-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e原文地址：\x3ca href=\x22https:\/\/github.com\/lcxfs1991\/blog\/issues\/8\/strong\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/lcxfs1991\/...\x3c\/a\x3e\x3c\/strong\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e最近一个季度，我们都在为手Q家校群做重构优化，将原有那套问题不断的框架换掉。经过一些斟酌，决定使用react 进行重构。选择react，其实也主要是因为它具有下面的三大特性。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eReact的特性\x3c\/h2\x3e\n\x3ch4\x3e1. Learn once, write anywhere\x3c\/h4\x3e\n\x3cp\x3e学习React的好处就是，学了一遍之后，能够写web, node直出，以及native，能够适应各种纷繁复杂的业务。需要轻量快捷的，直接可以用Reactjs；需要提升首屏时间的，可以结合React Server Render；需要更好的性能的，可以上React Native。\x3c\/p\x3e\n\x3cp\x3e但是，这其实暗示学习的曲线非常陡峭。单单是Webpack\x2b React \x2b Redux就已够一个入门者够呛，更何况还要兼顾直出和手机客户端。不是一般人能hold住所有端。\x3c\/p\x3e\n\x3ch4\x3e2. Virtual Dom\x3c\/h4\x3e\n\x3cp\x3eVirtual Dom（下称vd）算是React的一个重大的特色，因为Facebook宣称由于vd的帮助，React能够达到很好的性能。是的，Facebook说的没错，但只说了一半，它说漏的一半是：“除非你能正确的采用一系列优化手段”。\x3c\/p\x3e\n\x3ch4\x3e3. 组件化\x3c\/h4\x3e\n\x3cp\x3e另一个被大家所推崇的React优势在于，它能令到你的代码组织更清晰，维护起来更容易。我们在写的时候也有同感，但那是直到我们踩了一些坑，并且渐渐熟悉React\x2b Redux所推崇的那套代码组织规范之后。\x3c\/p\x3e\n\x3ch4\x3e那么？\x3c\/h4\x3e\n\x3cp\x3e上面的描述不免有些先扬后抑的感觉，那是因为往往作为React的刚入门者，都会像我们初入的时候一样，对React满怀希望，指意它帮我们做好一切，但随着了解的深入，发现需要做一些额外的事情来达到我们的期待。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e对React的期待\x3c\/h2\x3e\n\x3cp\x3e初学者对React可能满怀期待，觉得React可能完爆其它一切框架，甚至不切实际地认为React可能连原生的渲染都能完爆——对框架的狂热确实会出现这样的不切实际的期待。让我们来看看React的官方是怎么说的。React官方文档在Advanced Performanec这一节，这样写道：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22One of the first questions people ask when considering React for a project is whether their application will be as fast and responsive as an equivalent non-React version\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eOne \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efirst\x3c\/span\x3e questions people ask when \x3cspan class=\x22hljs-keyword\x22\x3econsidering\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e a project \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e whether their \x3cspan class=\x22hljs-built_in\x22\x3eapplication\x3c\/span\x3e will be \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e fast \x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e responsive \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e an equivalent non-React \x3cspan class=\x22hljs-built_in\x22\x3eversion\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e显然React自己也其实只是想尽量达到跟非React版本相若的性能。React在减少重复渲染方面确实是有一套独特的处理办法，那就是vd，但显示在首次渲染的时候React绝无可能超越原生的速度，或者一定能将其它的框架比下去。因此，我们在做优化的时候，可的期待的东西有：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e首屏时间可能会比较原生的慢一些，但可以尝试用React Server Render (又称Isomorphic)去提高效率\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e用户进行交互的时候，有可能会比原生的响应快一些，前提是你做了一些优化避免了浪费性能的重复渲染。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e以手Q家校群功能页React重构优化为例\x3c\/h2\x3e\n\x3cp\x3e手Q家校群功能页主要由三个页面构成，分别是列表页、布置页和详情页。列表页已经重构完成并已发布，布置页已重构完毕准备提测，详情页正在重构。与此同时我们已完成对列表页的同构直出优化，并已正在做React Native优化的铺垫。\x3c\/p\x3e\n\x3cp\x3e这三个页面的重构其实覆盖了不少页面的案例，所以还是蛮有代表性的，我们会将重构之中遇到的一些经验穿插在文章里论述。\x3c\/p\x3e\n\x3cp\x3e在手Q家校群重构之前，其实我们已经做了一版PC家校群。当时将native的页面全部web化，直接就采用了React比较常用的全家桶套装：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e构建工具 =\x26gt; gulp \x2b webpack\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e开发效率提升 =\x26gt; redux-dev-tools \x2b hot-reload\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e统一数据管理=\x26gt; redux\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e性能提升 =\x26gt; immutable \x2b purerender\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e路由控制器 =\x26gt; react-router(手Q暂时没采用)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为什么我们在优化的时候主要讲手Q呢？毕竟PC的性能在大部份情况下已经很好，在PC上一些存在的问题都被PC良好的性能掩盖下去。手机的性能不如PC，因此有更多有价值的东西深挖。开发的时候我就跟同事开玩笑说：“没做过手机web优化的都真不好意思说自己做过性能优化啊“。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e构建针对React做的优化\x3c\/h2\x3e\n\x3cp\x3e我在《性能优化三部曲之一——构建篇》提出，“通过构建，我们可以达成开发效率的提升，以及对项目最基本的优化”。在进行React重构优化的过程中，构建对项目的优化作用必不可少。在本文暂时不赘述，我另外开辟了一篇\x3ca href=\x22https:\/\/github.com\/lcxfs1991\/blog\/issues\/7\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《webpack使用优化（react篇）》\x3c\/a\x3e进行具体论述。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e开发效率提升工具\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006765620?w=379\x26amp;h=631\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006765620?w=379\x26amp;h=631\x22 alt=\x221\x22 title=\x221\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在PC端使用Redux的时候，我们都很喜欢使用Redux-Devtools来查看Redux触发的action，以及对应的数据变化。PC端使用的时候，我们习惯摆在右边。但移动端的屏幕较少，因此家校群项目使用的时候放在底部，而且由于性能问题，我们在constant里设一个debug参数，然后在chrome调试时打开，移动端非必须的时候关闭。否则，它会导致移动web的渲染比较低下。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e数据管理及性能优化\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eRedux统一管理数据\x3c\/h3\x3e\n\x3cp\x3e这一部份算是重头戏吧。React作为View层的框架，已经通过vd帮助我们解决重复渲染的问题。但vd是通过看数据的前后差异去判断是否要重复渲染的，但React并没有帮助我们去做这层比较。因此我们需要使用一整套数据管理工具及对应的优化方法去达成。在这方法，我们选择了Redux。\x3c\/p\x3e\n\x3cp\x3eRedux整个数据流大体可以用下图来描述：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599252\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599252\x22 alt=\x222\x22 title=\x222\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eRedux这个框架的好处在于能够统一在自己定义的reducer函数里面去进行数据处理，在View层中只需要通过事件去处触发一些action就可以改变地应的数据，这样能够使数据处理和dom渲染更好地分离，而避免手动地去设置state。\x3c\/p\x3e\n\x3cp\x3e在重构的时候，我们倾向于将功能类似的数据归类到一起，并建立对应的reducer文件对数据进行处理。如下图，是手Q家校群布置页的数据结构。有些大型的SPA项目可能会将初始数据分开在不同的reducer文件里，但这里我们倾向于归到一个store文件，这样能够清晰地知道整个文件的数据结构，也符合Redux想统一管理数据的想法。然后数据的每个层级与reducer文件都是一一对应的关系。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599254\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599254\x22 alt=\x223\x22 title=\x223\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e重复渲染导致卡顿\x3c\/h3\x3e\n\x3cp\x3e这套React \x2b Redux的东西在PC家校群页面上用得很欢乐， 以至于不用怎么写shouldComponentUpdate都没遇到过什么性能问题。但放到移动端上，我们在列表页重构的时候就马上遇到卡顿的问题了。\x3c\/p\x3e\n\x3cp\x3e什么原因呢？是重复渲染导致的！！！！！！\x3c\/p\x3e\n\x3cp\x3e说好的React vd可以减少重复渲染呢？！！！\x3c\/p\x3e\n\x3cp\x3e请别忘记前提条件！！！！\x3c\/p\x3e\n\x3cp\x3e你可以在每个component的render里，放一个console.log(\x22xxx component\x22)。然后触发一个action，在优化之前，几乎全部的component都打出这个log，表明都重复渲染了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3eReact性能的救星Immutablejs\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599256\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599256\x22 alt=\x224\x22 title=\x224\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e(网图，引用的文章太多以致于不知道哪篇才是出处)\x3c\/p\x3e\n\x3cp\x3e上图是React的生命周期，还没熟悉的同学可以去熟悉一下。因为其中的shouldComponentUpdate是优化的关键。React的重复渲染优化的核心其实就是在shouldComponentUpdate里面做数据比较。在优化之前，shouldComponentUpdate是默认返回true的，这导致任何时候触发任何的数据变化都会使component重新渲染。这必然会导致资源的浪费和性能的低下——你可能会感觉比较原生的响应更慢。\x3c\/p\x3e\n\x3cp\x3e这时你开始怀疑这世界——是不是Facebook在骗我。\x3c\/p\x3e\n\x3cp\x3e当时遇到这个问题我的开始翻阅文档，也是在Facebook的Advanced Performance一节中找到答案：Immutablejs。这个框架已被吹了有一年多了吧，吹这些框架的人理解它的原理，但不一定实践过——因为作为一线移动端开发者，打开它的github主页看dist文件，50kb，我就已经打退堂鼓了。只是遇到了性能问题，我们才再认真地去了解一遍。\x3c\/p\x3e\n\x3cp\x3eImmutable这个的意思就是不可变，Immutablejs就是一个生成数据不可变的框架。一开始你并不理解不可变有什么用。最开始的时候Immutable这种数据结构是为了解决数据锁的问题，而对于js，就可以借用来解决前后数据比较的问题——因为同时Immutablejs还提供了很好的数据比较方法——Immutable.is()。小结一下就是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eImmutablejs本身就能生成不可变数据，这样就不需要开发者自己去做数据深拷贝，可以直接拿prevProps\/prevState和nextProps\/nextState来比较。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eImmutable本身还提供了数据的比较方法，这样开发者也不用自己去写数据深比较的方法。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e说到这里，已万事俱备了。那东风呢？我们还欠的东风就是应该在哪里写这个比较。答案就是shouldComponentUpdate。这个生命周期会传入nextProps和nextState，可以跟component当前的props和state直接比较。这个就可以参考pure-render的做法，去重写shouldComponentUpdate，在里面写数据比较的逻辑。\x3c\/p\x3e\n\x3cp\x3e其中一位同事polarjiang利用Immutablejs的is方法，参考pure-render-decorator写了一个\x3ca href=\x22https:\/\/github.com\/lcxfs1991\/pure-render-deepCompare-decorator\/blob\/master\/src\/immutable-pure-render-decorator\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eimmutable-pure-render-decorator\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e那具体怎么使用immutable \x2b pure-render呢？\x3c\/p\x3e\n\x3cp\x3e对于immutable，我们需要改写一下reducer functions里面的处理逻辑，一律换成Immutable的api。\x3c\/p\x3e\n\x3cp\x3e至于pure-render，若是es5写法，可以用使mixin；若是es6\/es7写法，需要使用decorator，在js的babel loader里面，新增plugins: [‘transform-decorators-legacy’]。其es6的写法是\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@pureRender\nexport default class List extends Component { ... }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-meta\x22\x3e@pureRender\x3c\/span\x3e\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{ ... }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eImmutablejs带来的一些问题\x3c\/h3\x3e\n\x3ch4\x3e不重新渲染\x3c\/h4\x3e\n\x3cp\x3e你可能会想到Immutable能减少无谓的重新渲染，但可能没想过会导致页面不能正确地重新渲染。目前列表页在老师进入的时候是有2个tab的，tab的切换会让列表也切换。目前手Q的列表页学习PC的列表页，两个列表共用一套dom结构（因为除了作业布置者名字之外，两个列表一模一样）。上了Immutablejs之后，当碰巧“我发布的“列表和”全部“列表开头的几个作业都是同一个人布置的时候，列表切换就不重新渲染了。\x3c\/p\x3e\n\x3cp\x3e引入immutable和pureRender后，render里的JSX注意一定不要有同样的key（如两个列表，有重复的数据，此时以数据id来作为key就不太合适，应该要用数据id \x2b 列表类型作为key），会造成不渲染新数据情况。列表页目前的处理办法是将key值换成id \x2b listType。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599258\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599258\x22 alt=\x224\x22 title=\x224\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e(列表页两个列表的切换)\x3c\/p\x3e\n\x3cp\x3e这样写除了保证在父元素那一层知晓数据(key值）不同需要重新渲染之外，也保证了React底层渲染知道这是两组不同的数据。在React源文件里有一个ReactChildReconciler.js主要是写children的渲染逻辑。其中的updateChildren里面有具体如何比较前后children，然后再决定是否要重新渲染。在比较的时候它调用了shouldUpdateReactComponent方法。我们看到它有对key值做比较。在两个列表中有不同的key，在数据相似的情况下，能保证两者切换的时候能重新渲染。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function shouldUpdateReactComponent(prevElement, nextElement) {\n  var prevEmpty = prevElement === null || prevElement === false;\n  var nextEmpty = nextElement === null || nextElement === false;\n  if (prevEmpty || nextEmpty) {\n    return prevEmpty === nextEmpty;\n  }\n\n  var prevType = typeof prevElement;\n  var nextType = typeof nextElement;\n  if (prevType === \x27string\x27 || prevType === \x27number\x27) {\n    return nextType === \x27string\x27 || nextType === \x27number\x27;\n  } else {\n    return nextType === \x27object\x27 \x26amp;\x26amp; prevElement.type === nextElement.type \x26amp;\x26amp; prevElement.key === nextElement.key;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshouldUpdateReactComponent\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(prevElement, nextElement)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e prevEmpty = prevElement === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e || prevElement === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nextEmpty = nextElement === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e || nextElement === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (prevEmpty || nextEmpty) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e prevEmpty === nextEmpty;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e prevType = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e prevElement;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nextType = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e nextElement;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (prevType === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e || prevType === \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e nextType === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e || nextType === \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e;\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e nextType === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e \x26amp;\x26amp; prevElement.type === nextElement.type \x26amp;\x26amp; prevElement.key === nextElement.key;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eImmutablejs太大了\x3c\/h4\x3e\n\x3cp\x3e上文也提到Immutablejs编译后的包也有50kb。对于PC端来说可能无所谓，网速足够快，但对于移动端来说压力就大了。有人写了个\x3ca href=\x22https:\/\/github.com\/rtfeldman\/seamless-immutable\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eseamless-immutable\x3c\/a\x3e，算是简易版的Immutablejs，只有2kb，只支持Object和Array。\x3c\/p\x3e\n\x3cp\x3e但其实数据比较逻辑写起来也并不难，因此再去review代码的时候，我决定尝试自己写一个，也是这个决定让我发现了更多的奥秘。\x3c\/p\x3e\n\x3cp\x3e针对React的这个数据比较的深比较deepCompare，要点有2个：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e尽量使传入的数据扁平化一点\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e比较的时候做一些限制，避免溢出栈\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e先上一下列表页的代码，如下图。这里当时是学习了PC家校群的做法，将component作为props传入。这里的\x3ccode\x3e\x26lt;Scroll\x26gt;\x3c\/code\x3e封装的是滚动检测的逻辑，而\x3ccode\x3e\x26lt;List\x26gt;\x3c\/code\x3e则是列表页的渲染，\x3ccode\x3e\x26lt;Empty\x26gt;\x3c\/code\x3e是列表为空的时候展示的内容，\x3ccode\x3e\x26lt;Loading\x26gt;\x3c\/code\x3e是列表底部加载的显示横条。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599260\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599260\x22 alt=\x225\x22 title=\x225\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e针对deepCompare的第1个要点，扁平化数据，我们很明显就能定位出其中一个问题了。例如\x3ccode\x3e\x26lt;Empty\x26gt;\x3c\/code\x3e，我们传入了props.hw，这个props包括了两个列表的数据。但这样的结构就会是这样\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22props.hw = {\n    listMine: [\n        {...}, {...}, ...\n    ],\n    listAll: [\n        {...}, {...}, ...\n    ],\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3eprops.hw = {\n    listMine: [\n        \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e, \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e, ...\n    ],\n    listAll: [\n        \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e, \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e, ...\n    ],\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但如果我们提前在传入之前判断当前在哪个列表，然后传入对应列表的数量，则会像这样：\x3cbr\x3eprops.hw = 20;\x3c\/p\x3e\n\x3cp\x3e两者比较起来，显示是后者简单得多。\x3c\/p\x3e\n\x3cp\x3e针对deepCompare第2点，限制比较的条件。首先让我们想到的是比较的深度。一般而言，对于Object和Array数据，我们都需要递归去进行比较，出于性能的考虑，我们都会限制比较的深度。\x3c\/p\x3e\n\x3cp\x3e除此之外，我们回顾一下上面的代码，我们将几个React component作为props传进去了，这会在shouldComponentUpdate里面显示出来。这些component的结构大概如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599262\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599262\x22 alt=\x226\x22 title=\x226\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$$typeof \/\/ 类型\n_owner \/\/ 父组件\n_self: \/\/ 仅开发模式出现\n_source: \/\/  仅开发模式出现\n_store \/\/  仅开发模式出现\nkey \/\/ 组件的key属性值\nprops \/\/ 从传入的props\nref \/\/ 组件的ref属性值\ntype 本组件ReactComponent\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sqf\x22\x3e\x3ccode\x3e$$\x3cspan class=\x22hljs-built_in\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 类型\x3c\/span\x3e\n\x3cspan class=\x22hljs-variable\x22\x3e_owner\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 父组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-variable\x22\x3e_self\x3c\/span\x3e: \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 仅开发模式出现\x3c\/span\x3e\n\x3cspan class=\x22hljs-variable\x22\x3e_source\x3c\/span\x3e: \x3cspan class=\x22hljs-comment\x22\x3e\/\/  仅开发模式出现\x3c\/span\x3e\n\x3cspan class=\x22hljs-variable\x22\x3e_store\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/  仅开发模式出现\x3c\/span\x3e\nkey \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 组件的key属性值\x3c\/span\x3e\nprops \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从传入的props\x3c\/span\x3e\nref \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 组件的ref属性值\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e 本组件ReactComponent\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此，针对component的比较，有一些是可以忽略的，例如\x3ccode\x3e$$typeof, _store, _self, _source, _owner\x3c\/code\x3e。\x3ccode\x3etype\x3c\/code\x3e这个比较复杂，可以比较，但仅限于我们定好的比较深度。如果不做这些忽略，这个深比较将会比较消耗性能。关于这个deepCompare的代码，我放在了\x3ca href=\x22https:\/\/github.com\/lcxfs1991\/pure-render-deepCompare-decorator\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epure-render-deepCompare-decorator\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e不过其实，将component当作props传入更为灵活，而且能够增加组件的复用性，但从上面看来，是比较消耗性能的。看了官方文档之后，我们尝试换种写法，主要就是采用\x3ccode\x3e\x26lt;Scroll\x26gt;\x3c\/code\x3e包裹\x3ccode\x3e\x26lt;List\x26gt;\x3c\/code\x3e的做法，然后用this.props.children在\x3ccode\x3e\x26lt;Scroll\x26gt;\x3c\/code\x3e里面渲染，并将\x3ccode\x3e\x26lt;Empty\x26gt;\x3c\/code\x3e, \x3ccode\x3e\x26lt;Loading\x26gt;\x3c\/code\x3e抽出来。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599264\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599264\x22 alt=\x227\x22 title=\x227\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599266\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599266\x22 alt=\x228\x22 title=\x228\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e本以为React可能会对children这个props有什么特殊处理，但它依然是将children当作props，传入shouldComponentUpdate，这就迫使父元素\x3ccode\x3e\x26lt;Scroll\x26gt;\x3c\/code\x3e要去判断是否要重新渲染，进而跳到子无素\x3ccode\x3e\x26lt;List\x26gt;\x3c\/code\x3e再去判断是否进一步进行渲染。\x3c\/p\x3e\n\x3cp\x3e那\x3ccode\x3e\x26lt;Scroll\x26gt;\x3c\/code\x3e究竟要不要去做这重判断呢？针对列表页这种情况，我们觉得可以暂时不做，由于\x3ccode\x3e\x26lt;Scroll\x26gt;\x3c\/code\x3e包裹的元素不多，\x3ccode\x3e\x26lt;Scroll\x26gt;\x3c\/code\x3e可以先重复渲染，然后再交由子元素\x3ccode\x3e\x26lt;List\x26gt;\x3c\/code\x3e自己再去判断。这样我们对\x3ca href=\x22https:\/\/github.com\/lcxfs1991\/pure-render-deepCompare-decorator\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epure-render-deepCompare-decorator\x3c\/a\x3e要进行一些修改，当轮到props.children判断的时候，我们要求父元素直接重新渲染，这样就能交给子元素去做下一步的处理。\x3c\/p\x3e\n\x3cp\x3e如果\x3ccode\x3e\x26lt;Scroll\x26gt;\x3c\/code\x3e包裹的只有\x3ccode\x3e\x26lt;List\x26gt;\x3c\/code\x3e还好，如果还有像\x3ccode\x3e\x26lt;Empty\x26gt;\x3c\/code\x3e, \x3ccode\x3e\x26lt;Loading\x26gt;\x3c\/code\x3e甚至其它更多的子元素，那\x3ccode\x3e\x26lt;Scroll\x26gt;\x3c\/code\x3e重新渲染会触发其它子元素去运算，判断自己是否要做重新渲染，这就造成了浪费。react的官方论坛上已经有人提出，React的将父子元素的重复渲染的决策都放在shouldComponentUpdate，可能导致了耦合\x3ca href=\x22https:\/\/discuss.reactjs.org\/t\/shouldcomponentupdate-and-children\/2055\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eShouldcomponentupdate And Children\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch4\x3elodash.merge可以解决大部份场景\x3c\/h4\x3e\n\x3cp\x3e此段更新于2016年6月30日\x3cbr\x3e由于immutable的大小问题一直萦绕头上，久久不得散去，因此再去找寻其它的方案。后面决定尝试一下lodash.merge，并用上之前自己写的pureRender。在渲染性能上还可以接受，在仅比immutable差一点点（后面会披露具体数据），但却带来了30kb的减包。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e性能优化小Tips\x3c\/h2\x3e\n\x3cp\x3e这里归纳了一些其它性能优化的小Tips\x3c\/p\x3e\n\x3ch5\x3e请慎用setState，因其容易导致重新渲染\x3c\/h5\x3e\n\x3cp\x3e既然将数据主要交给了Redux来管理，那就尽量使用Redux管理你的数据和状态state，除了少数情况外，别忘了shouldComponentUpdate也需要比较state。\x3c\/p\x3e\n\x3ch5\x3e请将方法的bind一律置于constructor\x3c\/h5\x3e\n\x3cp\x3eComponent的render里不动态bind方法，方法都在constructor里bind好，如果要动态传参，方法可使用闭包返回一个最终可执行函数。如：showDelBtn(item) { return (e) =\x26gt; {}; }。如果每次都在render里面的jsx去bind这个方法，每次都要绑定会消耗性能。\x3c\/p\x3e\n\x3ch5\x3e请只传递component需要的props\x3c\/h5\x3e\n\x3cp\x3e传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担，因此，也请慎用spread attributes（\x26lt;Component {...props} \/\x26gt;）。\x3c\/p\x3e\n\x3ch5\x3e请尽量使用const element\x3c\/h5\x3e\n\x3cp\x3e这个用法是工业聚在React讨论微信群里教会的，我们可以将不怎么变动，或者不需要传入状态的component写成const element的形式，这样能加快这个element的初始渲染速度。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e路由控制与拆包\x3c\/h2\x3e\n\x3cp\x3e当项目变得更大规模与复杂的时候，我们需要设计成SPA，这时路由管理就非常重要了，这使特定url参数能够对应一个页面。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599268\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599268\x22 alt=\x229\x22 title=\x229\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3ePC家校群整个设计是一个中型的SPA，当js bundle太大的时候，需要拆分成几个小的bundle，进行异步加载。这时可以用到webpack的异步加载打包功能，require。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599270\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599270\x22 alt=\x2210\x22 title=\x2210\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在重构手Q家校群布置页的时候，我们有不少的浮层，列表有布置页内容主浮层、同步到多群浮层、科目管理浮层以及指定群成员浮层。这些完全可以使用react-router进行管理。但是由于当时一早使用了Immutablejs，js bundle已经比较大，我们就不打算使用react-router了。但后面仍然发现包比重构前要大一些，因此为了保证首屏时间不慢于重构前，我们希望在不用react-router的情况下进行分包，其实也并不难，如下面2幅图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599272\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599272\x22 alt=\x2212\x22 title=\x2212\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599274\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599274\x22 alt=\x2211\x22 title=\x2211\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e首先在切换浮层方法里面，使用require.ensure，指定要加载哪个包。\x3cbr\x3e在setComponent方法里，将component存在state里面。\x3cbr\x3e在父元素的渲染方法里，当state有值的时候，就会自动渲染加载回来的component。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e性能数据\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e首屏可交互时间\x3c\/h3\x3e\n\x3cp\x3e目前只有列表页发布外网了，我们比较了优化前后的首屏可交互时间，分别有18%和5.3%的提升。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599276\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599276\x22 alt=\x2213\x22 title=\x2213\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005599278\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005599278\x22 alt=\x2214\x22 title=\x2214\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e渲染FPS\x3c\/h3\x3e\n\x3cp\x3e更新于2016年7月2日\x3c\/p\x3e\n\x3ch4\x3eAndroid\x3c\/h4\x3e\n\x3cp\x3eReact重构后第一版，当时还没做任何的优化，发现平均FPS只有22（虽然Android的肉眼感受不出来），而后面使用Immutable或者Lodash.merge都非常接近，能达到42或以上。而手机QQ可接受的FPS最少值是30FPS。因此使用Immutable和Lodash.merge的优化还是相当明显的。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e重构后第一版\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVyJZT?w=540\x26amp;h=960\x22 src=\x22https:\/\/static.alili.tech\/img\/bVyJZT?w=540\x26amp;h=960\x22 alt=\x22before rebuild\x22 title=\x22before rebuild\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eImmutable\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVyJZV?w=540\x26amp;h=960\x22 src=\x22https:\/\/static.alili.tech\/img\/bVyJZV?w=540\x26amp;h=960\x22 alt=\x22Immutable\x22 title=\x22Immutable\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eLodash.merge\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVyJZX?w=540\x26amp;h=960\x22 src=\x22https:\/\/static.alili.tech\/img\/bVyJZX?w=540\x26amp;h=960\x22 alt=\x22Lodash.merge\x22 title=\x22Lodash.merge\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eiOS\x3c\/h4\x3e\n\x3cp\x3e在iOS上的fps差距尤为明显。重构后第一版，拉了大概5屏之后，肉眼会有卡顿的感觉，拉到了10屏之后，数据开始掉到了20多30。而Immutable和Lodash.merge则大部份时间保持在50fps以上，很多时候还能达到非常流畅的60fps。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e重构后第一版\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVyJZY?w=2554\x26amp;h=1542\x22 src=\x22https:\/\/static.alili.tech\/img\/bVyJZY?w=2554\x26amp;h=1542\x22 alt=\x22before rebuild\x22 title=\x22before rebuild\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eImmutable\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVyJZZ?w=2550\x26amp;h=1440\x22 src=\x22https:\/\/static.alili.tech\/img\/bVyJZZ?w=2550\x26amp;h=1440\x22 alt=\x22Immutable\x22 title=\x22Immutable\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eLodash.merge\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVyJZ1?w=1490\x26amp;h=1342\x22 src=\x22https:\/\/static.alili.tech\/img\/bVyJZ1?w=1490\x26amp;h=1342\x22 alt=\x22Lodash.merge\x22 title=\x22Lodash.merge\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eChrome模拟器\x3c\/h4\x3e\n\x3cp\x3e用Chrome模拟器也能看出一些端倪。在Scripting方面，Immutable和Lodash.merge的耗时是最少的，约700多ms，而重构后的第一版则需要1220ms。Lodash.merge在rendering和painting上则没占到优势，但Immutable则要比其它两个要少30% - 40%。由于测试的时候是在PC端，PC端的性能又极好，所以不管是肉眼，还是数据，对于不是很复杂的需求，\x3cb\x3e总体\x3c\/b\x3e的渲染性能看不出非常明显的差距。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e重构后第一版\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVyJZ3?w=1398\x26amp;h=880\x22 src=\x22https:\/\/static.alili.tech\/img\/bVyJZ3?w=1398\x26amp;h=880\x22 alt=\x22before rebuild\x22 title=\x22before rebuild\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eImmutable\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVyJ0d?w=1416\x26amp;h=917\x22 src=\x22https:\/\/static.alili.tech\/img\/bVyJ0d?w=1416\x26amp;h=917\x22 alt=\x22Immutable\x22 title=\x22Immutable\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eLodash.merge\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVyJ0e?w=1409\x26amp;h=800\x22 src=\x22https:\/\/static.alili.tech\/img\/bVyJ0e?w=1409\x26amp;h=800\x22 alt=\x22Lodash.merge\x22 title=\x22Lodash.merge\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e从上面的数据看来，在移动端使用Immutable和Lodash.merge相对于不用，会有较大的性能优势，但Immutable相对于Lodash.merge在我们需求情景下暂时没看出明显的优势，笔者估计可能是由于项目数据规模不大，结构不复杂，因此Immutable的算法优势并没有充分发挥出来。\x3c\/p\x3e\n\x3ch4\x3e测试注明\x3c\/h4\x3e\n\x3cp\x3eAndroid端测试FPS是使用了腾讯开发的\x3ca href=\x22http:\/\/gt.qq.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGT随身调\x3c\/a\x3e。而iOS则使用了Macbook里xCode自带的instrument中的animation功能。Chrome模拟器则使用了Chrome的timeline。测试的方式是匀速滚动列表，拉出数据进行渲染。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3eReact性能优化军规\x3c\/h2\x3e\n\x3cp\x3e我们在开发的过程中，将上面所论述的内容，总结成一个基本的军规，铭记于心，就可以保证React应用的性能不至于太差。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e渲染相关\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e提升级项目性能，请使用immutable(props、state、store)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e请pure-render-decorator与immutablejs搭配使用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e请慎用setState，因其容易导致重新渲染\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e谨慎将component当作props传入\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e请将方法的bind一律置于constructor\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e请只传递component需要的props，避免其它props变化导致重新渲染（慎用spread attributes）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e请在你希望发生重新渲染的dom上设置可被react识别的同级唯一key，否则react在某些情况可能不会重新渲染。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e请尽量使用const element\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3etap事件\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e1. 简单的tap事件，请使用react-tap-event-plugin\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e开发环境时，最好引入webpack的环境变量（仅在开发环境中初始化），在container中初始化。生产环境的时候，请将plugin跟react打包到一起（需要打包在一起才能正常使用，因为plugin对react有好多依赖），外链引入。\x3c\/p\x3e\n\x3cp\x3e目前参考了这个项目的打包方案：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/hartmamt\/react-with-tap-events\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/hartmamt\/r...\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eFacebook官方issue: \x3ca href=\x22https:\/\/github.com\/facebook\/react\/blob\/bef45b0b1a98ea9b472ba664d955a039cf2f8068\/src\/renderers\/dom\/client\/eventPlugins\/TapEventPlugin.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/facebook\/r...\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eReact-tap-event-plugin github: \x3ca href=\x22https:\/\/github.com\/zilverline\/react-tap-event-plugin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/zilverline...\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e2. 复杂的tap事件，建议使用tap component\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e家校群列表页的每个作业的tap交互都比较复杂，出了普通的tap之外，还需要long tap和swipe。因此我们只好自己封装了一个tap component\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3eDebug相关\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e移动端请慎用redux-devtools，易造成卡顿\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eWebpack慎用devtools的inline-source-map模式\x3cbr\x3e使用此模式会内联一大段便于定位bug的字符串，查错时可以开启，不是查错时建议关闭，否则开发时加载的包会非常大。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3e其它\x3c\/h3\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e慎用太新的es6语法。\x3cbr\x3eObject.assign等较新的类库避免在移动端上使用，会报错。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3eObject.assign目前使用object-assign包。或者使用babel-plugin-transform-object-assign插件。会转换成一个extends的函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var _extends = ...;\n\n_extends(a, b);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs verilog\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e = ...;\n\n\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e(a, b);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如有错误，请斧正！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 移动 web 极致优化</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005599249">https://segmentfault.com/a/1190000005599249</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/0po3zxsiwemj/" target="_blank">https://alili.tech/archive/0po3zxsiwemj/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>