<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="angular2 脏检查series1-Zone.js"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>angular2 脏检查series1-Zone.js | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/akg3nb4g1fp/",
				"appid": "1613049289050283", 
				"title": "angular2 脏检查series1-Zone.js | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-04T02:30:58"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fne155tkb6t/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/goqv5ke7jh/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fakg3nb4g1fp%2f&text=angular2%20%e8%84%8f%e6%a3%80%e6%9f%a5series1-Zone.js"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fakg3nb4g1fp%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fakg3nb4g1fp%2f&text=angular2%20%e8%84%8f%e6%a3%80%e6%9f%a5series1-Zone.js"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fakg3nb4g1fp%2f&title=angular2%20%e8%84%8f%e6%a3%80%e6%9f%a5series1-Zone.js"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fakg3nb4g1fp%2f&is_video=false&description=angular2%20%e8%84%8f%e6%a3%80%e6%9f%a5series1-Zone.js"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=angular2%20%e8%84%8f%e6%a3%80%e6%9f%a5series1-Zone.js&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fakg3nb4g1fp%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fakg3nb4g1fp%2f&title=angular2%20%e8%84%8f%e6%a3%80%e6%9f%a5series1-Zone.js"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fakg3nb4g1fp%2f&title=angular2%20%e8%84%8f%e6%a3%80%e6%9f%a5series1-Zone.js"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fakg3nb4g1fp%2f&title=angular2%20%e8%84%8f%e6%a3%80%e6%9f%a5series1-Zone.js"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fakg3nb4g1fp%2f&title=angular2%20%e8%84%8f%e6%a3%80%e6%9f%a5series1-Zone.js"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">angular2 脏检查series1-Zone.js</h1><div class="meta"><div class="postdate"><time datetime="2019-02-04" itemprop="datePublished">2019-02-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3eangular2 脏检查总述\x3c\/h1\x3e\n\x3cp\x3e这系列文章将介绍angular2的脏值检查是如何工作的？如何比ng1更高效？带着上述问题，让我们一起来看看angular2这禽兽（谁让它叫angular，又那么生猛）干了什么。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e什么是脏值检查\x3c\/h3\x3e\n\x3cp\x3e片面的说脏检查是对比当前的数据和曾经的数据是否发生改变。而在这个context下，我想介绍的是angular2从发现数据的变化到找到变化的点到更新DOM的整个过程。也就是说这里所说的脏值检查是Viewmodel与view层的那座桥梁。先看下面的图，红色表示改变的节点。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVCLYD\x22 src=\x22https:\/\/static.alili.tech\/img\/bVCLYD\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e那么问题来了，angular2是如何知道数据发生了改变？又是如何知道需要修改DOM的位置，准确的最小范围的修改DOM呢？没错，尽可能小的范围修改DOM，因为操作DOM对于性能来说可是一件奢侈品。别急，让我们先看看没有angular我们如何实现数据改变到view的改变。在web古老的年代，那个asp.net、j2ee、php的时代，请求\x2b整页重绘，那时啪啪啪的重绘声，如今依然回荡在心中，痛苦不可磨灭。再来看看SPA时代，其它framework的解决方案，最值得一提的是名声在外的react用了diff虚拟DOM的方式，也实现了最小化更新DOM。有兴趣可以看看Tero的这篇博客，比较了很多流行框架对这个问题的解决。  \x3cbr\x3e\x3ca href=\x22http:\/\/teropa.info\/blog\/2015\/03\/02\/change-and-its-detection-in-javascript-frameworks.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/teropa.info\/blog\/2015\/...\x3c\/a\x3e\x3cbr\x3e回到上面问题，angular2是如何知道数据发生了改变？细心的你可能会发现，在angular2 示例项目中都引入了一个Zone.js的东西。Zone.js是什么鬼？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eangular2 脏检查Series1之Zone.js\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eZone能做什么？\x3c\/h3\x3e\n\x3cp\x3eZone提供方便的方式”进入”异步函数执行上下文（注意进入有引号，后面解释），并能在异步执行环境中加入一些钩子的东西。\x3cbr\x3e为什么需要进入异步函数的执行上下文？这是我看到zone.js的github的第一个问题。我们先来看看这样一个场景。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22foo();\nsetTimeout(doSomething, 2000);\nbar();\nbaz();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3efoo();\nsetTimeout(doSomething, \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e);\nbar();\nbaz();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我任性的提出一个问题，我想知道上面doSomething函数在这个上下文中什么时候开始执行的？要知道为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。也就是说doSomething会进入事件循环。 这个时候是不是特别期望，能进入doSomething的执行环境，拿到点证据控告写doSomething这个函数的程序员写得垃圾？可能你已经想到了解决办法，虽然doSomething的执行上下文我进不了。但我可以wrap一下doSomething伪造一个执行上下文，在这个上下文中做点手脚，哼哼.. 恭喜你，你已经有了和Zone.js团队成员一样的思想觉悟。\x3cbr\x3e这也是为什么上面提到的Zone提供方便的方式”进入”异步函数执行上下文中进入加了引号。并不是真正的进入，而是通过包裹的方式伪造执行上下文，并通过钩子函数方便的进入执行环境。这个场景看似有些极端，但在异步Task跟踪，分析，错误记录、开发调试跟踪等场景，都有这样的需求。下面我们来看看Zone是如何提供方便的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eZone如何使用\x3c\/h3\x3e\n\x3cp\x3edemo1\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n        console.log(‘beforeTask time:’\x2bthis.start);\n      },\n      afterTask: function () {\n        time \x2b= timer() - this.start;\n        console.log(‘afterTask time:’\x2btime);\n      }\n    };\n  }());\n\nzone.fork(profilingZone).run(function(){\nfoo();\nsetTimeout(doSomething, 2000);\nbar();\nbaz();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e profilingZone = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e time = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now.bind(\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-attr\x22\x3ebeforeTask\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.start = timer();\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(‘beforeTask time:’\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.start);\n      },\n      \x3cspan class=\x22hljs-attr\x22\x3eafterTask\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        time \x2b= timer() - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.start;\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(‘afterTask time:’\x2btime);\n      }\n    };\n  }());\n\nzone.fork(profilingZone).run(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\nfoo();\nsetTimeout(doSomething, \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e);\nbar();\nbaz();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3edemo1运行结果\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ beforeTask time:3073872.9000000004\n\/\/ AfterTask time:1.04500000039116\n\/\/ beforeTask time:3075873.165\n\/\/ AfterTask time:1.2550000004\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ beforeTask time:3073872.9000000004\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ AfterTask time:1.04500000039116\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ beforeTask time:3075873.165\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ AfterTask time:1.2550000004\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以从上面的demo看到运用Zone提供的beforeTask，afterTask钩子函数方便的进入了doSomething执行的上下文，记录了时间。值得一提的是，我们并没有对doSomething做任何处理，我们所做的只是在doSomething外部做了点改动。就达到了进入doSomething执行上下文的目的。似乎看到了AOP的思想（说到AOP我又想到了ng2的annotation，找个时间好好分享一下）。 除此之外Zone还提供了一些其它钩子函数。请参考：\x3ca href=\x22https:\/\/github.com\/angular\/zone.js#api\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/angular\/zo...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eZone原理\x3c\/h3\x3e\n\x3cp\x3eyo! check it out! demo的运行结果为什么会有输出两次beforeTask和AfterTask？要想解答这个问题，我们先来看看Zone运行的原理。前面提到过Zone伪造一个执行上下文，实际上Zone有一个叫猴子补丁的东西。在Zone.js运行时，就会为这些异步事件做一层代理包裹，也就是说Zone.js运行后，调用setTimeout、addEventListener等浏览器异步事件时，不再是调用原生的方法，而是被猴子补丁包装过后的代理方法。wo！猴子补丁真牛逼，它是怎么把这些原生的事件都进行包装改造后进化成“猴子”的呢？其实很简单，其实并不难..只需要暴力点！再暴力点！\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/以下是Zone.js启动时执行逻辑的抽象代码片段\nfunction zoneAwareAddEventListener() {...}\nfunction zoneAwareRemoveEventListener() {...}\nfunction zoneAwarePromise() {...}\nfunction patchTimeout() {...}\nwindow.prototype.addEventListener = zoneAwareAddEventListener;\nwindow.prototype.removeEventListener = zoneAwareRemoveEventListener;\nwindow.prototype.promise = zoneAwarePromise;\nwindow.prototype.setTimeout = patchTimeout;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/以下是Zone.js启动时执行逻辑的抽象代码片段\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ezoneAwareAddEventListener\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{...}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ezoneAwareRemoveEventListener\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{...}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ezoneAwarePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{...}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epatchTimeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{...}\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.prototype.addEventListener = zoneAwareAddEventListener;\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.prototype.removeEventListener = zoneAwareRemoveEventListener;\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.prototype.promise = zoneAwarePromise;\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.prototype.setTimeout = patchTimeout;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e确实很暴力，直接原生覆盖了！原生的异步方法都被代理覆盖了，代理里setup了钩子函数，这还不能完全解决问题。我们还有个需求，需要“因人而异”的处理这些暴露的钩子函数。例如\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setTimeout(doA, 2000);\nsetTimeout(doB, 2000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetTimeout(doA, \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e);\nsetTimeout(doB, \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里有两个方法doA和doB，总不能用钩子函数里只能做同样的事情吧。所以会有一个根zone和fork。fork可以扩展一个新的zone。而每个zone都有自己的生命周期。为了理解这个问题我们再来看个Demo\x3c\/p\x3e\n\x3cp\x3edemo2\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/fork一个新的zone,我们给它暂定个名字叫temporary zone.\nZone.current.fork({}).run(function () {\n    \/\/调用beforeTask等钩子(zone内部处理)\n    \/\/run 内部Zone.current指向temporary zone（zone内部做的处理），并添加一个inTheZone属性设置为true.\n    Zone.current.inTheZone = true;\n    \/\/调用被猴子补丁包装后的setTimeout方法,并将包装后的greet方法内部的zone设置成当前的temporary zone，并将函数greet加入事件循环.\n    setTimeout(function greet() {\n        console.log(\x27in the zone: \x27 \x2b !!Zone.current.inTheZone);\n    }, 0);\n    \/\/要在zone run中执行的内容已经执行完了,调用AfterTask钩子.(zone内部处理)\n    \/\/    \/\/调用afterTask等钩子.(zone内部处理)\n    \/\/zone.current引用替换成根zone,因为run外部的zone不应该是fork后的zone,fork后的zone生命周期随着run的结束而结束.(zone内部处理)\n});\n\nconsole.log(\x27in the zone: \x27 \x2b !!Zone.current.inTheZone);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/fork一个新的zone,我们给它暂定个名字叫temporary zone.\x3c\/span\x3e\nZone.current.fork({}).run(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用beforeTask等钩子(zone内部处理)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/run 内部Zone.current指向temporary zone（zone内部做的处理），并添加一个inTheZone属性设置为true.\x3c\/span\x3e\n    Zone.current.inTheZone = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用被猴子补丁包装后的setTimeout方法,并将包装后的greet方法内部的zone设置成当前的temporary zone，并将函数greet加入事件循环.\x3c\/span\x3e\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egreet\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27in the zone: \x27\x3c\/span\x3e \x2b !!Zone.current.inTheZone);\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/要在zone run中执行的内容已经执行完了,调用AfterTask钩子.(zone内部处理)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/    \/\/调用afterTask等钩子.(zone内部处理)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/zone.current引用替换成根zone,因为run外部的zone不应该是fork后的zone,fork后的zone生命周期随着run的结束而结束.(zone内部处理)\x3c\/span\x3e\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27in the zone: \x27\x3c\/span\x3e \x2b !!Zone.current.inTheZone);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3edemo2输出结果\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nin the zone: false\nin the zone: true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e the \x3cspan class=\x22hljs-string\x22\x3ezone:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e the \x3cspan class=\x22hljs-string\x22\x3ezone:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e希望更好的理解，我在demo中加了注释以说明zone生命周期的问题.我们可以看到fork后的temporary zone生命周期随着run执行的结束而结束.所以run外部的console.log取不到Zone.current里的属性inTheZone(temporary zone中的inTheZone)而在greet真正执行时,也会经历和run内部一样的过程(钩子函数的执行,zone的引用替换销毁等).而包裹后的greet内部的zone指向的是在setTimeout传入greet上下文中的(当前作用域中)temporary zone.\x3cbr\x3e现在再回头看看demo1中为什么会输出两次beforeTask和AfterTask,也正是因为zone特定的生命周期所造成的.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eZone.js在angular2中的运用\x3c\/h3\x3e\n\x3cp\x3e还记得大明湖畔ng1的$scope.$apply吗？任何原生的事件都不会触发脏检查，必须得调用$scope.$apply来告诉angular。我的数据有更新了，你同步更新下UI吧。而在angular2中有了Zone.js。原生随便用，setTimeout，addEventListener、promise等都在ngZone中执行，angular并在ngZone中setup了相应的钩子，通知angular2做相应的脏检查处理，然后更新DOM。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e如何脏检查？如何更新DOM？比起angular1有什么新的变化？下章再见。希望上述内容能给你一些帮助。如有任何疑问与不足，欢迎指出并讨论。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>angular2 脏检查series1-Zone.js</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006820819">https://segmentfault.com/a/1190000006820819</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/akg3nb4g1fp/" target="_blank">https://alili.tech/archive/akg3nb4g1fp/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>