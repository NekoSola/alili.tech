<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Vue.js源码（1）：Hello World的背后"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Vue.js源码（1）：Hello World的背后 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/h8bmxix5eef/",
				"appid": "1613049289050283", 
				"title": "Vue.js源码（1）：Hello World的背后 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-04T02:30:58"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/6zw4e4s8ey9/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ofu9567aws/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fh8bmxix5eef%2f&text=Vue.js%e6%ba%90%e7%a0%81%ef%bc%881%ef%bc%89%ef%bc%9aHello%20World%e7%9a%84%e8%83%8c%e5%90%8e"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fh8bmxix5eef%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fh8bmxix5eef%2f&text=Vue.js%e6%ba%90%e7%a0%81%ef%bc%881%ef%bc%89%ef%bc%9aHello%20World%e7%9a%84%e8%83%8c%e5%90%8e"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fh8bmxix5eef%2f&title=Vue.js%e6%ba%90%e7%a0%81%ef%bc%881%ef%bc%89%ef%bc%9aHello%20World%e7%9a%84%e8%83%8c%e5%90%8e"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fh8bmxix5eef%2f&is_video=false&description=Vue.js%e6%ba%90%e7%a0%81%ef%bc%881%ef%bc%89%ef%bc%9aHello%20World%e7%9a%84%e8%83%8c%e5%90%8e"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Vue.js%e6%ba%90%e7%a0%81%ef%bc%881%ef%bc%89%ef%bc%9aHello%20World%e7%9a%84%e8%83%8c%e5%90%8e&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fh8bmxix5eef%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fh8bmxix5eef%2f&title=Vue.js%e6%ba%90%e7%a0%81%ef%bc%881%ef%bc%89%ef%bc%9aHello%20World%e7%9a%84%e8%83%8c%e5%90%8e"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fh8bmxix5eef%2f&title=Vue.js%e6%ba%90%e7%a0%81%ef%bc%881%ef%bc%89%ef%bc%9aHello%20World%e7%9a%84%e8%83%8c%e5%90%8e"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fh8bmxix5eef%2f&title=Vue.js%e6%ba%90%e7%a0%81%ef%bc%881%ef%bc%89%ef%bc%9aHello%20World%e7%9a%84%e8%83%8c%e5%90%8e"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fh8bmxix5eef%2f&title=Vue.js%e6%ba%90%e7%a0%81%ef%bc%881%ef%bc%89%ef%bc%9aHello%20World%e7%9a%84%e8%83%8c%e5%90%8e"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Vue.js源码（1）：Hello World的背后</h1><div class="meta"><div class="postdate"><time datetime="2019-02-04" itemprop="datePublished">2019-02-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e下面的代码会在页面上输出Hello World，但是在这个\x3ccode\x3enew Vue()\x3c\/code\x3e到页面渲染之间，到底发生了什么。这篇文章希望通过最简单的例子，去了解Vue源码过程。这里分析的源码版本是\x3ccode\x3eVue.version = \x271.0.20\x27\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \x3cdiv id=\x26quot;mountNode\x26quot;\x3e\x22{{\x22message\x22}}\x22\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e    \x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22mountNode\x22\x3c\/span\x3e\x26gt;\x22{{\x22message\x22}}\x22\x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var vm = new Vue({\n    el: \x27#mountNode\x27,\n    data: function () {\n        return {\n            message: \x27Hello World\x27\n        };\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n    el: \x3cspan class=\x22hljs-string\x22\x3e\x27#mountNode\x27\x3c\/span\x3e,\n    data: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            message: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello World\x27\x3c\/span\x3e\n        };\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这篇文章将要解决几个问题：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3enew Vue()的过程中，内部到底有哪些步骤\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如何收集依赖\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如何计算表达式\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如何表达式的值如何反应在DOM上的\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e简单来说过程是这样的：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eobserve: 把{message: \x27Hello World\x27}变成是reactive的\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecompile: compileTextNode \x22\x22{{\x22message\x22}}\x22\x22，解析出指令(directive = v-text)和表达式(expression = message)，创建fragment(new TextNode)准备替换\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3elink：实例化directive，将创建的fragment和directive链接起来，将fragment替换在DOM上\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ebind: 通过directive对应的watcher获取依赖(message)的值(\x22Hello World\x22)，v-text去update值到fragment上\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e详细过程，接着往下看。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e构造函数\x3c\/h1\x3e\n\x3cp\x3e文件路径：src\/instance\/vue.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Vue (options) {\n  this._init(options)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eVue\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(options)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._init(options)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e初始化\x3c\/h1\x3e\n\x3cp\x3e这里只拿对例子理解最关键的步骤分析。\x3cbr\x3e文件路径：src\/instance\/internal\/init.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.prototype._init = function (options) {\n    ...\n    \/\/ merge options.\n    options = this.$options = mergeOptions(\n      this.constructor.options,\n      options,\n      this\n    )\n    ...\n    \/\/ initialize data observation and scope inheritance.\n    this._initState()\n    ...\n    \/\/ if `el` option is passed, start compilation.\n    if (options.el) {\n      this.$mount(options.el)\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3eVue.prototype._init = function (\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e) {\n    ...\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ merge options.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e = mergeOptions(\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.constructor.\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    )\n    ...\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ initialize data observation and scope inheritance.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._initState()\n    ...\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if `el` option is passed, start compilation.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.el) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$mount(\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.el)\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3emerge options\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3emergeOptions()\x3c\/code\x3e定义在src\/util\/options.js文件中，这里主要定义options中各种属性的合并（merge），例如：props, methods, computed, watch等。另外，这里还定义了每种属性merge的默认算法（strategy），这些strategy都可以配置的，参考\x3ca href=\x22http:\/\/vuejs.org\/guide\/mixins.html#Custom-Option-Merge-Strategies\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCustom Option Merge Strategy\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e在本文的例子中，主要是data选项的merge，在merge之后，放到\x3ccode\x3e$options.data\x3c\/code\x3e中，基本相当于下面这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22vm.$options.data = function mergedInstanceDataFn () {\n      var parentVal = undefined\n      \n      \/\/ 这里就是在我们定义的options中的data\n      var childVal = function () {\n          return {\n              message: \x27Hello World\x27\n          }\n      }\n      \n      \/\/ data function绑定vm实例后执行，执行结果: {message: \x27Hello World\x27}\n      var instanceData = childVal.call(vm)\n      \n      \/\/ 对象之间的merge，类似$.extend，结果肯定就是：{message: \x27Hello World\x27}\n      return mergeData(instanceData, parentVal)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3evm.$options.data = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emergedInstanceDataFn\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parentVal = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里就是在我们定义的options中的data\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e childVal = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n              message: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello World\x27\x3c\/span\x3e\n          }\n      }\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ data function绑定vm实例后执行，执行结果: {message: \x27Hello World\x27}\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instanceData = childVal.call(vm)\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对象之间的merge，类似$.extend，结果肯定就是：{message: \x27Hello World\x27}\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e mergeData(instanceData, parentVal)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3einit data\x3c\/h1\x3e\n\x3cp\x3e\x3ccode\x3e_initData()\x3c\/code\x3e发生在\x3ccode\x3e_initState()\x3c\/code\x3e中，主要做了两件事：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e代理data中的属性\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eobserve data\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e文件路径：src\/instance\/internal\/state.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.prototype._initState = function () {\n    this._initProps()\n    this._initMeta()\n    this._initMethods()\n    this._initData() \/\/ 这里\n    this._initComputed()\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eVue.prototype._initState = function () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._initProps()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._initMeta()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._initMethods()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._initData() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._initComputed()\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e属性代理（proxy）\x3c\/h3\x3e\n\x3cp\x3e把data的结果赋值给内部属性：\x3cbr\x3e文件路径：src\/instance\/internal\/state.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var dataFn = this.$options.data \/\/ 上面我们得到的mergedInstanceDataFn函数\nvar data = this._data = dataFn ? dataFn() : {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dataFn = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上面我们得到的mergedInstanceDataFn函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._data = dataFn ? dataFn() : {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代理（proxy）\x3ccode\x3edata\x3c\/code\x3e中的属性到\x3ccode\x3e_data\x3c\/code\x3e，使得\x3ccode\x3evm.message === vm._data.message\x3c\/code\x3e：\x3cbr\x3e文件路径：src\/instance\/internal\/state.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n  * Proxy a property, so that\n  * vm.prop === vm._data.prop\n  *\/\nVue.prototype._proxy = function (key) {\n    if (!isReserved(key)) {\n      var self = this\n      Object.defineProperty(self, key, {\n        configurable: true,\n        enumerable: true,\n        get: function proxyGetter () {\n          return self._data[key]\n        },\n        set: function proxySetter (val) {\n          self._data[key] = val\n        }\n      })\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n  * Proxy a property, so that\n  * vm.prop === vm._data.prop\n  *\/\x3c\/span\x3e\nVue.prototype._proxy = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(key)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isReserved(key)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e = this\n      Object.defineProperty(\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e, key, {\n        configurable: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e,\n        enumerable: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e,\n        get: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproxyGetter\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._data[key]\n        },\n        set: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproxySetter\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(val)\x3c\/span\x3e \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._data[key] = val\n        }\n      })\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader5\x22\x3eobserve\x3c\/h1\x3e\n\x3cp\x3e这里是我们的第一个重点，observe过程。在\x3ccode\x3e_initData()\x3c\/code\x3e最后，调用了\x3ccode\x3eobserve(data, this)\x3c\/code\x3e对数据进行observe。在hello world例子里，\x3ccode\x3eobserve()\x3c\/code\x3e函数主要是针对\x3ccode\x3e{message: \x27Hello World\x27}\x3c\/code\x3e创建了Observer对象。\x3cbr\x3e文件路径：src\/observer\/index.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var ob = new Observer(value) \/\/ value = data = {message:\x27Hello World\x27}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-title\x22\x3evar\x3c\/span\x3e ob = new \x3cspan class=\x22hljs-type\x22\x3eObserver\x3c\/span\x3e(value) \/\/ value = \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = {\x3cspan class=\x22hljs-title\x22\x3emessage\x3c\/span\x3e:\x27\x3cspan class=\x22hljs-type\x22\x3eHello\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eWorld\x3c\/span\x3e\x27}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3eobserve()\x3c\/code\x3e函数中还做了些能否observe的条件判断，这些条件有：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e没有被observe过（observe过的对象都会被添加\x3ccode\x3e__ob__\x3c\/code\x3e属性）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e只能是plain object（\x3ccode\x3etoString.call(ob) === \x22[object Object]\x22\x3c\/code\x3e）或者数组\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不能是Vue实例（\x3ccode\x3eobj._isVue !== true\x3c\/code\x3e）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eobject是extensible的（\x3ccode\x3eObject.isExtensible(obj) === true\x3c\/code\x3e）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eObserver\x3c\/h3\x3e\n\x3cp\x3e官网的\x3ca href=\x22http:\/\/vuejs.org\/guide\/reactivity.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReactivity in Depth\x3c\/a\x3e上有这么句话：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eWhen you pass a plain JavaScript object to a Vue instance as its data option, Vue.js will walk through all of its properties and convert them to getter\/setters \x3c\/p\x3e\n\x3cp\x3eThe getter\/setters are invisible to the user, but under the hood they enable Vue.js to perform dependency-tracking and change-notification when properties are accessed or modified\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3eObserver就是干这个事情的，使data变成“发布者”，watcher是订阅者，订阅data的变化。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVx1bI\x22 src=\x22https:\/\/static.alili.tech\/img\/bVx1bI\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在例子中，创建observer的过程是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3enew Observer({message: \x27Hello World\x27})\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e实例化一个Dep对象，用来收集依赖\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ewalk（\x3ccode\x3eObserver.prototype.walk()\x3c\/code\x3e）数据的每一个属性，这里只有message\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将属性变成reactive的(\x3ccode\x3eObserver.protoype.convert()\x3c\/code\x3e)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3ccode\x3econvert()\x3c\/code\x3e里调用了\x3ccode\x3edefineReactive()\x3c\/code\x3e，给data的message属性添加reactiveGetter和reactiveSetter\x3cbr\x3e文件路径：src\/observer\/index.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function defineReactive (obj, key, value) {\n    ...\n    Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      ...\n      if (Dep.target) {\n        dep.depend() \/\/ 这里是收集依赖\n        ...\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      ...\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      ...\n      dep.notify() \/\/ 这里是notify观察这个数据的依赖（watcher）\n    }\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineReactive\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eobj, key, value\x3c\/span\x3e) \x3c\/span\x3e{\n    ...\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\n    \x3cspan class=\x22hljs-attribute\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attribute\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attribute\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      ...\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n        dep.depend() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里是收集依赖\x3c\/span\x3e\n        ...\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n    },\n    \x3cspan class=\x22hljs-attribute\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveSetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e) \x3c\/span\x3e{\n      ...\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (setter) {\n        setter.call(obj, newVal)\n      } \x3cspan class=\x22hljs-title\x22\x3eelse\x3c\/span\x3e {\n        val = newVal\n      }\n      ...\n      dep.notify() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里是notify观察这个数据的依赖（watcher）\x3c\/span\x3e\n    }\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于依赖收集和notify，主要是\x3ccode\x3eDep\x3c\/code\x3e类\x3cbr\x3e文件路径：src\/observer\/dep.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default function Dep () {\n  this.id = uid\x2b\x2b\n  this.subs = []\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDep\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = uid\x2b\x2b\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs = []\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的subs是保存着订阅者（即watcher）的数组，当被观察数据发生变化时，即被调用setter，那么\x3ccode\x3edep.notify()\x3c\/code\x3e就循环这里的订阅者，分别调用他们的update方法。\x3c\/p\x3e\n\x3cp\x3e但是在getter收集依赖的代码里，并没有看到watcher被添加到subs中，什么时候添加进去的呢？这个问题在讲到Watcher的时候再回答。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader7\x22\x3emount node\x3c\/h1\x3e\n\x3cp\x3e按照生命周期图上，observe data和一些init之后，就是\x3ccode\x3e$mount\x3c\/code\x3e了，最主要的就是\x3ccode\x3e_compile\x3c\/code\x3e。\x3cbr\x3e文件路径：src\/instance\/api\/lifecycle.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.prototype.$mount = function (el) {\n    ...\n    this._compile(el)\n    ...\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e.proto\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.$mount = function (el) {\n    ...\n    this._compile(el)\n    ...\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_compile\x3c\/code\x3e里分两步：compile和link\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3ecompile\x3c\/h3\x3e\n\x3cp\x3ecompile过程是分析给定元素（el）或者模版（template），提取指令（directive）和创建对应离线的DOM元素（document fragment）。\x3c\/p\x3e\n\x3cp\x3e文件路径：src\/instance\/internal\/lifecycle.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.prototype._compile = function (el) {\n    ...\n    var rootLinker = compileRoot(el, options, contextOptions)\n    ...\n    var rootUnlinkFn = rootLinker(this, el, this._scope)\n    ...\n    var contentUnlinkFn = compile(el, options)(this, el)\n    ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eVue.prototype._compile = function (el) {\n    ...\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rootLinker = compileRoot(el, options, contextOptions)\n    ...\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rootUnlinkFn = rootLinker(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, el, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._scope)\n    ...\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e contentUnlinkFn = compile(el, options)(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, el)\n    ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e例子中compile #mountNode元素，大致过程如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3ecompileRoot：由于root node（\x3ccode\x3e\x26lt;div id=\x22mountNode\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e）本身没有任何指令，所以这里compile不出什么东西\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecompileChildNode：mountNode的子node，即内容为\x22\x22{{\x22message\x22}}\x22\x22的TextNode\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecompileTextNode：\x3cbr\x3e   3.1 parseText：其实就是tokenization（标记化：从字符串中提取符号，语句等有意义的元素），得到的结果是tokens\x3cbr\x3e   3.2 processTextToken：从tokens中分析出指令类型，表达式和过滤器，并创建新的空的TextNode\x3cbr\x3e   3.3 创建fragment，将新的TextNode append进去\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eparseText的时候，通过正则表达式（\x3ccode\x3e\/\\{\\{\\{(.\x2b?)\\}\\}\\}|\\{\\{(.\x2b?)\\}\\}\/g\x3c\/code\x3e）匹配字符串\x22\x22{{\x22message\x22}}\x22\x22，得出的token包含这些信息：“这是个tag，而且是文本（text）而非\x3ca href=\x22http:\/\/vuejs.org\/guide\/syntax.html#Raw-HTML\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHTML\x3c\/a\x3e的tag，不是一次性的插值（\x3ca href=\x22http:\/\/vuejs.org\/guide\/syntax.html#Text\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eone-time interpolation\x3c\/a\x3e），tag的内容是\x22message\x22”。这里用来做匹配的正则表达式是会根据\x3ca href=\x22http:\/\/vuejs.org\/api\/#delimiters\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edelimiters\x3c\/a\x3e和\x3ca href=\x22http:\/\/vuejs.org\/api\/#unsafeDelimiters\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eunsafeDelimiters\x3c\/a\x3e的配置动态生成的。\x3c\/p\x3e\n\x3cp\x3eprocessTextToken之后，其实就得到了创建指令需要的所有信息：指令类型v-text，表达式\x22message\x22，过滤器无，并且该指令负责跟进的DOM是新创建的TextNode。接下来就是实例化指令了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3elink\x3c\/h3\x3e\n\x3cp\x3e每个compile函数之后都会返回一个link function（linkFn）。linkFn就是去实例化指令，将指令和新建的元素link在一起，然后将元素替换到DOM tree中去。\x3cbr\x3e每个linkFn函数都会返回一个unlink function（unlinkFn）。unlinkFn是在vm销毁的时候用的，这里不介绍。\x3c\/p\x3e\n\x3cp\x3e实例化directive：\x3ccode\x3enew Directive(description, vm, el)\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3edescription\x3c\/code\x3e是compile结果token中保存的信息，内容如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22description = {\n    name: \x27text\x27, \/\/ text指令\n    expression: \x27message\x27,\n    filters: undefined,\n    def: vTextDefinition\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elixir\x22\x3e\x3ccode\x3edescription = {\n    \x3cspan class=\x22hljs-symbol\x22\x3ename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27text\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e text指令\n    \x3cspan class=\x22hljs-symbol\x22\x3eexpression:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27message\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-symbol\x22\x3efilters:\x3c\/span\x3e undefined,\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edef\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3evTextDefinition\x3c\/span\x3e\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3edef属性上的是text指令的定义（definition），和\x3ca href=\x22http:\/\/vuejs.org\/guide\/custom-directive.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCustome Directive\x3c\/a\x3e一样，text指令也有bind和update方法，其定义如下：\x3c\/p\x3e\n\x3cp\x3e文件路径：src\/directives\/public\/text.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default {\n\n  bind () {\n    this.attr = this.el.nodeType === 3\n      ? \x27data\x27\n      : \x27textContent\x27\n  },\n\n  update (value) {\n    this.el[this.attr] = _toString(value)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e {\n\n  bind () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.attr = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.el.nodeType === \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n      ? \x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e\n      : \x3cspan class=\x22hljs-string\x22\x3e\x27textContent\x27\x3c\/span\x3e\n  },\n\n  update (value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.el[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.attr] = _toString(value)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3enew Directive()\x3c\/code\x3e构造函数里面只是一些内部属性的赋值，真正的绑定过程还需要调用\x3ccode\x3eDirective.prototype._bind\x3c\/code\x3e，它是在Vue实例方法\x3ccode\x3e_bindDir()\x3c\/code\x3e中被调用的。\x3cbr\x3e在_bind里面，会创建watcher，并第一次通过watcher去获得表达式\x22message\x22的计算值，更新到之前新建的TextNode中去，完成在页面上渲染\x22Hello World\x22。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3ewatcher\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3eFor every directive \/ data binding in the template, there will be a corresponding watcher object, which records any properties “touched” during its evaluation as dependencies. Later on when a dependency’s setter is called, it triggers the watcher to re-evaluate, and in turn causes its associated directive to perform DOM updates.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e每个与数据绑定的directive都有一个watcher，帮它监听表达式的值，如果发生变化，则通知它update自己负责的DOM。一直说的dependency collection就在这里发生。\x3c\/p\x3e\n\x3cp\x3eDirective.prototype._bind()里面，会\x3ccode\x3enew Watcher(expression, update)\x3c\/code\x3e，把表达式和directive的update方法传进去。\x3c\/p\x3e\n\x3cp\x3eWatcher会去\x3ccode\x3eparseExpression\x3c\/code\x3e：\x3cbr\x3e文件路径：src\/parsers\/expression.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function parseExpression (exp, needSet) {\n  exp = exp.trim()\n  \/\/ try cache\n  var hit = expressionCache.get(exp)\n  if (hit) {\n    if (needSet \x26amp;\x26amp; !hit.set) {\n      hit.set = compileSetter(hit.exp)\n    }\n    return hit\n  }\n  var res = { exp: exp }\n  res.get = isSimplePath(exp) \x26amp;\x26amp; exp.indexOf(\x27[\x27) \x3c 0\n    \/\/ optimized super simple getter\n    ? makeGetterFn(\x27scope.\x27 \x2b exp)\n    \/\/ dynamic getter\n    : compileGetter(exp)\n  if (needSet) {\n    res.set = compileSetter(exp)\n  }\n  expressionCache.put(exp, res)\n  return res\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vim\x22\x3e\x3ccode\x3eexport \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eparseExpression\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(exp, needSet)\x3c\/span\x3e {\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e.trim()\n  \/\/ \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e cache\n  var hit = expressionCache.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hit) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (needSet \x26amp;\x26amp; !hit.\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e) {\n      hit.\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e = compileSetter(hit.\x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e)\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hit\n  }\n  var \x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e = { \x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e }\n  \x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e = isSimplePath(\x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e) \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27[\x27\x3c\/span\x3e) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \/\/ optimized super simple getter\n    ? makeGetterFn(\x3cspan class=\x22hljs-string\x22\x3e\x27scope.\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e)\n    \/\/ dynamic getter\n    : compileGetter(\x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (needSet) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e = compileSetter(\x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e)\n  }\n  expressionCache.\x3cspan class=\x22hljs-keyword\x22\x3eput\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eexp\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的expression是\x22message\x22，单一变量，被认为是简单的数据访问路径（simplePath）。simplePath的值如何计算，怎么通过\x22message\x22字符串获得data.message的值呢？\x3cbr\x3e获取字符串对应的变量的值，除了用eval，还可以用Function。上面的\x3ccode\x3emakeGetterFn(\x27scope.\x27 \x2b exp)\x3c\/code\x3e返回：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var getter = new Function(\x27scope\x27, \x27return \x27 \x2b body \x2b \x27;\x27) \/\/ new Function(\x27scope\x27, \x27return scope.message;\x27)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3evar getter = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-symbol\x22\x3e\x27scope\x3c\/span\x3e\x27, \x3cspan class=\x22hljs-symbol\x22\x3e\x27return\x3c\/span\x3e \x27 \x2b \x3cspan class=\x22hljs-keyword\x22\x3ebody\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27;\x27\x3c\/span\x3e) \/\/ \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-symbol\x22\x3e\x27scope\x3c\/span\x3e\x27, \x3cspan class=\x22hljs-symbol\x22\x3e\x27return\x3c\/span\x3e scope.message;\x27)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eWatch.prototype.get()获取表达式值的时候，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var scope = this.vm\ngetter.call(scope, scope) \/\/ 即执行vm.message\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs d\x22\x3e\x3ccode\x3evar \x3cspan class=\x22hljs-keyword\x22\x3escope\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm\ngetter.call(\x3cspan class=\x22hljs-keyword\x22\x3escope\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3escope\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 即执行vm.message\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于initState时对数据进行了代理（proxy），这里的vm.message即为vm._data.message，即是data选项中定义的\x22Hello World\x22。\x3c\/p\x3e\n\x3cp\x3e值拿到了，那什么时候将message设为依赖的呢？这就要结合前面observe data里说到的\x3ccode\x3ereactiveGetter\x3c\/code\x3e了。\x3cbr\x3e文件路径：src\/watcher.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Watcher.prototype.get = function () {\n  this.beforeGet()        \/\/ -\x3e Dep.target = this\n  var scope = this.scope || this.vm\n  ...\n  var value value = this.getter.call(scope, scope)\n  ...\n  this.afterGet()         \/\/ -\x3e Dep.target = null\n  return value\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eWatcher.prototype.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e = function () {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.beforeGet()        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ -\x26gt; Dep.target = this\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scope || \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm\n  ...\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter.call(scope, scope)\n  ...\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.afterGet()         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ -\x26gt; Dep.target = null\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ewatcher获取表达式的值分三步：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3ebeforeGet：设置\x3ccode\x3eDep.target = this\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e调用表达式的getter，读取（getter）vm.message的值，进入了message的reactiveGetter，由于Dep.target有值，因此执行了\x3ccode\x3edep.depend()\x3c\/code\x3e将target，即当前watcher，收入dep.subs数组里\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eafterGet：设置\x3ccode\x3eDep.target = null\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这里值得注意的是\x3ccode\x3eDep.target\x3c\/code\x3e，由于JS的单线程特性，同一时刻只能有一个watcher去get数据的值，所以target在全局下只需要有一个就可以了。\x3cbr\x3e文件路径：src\/observer\/dep.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ the current target watcher being evaluated.\n\/\/ this is globally unique because there could be only one\n\/\/ watcher being evaluated at any time.\nDep.target = null\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ the current target watcher being evaluated.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ this is globally unique because there could be only one\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ watcher being evaluated at any time.\x3c\/span\x3e\nDep.\x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就这样，指令通过watcher，去touch了表达式中涉及到的数据，同时被该数据（reactive data）保存为其变化的订阅者（subscriber），数据变化时，通过dep.notify() -\x26gt; watcher.update() -\x26gt; directive.update() -\x26gt; textDirective.update()，完成DOM的更新。\x3c\/p\x3e\n\x3cp\x3e到这里，“Hello World”怎么渲染到页面上的过程基本就结束了。这里针对最简单的使用，挑选了最核心的步骤进行分析，更多内部细节，后面慢慢分享。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Vue.js源码（1）：Hello World的背后</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006866881">https://segmentfault.com/a/1190000006866881</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/h8bmxix5eef/" target="_blank">https://alili.tech/archive/h8bmxix5eef/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>