<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Ajax局部页面刷新和History API结合的陷阱"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Ajax局部页面刷新和History API结合的陷阱 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/oe3y59qcal/",
				"appid": "1613049289050283", 
				"title": "Ajax局部页面刷新和History API结合的陷阱 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-05T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fgmhl36ltzd/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/64nerx21sx5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2foe3y59qcal%2f&text=Ajax%e5%b1%80%e9%83%a8%e9%a1%b5%e9%9d%a2%e5%88%b7%e6%96%b0%e5%92%8cHistory%20API%e7%bb%93%e5%90%88%e7%9a%84%e9%99%b7%e9%98%b1"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2foe3y59qcal%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2foe3y59qcal%2f&text=Ajax%e5%b1%80%e9%83%a8%e9%a1%b5%e9%9d%a2%e5%88%b7%e6%96%b0%e5%92%8cHistory%20API%e7%bb%93%e5%90%88%e7%9a%84%e9%99%b7%e9%98%b1"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2foe3y59qcal%2f&title=Ajax%e5%b1%80%e9%83%a8%e9%a1%b5%e9%9d%a2%e5%88%b7%e6%96%b0%e5%92%8cHistory%20API%e7%bb%93%e5%90%88%e7%9a%84%e9%99%b7%e9%98%b1"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2foe3y59qcal%2f&is_video=false&description=Ajax%e5%b1%80%e9%83%a8%e9%a1%b5%e9%9d%a2%e5%88%b7%e6%96%b0%e5%92%8cHistory%20API%e7%bb%93%e5%90%88%e7%9a%84%e9%99%b7%e9%98%b1"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Ajax%e5%b1%80%e9%83%a8%e9%a1%b5%e9%9d%a2%e5%88%b7%e6%96%b0%e5%92%8cHistory%20API%e7%bb%93%e5%90%88%e7%9a%84%e9%99%b7%e9%98%b1&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2foe3y59qcal%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2foe3y59qcal%2f&title=Ajax%e5%b1%80%e9%83%a8%e9%a1%b5%e9%9d%a2%e5%88%b7%e6%96%b0%e5%92%8cHistory%20API%e7%bb%93%e5%90%88%e7%9a%84%e9%99%b7%e9%98%b1"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2foe3y59qcal%2f&title=Ajax%e5%b1%80%e9%83%a8%e9%a1%b5%e9%9d%a2%e5%88%b7%e6%96%b0%e5%92%8cHistory%20API%e7%bb%93%e5%90%88%e7%9a%84%e9%99%b7%e9%98%b1"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2foe3y59qcal%2f&title=Ajax%e5%b1%80%e9%83%a8%e9%a1%b5%e9%9d%a2%e5%88%b7%e6%96%b0%e5%92%8cHistory%20API%e7%bb%93%e5%90%88%e7%9a%84%e9%99%b7%e9%98%b1"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2foe3y59qcal%2f&title=Ajax%e5%b1%80%e9%83%a8%e9%a1%b5%e9%9d%a2%e5%88%b7%e6%96%b0%e5%92%8cHistory%20API%e7%bb%93%e5%90%88%e7%9a%84%e9%99%b7%e9%98%b1"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Ajax局部页面刷新和History API结合的陷阱</h1><div class="meta"><div class="postdate"><time datetime="2019-02-05" itemprop="datePublished">2019-02-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eajax在现代网站已经得到非常普遍地应用，主要的好处大家都知道（异步加载数据，不用刷新整个浏览器，更小的数据传输尺寸）。对于那些老网站或者老项目来说全盘改造成ajax并不现实，于是就有了“局部页面刷新”这个解决方案。如果不知道“局部页面刷新”是何物请看\x3ca href=\x22http:\/\/msdn.microsoft.com\/en-us\/library\/bb386573%5C%28v=vs.140%5C%29.aspx\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e，\x3ca href=\x22http:\/\/api.jquery.com\/load\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e和\x3ca href=\x22http:\/\/amberonrails.com\/ajax-partial-loading\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e在我们的项目里，将原来的\x3ccode\x3eiframe\x3c\/code\x3e或者\x3ccode\x3eframe\x3c\/code\x3e统统替换成了时髦的\x3ccode\x3ediv\x3c\/code\x3e，然后修改了页面上所有发起请求的地方，把响应内容\x3ccode\x3ejQuery.load\x3c\/code\x3e到\x3ccode\x3ediv\x3c\/code\x3e里。\x3c\/p\x3e\n\x3cp\x3e于是乎原来老旧的网站变成了一个时髦的基于ajax的网站，每个页面传输的数据量变小了，再也不用解决令人头疼的:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e为了消除滚动条让\x3ca href=\x22http:\/\/www.codeproject.com\/Articles\/19499\/How-To-Adjust-IFrame-Height-on-Its-Content\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eiframe自适应大小\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/stackoverflow.com\/questions\/14941504\/how-to-access-parent-window-javascript-variable-inside-child-windowpop-up\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e如何访问parent window变量\x3c\/a\x3e的问题(还有如何访问parent的parent的parent... window变量的问题)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/stackoverflow.com\/questions\/14366841\/accessing-javascript-variable-in-an-iframe-from-the-parent-window-on-same-domai\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e如何访问child iframe里的变量\x3c\/a\x3e[]的问题了(还有如何访问child的child的child... iframe里的变量的问题)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e因为大家永远都在同一个window里，而且div本身就会根据内容自动撑大。但是等等！浏览器怎么不能后退了？\x3c\/p\x3e\n\x3cp\x3e我们的那个项目是一个满大街可见的\x3cstrong\x3e\x3cem\x3eXX管理信息系统\x3c\/em\x3e\x3c\/strong\x3e，这种系统最常见的布局就是左侧一个树形菜单区域，右侧是一个功能区域，功能区域里有一个查询条件区域（里面有个查询按钮），还有一个空白的区域用来显示查询结果，同时是用户操作数据的地方（比如form表单）。\x3c\/p\x3e\n\x3cp\x3e在iframe时代，上面讲到的4个区域都是一个iframe，这也就意味着我们可以有很变态的后退能力。\x3cbr\x3e当然了一般来说用户最常用的就是对操作区域做后退动作，比如查询一下，选择一条记录点击修改，看到form表单，修改一下，在点击保存前后悔了，点击浏览器的后退，回到查询结果页面。\x3c\/p\x3e\n\x3cp\x3e但是在引入了ajax后无法后退了，因为ajax请求不会记录到浏览器历史里，历史都没有了自然就无法后退了。\x3c\/p\x3e\n\x3cp\x3e好在Html5的History API能够帮助我们解决问题。我们可以人为的使用\x3ccode\x3ehistory.pushState\x3c\/code\x3e来人造历史信息，并且通过监听\x3ccode\x3epopstate\x3c\/code\x3e事件来知道用户点击了浏览器后退或前进按钮，然后将页面元素还原到历史上的某个状态。关于Html5 History API的相关信息可以看\x3ca href=\x22http:\/\/diveintohtml5.info\/history.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e但是事情远不止这么简单，下面是我们遇到的一些坑：\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e陷阱1：重复执行js脚本\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 点击查询按钮的时候人为构造一个浏览器历史\n$(\x27#some-button\x27).click(function() {\n  $(targetSelector).load(url);\n\n  history.pushState({\n    container : targetSelector,\n    content   : $(targetSelector).html()\n  }, null, url);\n\n});\n\n\/\/ 当浏览器后退后者前进的时候，我们把当时的结果重新加载到container里来\nwindow.addEventListener(\x27popstate\x27, function() {\n  var state = history.state\n  $(state.container).html(state.content);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 点击查询按钮的时候人为构造一个浏览器历史\x3c\/span\x3e\n$(\x3cspan class=\x22hljs-string\x22\x3e\x27#some-button\x27\x3c\/span\x3e).click(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  $(targetSelector).load(url);\n\n  history.pushState({\n    \x3cspan class=\x22hljs-attr\x22\x3econtainer\x3c\/span\x3e : targetSelector,\n    \x3cspan class=\x22hljs-attr\x22\x3econtent\x3c\/span\x3e   : $(targetSelector).html()\n  }, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, url);\n\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当浏览器后退后者前进的时候，我们把当时的结果重新加载到container里来\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27popstate\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e state = history.state\n  $(state.container).html(state.content);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一切看上去都OK，直到...我们发现局部页面刷新所获得的结果里包含了操作dom元素的js。\x3c\/p\x3e\n\x3cp\x3e当遇到这种情况时会发生很奇妙的现象，history state.content是已经加载完毕\x2bjs执行后的结果，当我们重新还原的时候，我们会把这个结果加载出来，\x3cstrong\x3e并且又会执行一遍js\x3c\/strong\x3e。如果这个js是一个添加dom的动作那么在后退的时候你会看到这个重复的dom元素。\x3c\/p\x3e\n\x3cp\x3e我们想过跟踪哪些dom元素是被js修改过的来避免这个问题，但是...这是不现实的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e陷阱2：无法还原到最初状态\x3c\/h2\x3e\n\x3cp\x3e前面的方案因为load的内容里可能有js脚本所以有严重缺陷，于是我们换了个思路，history里保存responseText，而不是已经load好后的东西。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 点击查询按钮的时候人为构造一个浏览器历史\n$(\x27#some-button\x27).click(function() {\n  $(targetSelector).load(url, function(responseText) {\n    history.pushState({\n      container : targetSelector,\n      content   : responseText\n    }, null, url);\n  });\n});\n\n\/\/ popstate事件的处理方式一样\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 点击查询按钮的时候人为构造一个浏览器历史\x3c\/span\x3e\n$(\x3cspan class=\x22hljs-string\x22\x3e\x27#some-button\x27\x3c\/span\x3e).click(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  $(targetSelector).load(url, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponseText\x3c\/span\x3e) \x3c\/span\x3e{\n    history.pushState({\n      \x3cspan class=\x22hljs-attr\x22\x3econtainer\x3c\/span\x3e : targetSelector,\n      \x3cspan class=\x22hljs-attr\x22\x3econtent\x3c\/span\x3e   : responseText\n    }, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, url);\n  });\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ popstate事件的处理方式一样\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是仍然遇到了这么一个问题，如果container（刷新目标区域，某个div）原来是有内容的，而这个内容不是通过ajax局部页面刷新而来，而是用户一进入这个页面就已经有的，比如使用服务器端的模板引擎生成的页面，那么在它加载完html片段后就无法回退了。因为它的内容一开始就不在history里（事实上浏览器自己产生的history是没有state的），这样就形成了退无可退的局面。\x3c\/p\x3e\n\x3cp\x3e如果你想，我们只要保存这个container原来的内容不就行了，当后退的时候我们直接恢复它原来的内容，但是请看\x3cstrong\x3e陷阱1\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e不过当发生退无可退的情况时，我们认为已经退回到了第一次进入页面的状态，这个时候我们刷新整个页面就行了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e陷阱3：多个并列的container\x3c\/h2\x3e\n\x3cp\x3e陷阱2的解决方案实际上是基于container之间是属于嵌套关系或者就一个container的情况的。如果是这种情况就不行了：\x3c\/p\x3e\n\x3cp\x3e有A和B两个container，点击某个按钮刷新了A的内容（产生历史），然后在点击某个按钮刷新的B的按钮（产生历史），按照用户的预想情况，第一次后退还原B原来的内容，第二次后退还原A原来的内容。但实际上，第一次后退无法还原B的内容（陷阱2），第二次后退页面刷新了（一切恢复最初的样子）。\x3c\/p\x3e\n\x3cp\x3e如果B是嵌套在A里的就无所谓了，第一次后退的时候获得的是A的state，根据A的state还原A的内容的时候顺便把B也还原了，第二次后退页面刷新，把A也还原了。\x3c\/p\x3e\n\x3cp\x3e而且根据\x3cstrong\x3e陷阱1\x3c\/strong\x3e所讲，我们也不能在history里存储A或者B里原来的内容。\x3c\/p\x3e\n\x3cp\x3e解决办法：对于这种操作就不要记录历史了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e陷阱4：看到过时页面\x3c\/h2\x3e\n\x3cp\x3e我们在History state里存的是当时load时的responseText，当我们后退的时候看到的是过时的页面，比如我们原先查询结果里看到有A记录，然后我们跳转到其他页面里，然后再后退到查询结果页面看到A记录还在，但是这个A记录很可能只是一个幽灵，在数据库里早就已经不存在了。如果我们这个时候再对A记录操作就有出现错误。\x3c\/p\x3e\n\x3cp\x3e解决办法是我们在history state里保存url已经相关的参数，当popstate的时候重新发起请求就行了，这样一来的话也减少了history存储state所需要的空间。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这里只给get请求的例子，post的原理也差不多\n$(\x27#some-button\x27).click(function() {\n  $(targetSelector).load(url, function(responseText) {\n    history.pushState({\n      container : targetSelector,\n      url       : url\n    }, null, url);\n  });\n});\n\nwindow.addEventListener(\x27popstate\x27, function() {\n  var state = history.state;\n  $(state.container).load(state.url);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里只给get请求的例子，post的原理也差不多\x3c\/span\x3e\n$(\x3cspan class=\x22hljs-string\x22\x3e\x27#some-button\x27\x3c\/span\x3e).click(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  $(targetSelector).load(url, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponseText\x3c\/span\x3e) \x3c\/span\x3e{\n    history.pushState({\n      \x3cspan class=\x22hljs-attr\x22\x3econtainer\x3c\/span\x3e : targetSelector,\n      \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e       : url\n    }, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, url);\n  });\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27popstate\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e state = history.state;\n  $(state.container).load(state.url);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e陷阱5：redirect\x3c\/h2\x3e\n\x3cp\x3e即使我们在history state保存了url你就以为没事了？too simple, too naive！如果我们对这个url发起的请求被服务器redirect到另一个url，那么在history state里保存这个url就不对了。\x3c\/p\x3e\n\x3cp\x3e如果我们这个url是用来删除某条记录的，服务器收到请求在数据库里删除了这条记录，然后redirect到了首页url，那么这个时候你在history里应该存那个url呢？显然是首页的url，因为如果你存了删除url，那么在后退的时候，我们会重新发起这个url，想想这多吓人。\x3c\/p\x3e\n\x3cp\x3e解决办法其实不太简单，因为ajax是否被redirect你是不知道的，用jQuery封装的jqXHR对象也没法知道这个。\x3c\/p\x3e\n\x3cp\x3e也许\x3ca href=\x22https:\/\/xhr.spec.whatwg.org\/#the-responseurl-attribute\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e链WHATWG的XmlHttpRequest.responseURL\x3c\/a\x3e可以救你，但是浏览器兼容性不好。\x3c\/p\x3e\n\x3cp\x3e我的做法在服务器\x3ccode\x3esendRedirect\x3c\/code\x3e之前在\x3ccode\x3erequestUrl\x3c\/code\x3e的\x3ccode\x3equeryString\x3c\/code\x3e里添加一个flag，用一个专门的servlet filter判断过来的请求是否有这个flag，如果有那么就将本次请求的url（也就是redirect到的url）放到\x3ccode\x3eresponse\x3c\/code\x3e的一个特定的header里。然后就可以用\x3ccode\x3ejqXHR.getResponseHeader(\x27some-header\x27)\x3c\/code\x3e来获得这个url，把这个url放到history state里。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e陷阱6：无法精确还原dom对象的状态\x3c\/h2\x3e\n\x3cp\x3e不论是保存responseText还是保存url请求参数，都无法在浏览器后退的时候精确还原dom对象的状态，比如我在IE6里有个这样的特性，你在某个页面勾选了某个checkbox，然后跳转到一个新的页面然后再后退，那个checkbox还是处于勾选状态，这个在利用ajax局部页面刷新里是完全做不到的，想到用户和我说以前后退的时候那个勾还在现在勾没有了，不解决这个BUG就不验收的事情时才想到iframe的好啊。\x3c\/p\x3e\n\x3cp\x3e所以如果要精确还原dom对象的状态，得在history.pushState的时候自行把相关信息保存下来，在popstate的时候用到这些信息并还原dom。\x3c\/p\x3e\n\x3cp\x3e事实上即使用了iframe也并不是所有的浏览器会还原dom对象状态，看\x3ca href=\x22https:\/\/segmentfault.com\/n\/1330000006240399\x22\x3e这篇文章\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e总结\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e不要轻易从iframe切换到ajax局部页面刷新\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e要自己控制那些ajax局部页面刷新纪录历史，哪些不记录，有些时候可能还需要replaceState，不要想当然的把所有请求都记录历史\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e把代码改造成ajax局部页面刷新只是第一步，还需要对整个网站、应用的UI做规划和设计，关于这个问题不存在通用的解决方案\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e参考资料\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/diveintohtml5.info\/history.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMANIPULATING HISTORY FOR FUN \x26amp; PROFIT\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/html.spec.whatwg.org\/multipage\/browsers.html#history\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSession history and navigation\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en\/DOM\/Manipulating_the_browser_history\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eManipulating the browser history\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Ajax局部页面刷新和History API结合的陷阱</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006240654">https://segmentfault.com/a/1190000006240654</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/oe3y59qcal/" target="_blank">https://alili.tech/archive/oe3y59qcal/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>