<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="[译]JavaScript中的不可变性(Immutability)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>[译]JavaScript中的不可变性(Immutability) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/j2a8l3mpk3/",
				"appid": "1613049289050283", 
				"title": "[译]JavaScript中的不可变性(Immutability) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-12T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/zyc0ouws8gj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/9luhiu24omc/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fj2a8l3mpk3%2f&text=%5b%e8%af%91%5dJavaScript%e4%b8%ad%e7%9a%84%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7%28Immutability%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fj2a8l3mpk3%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fj2a8l3mpk3%2f&text=%5b%e8%af%91%5dJavaScript%e4%b8%ad%e7%9a%84%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7%28Immutability%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fj2a8l3mpk3%2f&title=%5b%e8%af%91%5dJavaScript%e4%b8%ad%e7%9a%84%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7%28Immutability%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fj2a8l3mpk3%2f&is_video=false&description=%5b%e8%af%91%5dJavaScript%e4%b8%ad%e7%9a%84%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7%28Immutability%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%5b%e8%af%91%5dJavaScript%e4%b8%ad%e7%9a%84%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7%28Immutability%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fj2a8l3mpk3%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fj2a8l3mpk3%2f&title=%5b%e8%af%91%5dJavaScript%e4%b8%ad%e7%9a%84%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7%28Immutability%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj2a8l3mpk3%2f&title=%5b%e8%af%91%5dJavaScript%e4%b8%ad%e7%9a%84%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7%28Immutability%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj2a8l3mpk3%2f&title=%5b%e8%af%91%5dJavaScript%e4%b8%ad%e7%9a%84%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7%28Immutability%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj2a8l3mpk3%2f&title=%5b%e8%af%91%5dJavaScript%e4%b8%ad%e7%9a%84%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7%28Immutability%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">[译]JavaScript中的不可变性(Immutability)</h1><div class="meta"><div class="postdate"><time datetime="2019-02-12" itemprop="datePublished">2019-02-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)是函数式编程的核心原则，在面向对象编程里也有大量应用。在这篇文章里，我会给大家秀一下到底什么是不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)、她为什么还这么屌、以及在\x3ccode\x3eJavaScript\x3c\/code\x3e中怎么应用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e什么是不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)？\x3c\/h2\x3e\n\x3cp\x3e还是先来看看关于可变性(\x3ccode\x3eMutability\x3c\/code\x3e)的教条式定义：“liable or subject to change or alteration(译者注：真他妈难翻，就简单理解成\x27易于改变的\x27吧)”。在编程领域里，我们用可变性(\x3ccode\x3eMutability\x3c\/code\x3e)来描述这样一种对象，它在创建之后状态依旧可被改变。那当我们说不可变(\x3ccode\x3eImmutable\x3c\/code\x3e)时，就是可变(\x3ccode\x3eMutable\x3c\/code\x3e)的对立面了(译者注：原谅我翻的废话又多起来) － 意思是，创建之后，就再也不能被修改了。\x3c\/p\x3e\n\x3cp\x3e如果我说的又让你感到诡异了，原谅我小小的提醒一下，其实我们平时使用的很多东西事实上都是不可变的哦！\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var statement = \x27I am an immutable value\x27;\nvar otherStr = statement.slice(8, 17);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e statement = \x3cspan class=\x22hljs-string\x22\x3e\x27I am an immutable value\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e otherStr = statement.slice(\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e17\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我猜没人会吃惊，\x3ccode\x3estatement.slice(8, 17)\x3c\/code\x3e并没有改变\x3ccode\x3estatement\x3c\/code\x3e变量吧(译者注：如果你吃惊了，赶紧去补基本知识吧)？事实上，\x3ccode\x3estring\x3c\/code\x3e对象上的所有方法里，没有一个会修改原\x3ccode\x3estring\x3c\/code\x3e，它们一律返回新的\x3ccode\x3estring\x3c\/code\x3e。原因简单了，因为\x3ccode\x3estring\x3c\/code\x3e就是是不可变的(\x3ccode\x3eImmutable\x3c\/code\x3e) - 它们不能被修改，我们能做的就是基于原\x3ccode\x3estring\x3c\/code\x3e操作后得到一个新\x3ccode\x3estring\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e注意了，\x3ccode\x3estring\x3c\/code\x3e可不是\x3ccode\x3eJavaScript\x3c\/code\x3e里唯一内置的不可变(\x3ccode\x3eImmutable\x3c\/code\x3e)数据类型哦。\x3ccode\x3enumber\x3c\/code\x3e也是不可变(\x3ccode\x3eImmutable\x3c\/code\x3e)的。否则的话，你试想下这个表达式\x3ccode\x3e2 \x2b 3\x3c\/code\x3e，如果\x3ccode\x3e2\x3c\/code\x3e的含义能被修改，那代码该怎么写啊\\|_\\|。听起来荒谬吧，但我们在编程中却常常对\x3ccode\x3eobject\x3c\/code\x3e和\x3ccode\x3earray\x3c\/code\x3e做出这种事儿。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eJavaScript充满变化\x3c\/h2\x3e\n\x3cp\x3e在\x3ccode\x3eJavaScript\x3c\/code\x3e中，\x3ccode\x3estring\x3c\/code\x3e和\x3ccode\x3enumber\x3c\/code\x3e从设计之初就是不可变(\x3ccode\x3eImmutable\x3c\/code\x3e)的。但是，看看下面这个关于\x3ccode\x3earray\x3c\/code\x3e例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [];\nvar v2 = arr.push(2);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [];\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e v2 = arr.push(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e来我问你，\x3ccode\x3ev2\x3c\/code\x3e的值是什么？如果\x3ccode\x3earray\x3c\/code\x3e和\x3ccode\x3estring\x3c\/code\x3e、\x3ccode\x3enumber\x3c\/code\x3e一样也是不可变(\x3ccode\x3eImmutable\x3c\/code\x3e)的，那此时\x3ccode\x3ev2\x3c\/code\x3e必定是一个包含了一个数字\x3ccode\x3e2\x3c\/code\x3e的新\x3ccode\x3earray\x3c\/code\x3e。事实上，还真就不是那样的。这里\x3ccode\x3earr\x3c\/code\x3e引用的\x3ccode\x3earray\x3c\/code\x3e被修改了，里面添了一个数字\x3ccode\x3e2\x3c\/code\x3e，这时\x3ccode\x3ev2\x3c\/code\x3e的值(也就是\x3ccode\x3earr.push(2)\x3c\/code\x3e的返回值)，其实是\x3ccode\x3earr\x3c\/code\x3e此时的长度 － 就是\x3ccode\x3e1\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e试想我们拥有一个不可变的数组(\x3ccode\x3eImmutableArray\x3c\/code\x3e)。就像\x3ccode\x3estring\x3c\/code\x3e、\x3ccode\x3enumber\x3c\/code\x3e那样，她应该能像如下这样被使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = new ImmutableArray([1, 2, 3, 4]);\nvar v2 = arr.push(5);\n\narr.toArray(); \/\/ [1, 2, 3, 4]\nv2.toArray();  \/\/ [1, 2, 3, 4, 5]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ImmutableArray([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e]);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e v2 = arr.push(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n\narr.toArray(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [1, 2, 3, 4]\x3c\/span\x3e\nv2.toArray();  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [1, 2, 3, 4, 5]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e类似的，也可以有一个不可变的Map(\x3ccode\x3eImmutableMap\x3c\/code\x3e)，理论上可以替代\x3ccode\x3eobject\x3c\/code\x3e应该于多数场景，她应该有一个\x3ccode\x3eset\x3c\/code\x3e方法，不过这个\x3ccode\x3eset\x3c\/code\x3e方法不会塞任何东西到原\x3ccode\x3eMap\x3c\/code\x3e里，而是返回一个包含了塞入值的新\x3ccode\x3eMap\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var person = new ImmutableMap({name: \x27Chris\x27, age: 32});\nvar olderPerson = person.set(\x27age\x27, 33);\n\nperson.toObject(); \/\/ {name: \x27Chris\x27, age: 32}\nolderPerson.toObject(); \/\/ {name: \x27Chris\x27, age: 33}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ImmutableMap({\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Chris\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e32\x3c\/span\x3e});\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e olderPerson = person.set(\x3cspan class=\x22hljs-string\x22\x3e\x27age\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e33\x3c\/span\x3e);\n\nperson.toObject(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ {name: \x27Chris\x27, age: 32}\x3c\/span\x3e\nolderPerson.toObject(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ {name: \x27Chris\x27, age: 33}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就像\x3ccode\x3e2 \x2b 3\x3c\/code\x3e这个表达式里，我们不可能改变\x3ccode\x3e2\x3c\/code\x3e或是\x3ccode\x3e3\x3c\/code\x3e所代表的含义，一个\x3ccode\x3eperson\x3c\/code\x3e在庆祝他33岁的生日，并不会影响他曾经是32岁的事实。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eJavaScript不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)实战\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eJavaScript\x3c\/code\x3e里目前还没有不可变的\x3ccode\x3elist\x3c\/code\x3e和\x3ccode\x3emap\x3c\/code\x3e，所以暂时我们还是需要三方库的帮助。有两个很不错的，一个是\x3ca href=\x22https:\/\/github.com\/swannodette\/mori\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMori\x3c\/a\x3e － 她把\x3ccode\x3eClojureScript\x3c\/code\x3e里持久化数据结构的API支持带到了\x3ccode\x3eJavaScript\x3c\/code\x3e里；另一个是Facebook出品的\x3ca href=\x22https:\/\/github.com\/facebook\/immutable-js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eimmutable.js\x3c\/a\x3e。后面的示例里，我将使用\x3ca href=\x22https:\/\/github.com\/facebook\/immutable-js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eimmutable.js\x3c\/a\x3e，因为她的API对于\x3ccode\x3eJavaScript\x3c\/code\x3e开发者更友好一些。\x3c\/p\x3e\n\x3cp\x3e下面的例子里，我们使用不可变(\x3ccode\x3eImmutable\x3c\/code\x3e)知识来构建一个扫雷小游戏。扫雷的游戏面板我们用一个不可变的\x3ccode\x3emap\x3c\/code\x3e来构建，其中\x3ccode\x3etiles\x3c\/code\x3e(雷区区块)部分值得关注哦，它是一个由不可变\x3ccode\x3emap\x3c\/code\x3e组成的不可变\x3ccode\x3elist\x3c\/code\x3e(译者注：又开始绕了)，其中每一个不可变的\x3ccode\x3emap\x3c\/code\x3e表示一个\x3ccode\x3etile\x3c\/code\x3e(雷区块)。整个这个雷区面板都是由\x3ccode\x3eJavaScript\x3c\/code\x3e的\x3ccode\x3eobject\x3c\/code\x3e和\x3ccode\x3earray\x3c\/code\x3e组成的，最后由\x3ca href=\x22https:\/\/github.com\/facebook\/immutable-js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eimmutable.js\x3c\/a\x3e的\x3ccode\x3efromJS\x3c\/code\x3e方法对其进行不可变化处理：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createGame(options) {\n  return Immutable.fromJS({\n    cols: options.cols,\n    rows: options.rows,\n    tiles: initTiles(options.rows, options.cols, options.mines)\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateGame\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Immutable.fromJS({\n    \x3cspan class=\x22hljs-attr\x22\x3ecols\x3c\/span\x3e: options.cols,\n    \x3cspan class=\x22hljs-attr\x22\x3erows\x3c\/span\x3e: options.rows,\n    \x3cspan class=\x22hljs-attr\x22\x3etiles\x3c\/span\x3e: initTiles(options.rows, options.cols, options.mines)\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e剩下的主要逻辑部分就是“扫雷”了，传入扫雷游戏对象(一个不可变结构)做为第一个参数，以及要“扫”的那个\x3ccode\x3etile\x3c\/code\x3e(雷区块)对象，最后返回新的扫雷游戏实例。以下我们就要讲到这个\x3ccode\x3erevealTile\x3c\/code\x3e函数。当它被调用时，\x3ccode\x3etile\x3c\/code\x3e(雷区块)的状态就要被重置为“扫过”的状态。如果是可变编程，代码很简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function revealTile(game, tile) {\n  game.tiles[tile].isRevealed = true;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erevealTile\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3egame, tile\x3c\/span\x3e) \x3c\/span\x3e{\n  game.tiles[tile].isRevealed = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后再来看看如果用上面介绍的不可变数据结构来编码，坦白讲，一开始代码变得都点丑了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function revealTile(game, tile) {\n  var updatedTile = game.get(\x27tiles\x27).get(tile).set(\x27isRevealed\x27, true);\n  var updatedTiles = game.get(\x27tiles\x27).set(tile, updatedTile);\n  return game.set(\x27tiles\x27, updatedTiles);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erevealTile\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3egame, tile\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e updatedTile = game.get(\x3cspan class=\x22hljs-string\x22\x3e\x27tiles\x27\x3c\/span\x3e).get(tile).set(\x3cspan class=\x22hljs-string\x22\x3e\x27isRevealed\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e updatedTiles = game.get(\x3cspan class=\x22hljs-string\x22\x3e\x27tiles\x27\x3c\/span\x3e).set(tile, updatedTile);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e game.set(\x3cspan class=\x22hljs-string\x22\x3e\x27tiles\x27\x3c\/span\x3e, updatedTiles);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我去，丑爆了有木有！\x3c\/p\x3e\n\x3cp\x3e万幸，不可变性不止于此，一定有得救！这种需求很常见，所以工具早就考虑到了，可以这么操作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function revealTile(game, tile) {\n  return game.setIn([\x27tiles\x27, tile, \x27isRevealed\x27], true);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erevealTile\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3egame, tile\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e game.setIn([\x3cspan class=\x22hljs-string\x22\x3e\x27tiles\x27\x3c\/span\x3e, tile, \x3cspan class=\x22hljs-string\x22\x3e\x27isRevealed\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在\x3ccode\x3erevealTile\x3c\/code\x3e返回一个新的实例了，新实例里其中一个\x3ccode\x3etile\x3c\/code\x3e(雷区块)的\x3ccode\x3eisRevealed\x3c\/code\x3e就和之前那个\x3ccode\x3egame\x3c\/code\x3e实例里的不一样了。这里面用到的\x3ccode\x3esetIn\x3c\/code\x3e是一个\x3ccode\x3enull-safe\x3c\/code\x3e(空值安全)的函数，任意\x3ccode\x3ekeyPath\x3c\/code\x3e中的\x3ccode\x3ekey\x3c\/code\x3e不存在时，都会在这个位置创建一个新的不可变\x3ccode\x3emap\x3c\/code\x3e(译者注：这句略绕，个人认为既然这里不是主讲\x3ca href=\x22https:\/\/github.com\/facebook\/immutable-js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eimmutable.js\x3c\/a\x3e，那就没必要非提一下它的这个特性，反而不清不楚，原作没细说，那我也就不多说了，有兴趣的可以\x3ca href=\x22http:\/\/facebook.github.io\/immutable-js\/docs\/#\/Map\/setIn\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e来这里\x3c\/a\x3e自己揣摩)。这个\x3ccode\x3enull-safe\x3c\/code\x3e特性对于我们现在扫雷游戏这个例子并不合适，因为“扫”一个不存在的\x3ccode\x3etile\x3c\/code\x3e(雷区块)表示我们正在试图扫雷区以外的地方，那显然不对！这里需要多做一步检查，通过\x3ccode\x3egetIn\x3c\/code\x3e方法检查\x3ccode\x3etile\x3c\/code\x3e(雷区块)是否存在，然后再“扫”它：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function revealTile(game, tile) {\n  return game.getIn([\x27tiles\x27, tile]) ?\n    game.setIn([\x27tiles\x27, tile, \x27isRevealed\x27], true) :\n    game;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erevealTile\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3egame, tile\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e game.getIn([\x3cspan class=\x22hljs-string\x22\x3e\x27tiles\x27\x3c\/span\x3e, tile]) ?\n    game.setIn([\x3cspan class=\x22hljs-string\x22\x3e\x27tiles\x27\x3c\/span\x3e, tile, \x3cspan class=\x22hljs-string\x22\x3e\x27isRevealed\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e) :\n    game;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果\x3ccode\x3etile\x3c\/code\x3e(雷区块)不存在，我们就返回原扫雷游戏实例。这就是个可迅速上手的关于不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)的练习，想深入了解的可以看\x3ca href=\x22http:\/\/codepen.io\/SitePoint\/pen\/zGYZzQ\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecodepen\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22SitePoint\/pen\/zGYZzQ\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e，完整的实现都在里面了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3ePerformance怎么样?\x3c\/h2\x3e\n\x3cp\x3e你可能觉得，这他妈Performance应该low爆了吧，我只能说某些情况下你是对的。每当你想添加点东西到一个不可变(\x3ccode\x3eImmutable\x3c\/code\x3e)对象里时，她一定是先拷贝以存在值到新实例里，然后再给新实例添加内容，最后返回新实例。相比可变对象，这势必会有更多内存、计算量消耗。\x3c\/p\x3e\n\x3cp\x3e因为不可变(\x3ccode\x3eImmutable\x3c\/code\x3e)对象永远不变，实际上有一种实现策略叫“结构共享”，使得她的内存消耗远比你想象的少。虽然和内置的\x3ccode\x3earray\x3c\/code\x3e、\x3ccode\x3eobject\x3c\/code\x3e的“变化”相比仍然会有额外的开销，但这个开始恒定，绝对可以被不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)带来的其它众多优势所消磨、减少。在实践中，不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)带来的优势可以极大的优化程序的整体性能，即使其中的某些个别操作开销变大了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e改进变更追踪\x3c\/h2\x3e\n\x3cp\x3e各种UI框架里，最难的部分永远是变更追踪(译者注：或者叫“脏检查”)。这是\x3ccode\x3eJavaScript\x3c\/code\x3e社区里的普遍问题，所以EcmaScript 7里提供了单独的API在保证Performance的前提下可以追踪变化：\x3ccode\x3eObject.observe()\x3c\/code\x3e。很多人为之激动，但也有不少人认为这个API然并卵。他们认为，在任何情况下，这个API都没很好的解决变更追踪问题：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var tiles = [{id: 0, isRevealed: false}, {id: 1, isRevealed: true}];\nObject.observe(tiles, function () { \/* ... *\/ });\n\ntiles[0].id = 2;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tiles = [{\x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eisRevealed\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e}, {\x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eisRevealed\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e}];\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.observe(tiles, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/* ... *\/\x3c\/span\x3e });\n\ntiles[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].id = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面例子里，\x3ccode\x3etiles[0]\x3c\/code\x3e的变更并没有触发\x3ccode\x3eobserver\x3c\/code\x3e，所以其实这个提案即便是最简单的变更追踪也没做到。那不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)又是怎么解决的？假设有一个应用状态\x3ccode\x3ea\x3c\/code\x3e，然后它内部有值被改变了，于是就得到了一个新的实例\x3ccode\x3eb\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (a === b) {\n  \/\/ 数据没变，停止操作\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (a === b) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据没变，停止操作\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果应用状态\x3ccode\x3ea\x3c\/code\x3e没有被修改，那\x3ccode\x3eb\x3c\/code\x3e就是\x3ccode\x3ea\x3c\/code\x3e，它们指向同一个实例，\x3ccode\x3e===\x3c\/code\x3e就够了，不用做其他事儿。当然这需要我们追踪应用状态的引用，但整个问题的复杂度被大大简化了，现在只要判断一下它们是否同一个实例的引用就好了，真心不用再去深入调查里面的某某字段是不是变了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e结束语\x3c\/h2\x3e\n\x3cp\x3e希望本文能某种程度上帮你了解不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)是如何帮我们优化\/改进代码的，也希望这些例子从实践角度说清楚了使用方式。不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)的热度在持续增高，我确定这绝不是你今年看到的关于不可变性(\x3ccode\x3eImmutability\x3c\/code\x3e)的最后一文。同志们，是时候来一发了，我相信你用过后一定会high至的，就像我现在一样^^。\x3c\/p\x3e\n\x3cp\x3e原文地址：\x3ca href=\x22http:\/\/www.sitepoint.com\/immutability-javascript\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eImmutability in JavaScript\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>[译]JavaScript中的不可变性(Immutability)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000004906518">https://segmentfault.com/a/1190000004906518</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/j2a8l3mpk3/" target="_blank">https://alili.tech/archive/j2a8l3mpk3/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>