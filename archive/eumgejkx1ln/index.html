<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="异步Promise及Async/Await可能最完整入门攻略"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>异步Promise及Async/Await可能最完整入门攻略 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/eumgejkx1ln/",
				"appid": "1613049289050283", 
				"title": "异步Promise及Async/Await可能最完整入门攻略 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-15T02:30:44"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/mxdc3fhhut/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/a389msrmfwv/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2feumgejkx1ln%2f&text=%e5%bc%82%e6%ad%a5Promise%e5%8f%8aAsync%2fAwait%e5%8f%af%e8%83%bd%e6%9c%80%e5%ae%8c%e6%95%b4%e5%85%a5%e9%97%a8%e6%94%bb%e7%95%a5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2feumgejkx1ln%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2feumgejkx1ln%2f&text=%e5%bc%82%e6%ad%a5Promise%e5%8f%8aAsync%2fAwait%e5%8f%af%e8%83%bd%e6%9c%80%e5%ae%8c%e6%95%b4%e5%85%a5%e9%97%a8%e6%94%bb%e7%95%a5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2feumgejkx1ln%2f&title=%e5%bc%82%e6%ad%a5Promise%e5%8f%8aAsync%2fAwait%e5%8f%af%e8%83%bd%e6%9c%80%e5%ae%8c%e6%95%b4%e5%85%a5%e9%97%a8%e6%94%bb%e7%95%a5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2feumgejkx1ln%2f&is_video=false&description=%e5%bc%82%e6%ad%a5Promise%e5%8f%8aAsync%2fAwait%e5%8f%af%e8%83%bd%e6%9c%80%e5%ae%8c%e6%95%b4%e5%85%a5%e9%97%a8%e6%94%bb%e7%95%a5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%bc%82%e6%ad%a5Promise%e5%8f%8aAsync%2fAwait%e5%8f%af%e8%83%bd%e6%9c%80%e5%ae%8c%e6%95%b4%e5%85%a5%e9%97%a8%e6%94%bb%e7%95%a5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2feumgejkx1ln%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2feumgejkx1ln%2f&title=%e5%bc%82%e6%ad%a5Promise%e5%8f%8aAsync%2fAwait%e5%8f%af%e8%83%bd%e6%9c%80%e5%ae%8c%e6%95%b4%e5%85%a5%e9%97%a8%e6%94%bb%e7%95%a5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2feumgejkx1ln%2f&title=%e5%bc%82%e6%ad%a5Promise%e5%8f%8aAsync%2fAwait%e5%8f%af%e8%83%bd%e6%9c%80%e5%ae%8c%e6%95%b4%e5%85%a5%e9%97%a8%e6%94%bb%e7%95%a5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2feumgejkx1ln%2f&title=%e5%bc%82%e6%ad%a5Promise%e5%8f%8aAsync%2fAwait%e5%8f%af%e8%83%bd%e6%9c%80%e5%ae%8c%e6%95%b4%e5%85%a5%e9%97%a8%e6%94%bb%e7%95%a5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2feumgejkx1ln%2f&title=%e5%bc%82%e6%ad%a5Promise%e5%8f%8aAsync%2fAwait%e5%8f%af%e8%83%bd%e6%9c%80%e5%ae%8c%e6%95%b4%e5%85%a5%e9%97%a8%e6%94%bb%e7%95%a5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">异步Promise及Async/Await可能最完整入门攻略</h1><div class="meta"><div class="postdate"><time datetime="2019-02-15" itemprop="datePublished">2019-02-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e此文只介绍Async\/Await与Promise基础知识与实际用到注意的问题，将通过很多代码实例进行说明，两个实例代码是\x3ccode\x3esetDelay\x3c\/code\x3e和\x3ccode\x3esetDelaySecond\x3c\/code\x3e。\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3etips:本文系原创转自我的博客\x3ca href=\x22http:\/\/www.tangyida.top\/detail\/152\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e异步Promise及Async\/Await最完整入门攻略\x3c\/a\x3e，欢迎前端大神交流，指出问题\x3c\/strong\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e一、为什么有Async\/Await？\x3c\/h2\x3e\n\x3cp\x3e我们都知道已经有了\x3ccode\x3ePromise\x3c\/code\x3e的解决方案了，为什么还要ES7提出新的Async\/Await标准呢？\x3c\/p\x3e\n\x3cp\x3e答案其实也显而易见：\x3ccode\x3ePromise\x3c\/code\x3e虽然跳出了异步嵌套的怪圈，用链式表达更加清晰，但是我们也发现如果有大量的异步请求的时候，流程复杂的情况下，会发现充满了屏幕的\x3ccode\x3ethen\x3c\/code\x3e，看起来非常吃力，而ES7的Async\/Await的出现就是为了解决这种复杂的情况。\x3c\/p\x3e\n\x3cp\x3e首先，我们必须了解\x3ccode\x3ePromise\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e二、Promise简介\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e2.1 Promise实例\x3c\/h3\x3e\n\x3cp\x3e什么是Promise，很多人应该都知道基础概念？直接看下面的代码（\x3cstrong\x3e全文的例子都是基于\x3ccode\x3esetDelaySecond\x3c\/code\x3e和\x3ccode\x3esetDelay\x3c\/code\x3e两个函数，请务必记住\x3c\/strong\x3e）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const setDelay = (millisecond) =\x3e {\n  return new Promise((resolve, reject)=\x3e{\n      if (typeof millisecond != \x27number\x27) reject(new Error(\x27参数必须是number类型\x27));\n      setTimeout(()=\x3e {\n        resolve(`我延迟了${millisecond}毫秒后输出的`)\n      }, millisecond)\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e setDelay = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3emillisecond\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e millisecond != \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e) reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27参数必须是number类型\x27\x3c\/span\x3e));\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {\n        resolve(\x3cspan class=\x22hljs-string\x22\x3e`我延迟了\x3cspan class=\x22hljs-subst\x22\x3e${millisecond}\x3c\/span\x3e毫秒后输出的`\x3c\/span\x3e)\n      }, millisecond)\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们把一个Promise封装在一个函数里面同时返回了一个Promise，这样比较规范。\x3c\/p\x3e\n\x3cp\x3e可以看到定义的Promise有两个参数，\x3ccode\x3eresolve\x3c\/code\x3e和\x3ccode\x3ereject\x3c\/code\x3e。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3eresolve\x3c\/code\x3e：将异步的执行从\x3ccode\x3epending(请求)\x3c\/code\x3e变成了\x3ccode\x3eresolve(成功返回)\x3c\/code\x3e，是个函数执行返回。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ereject\x3c\/code\x3e：顾名思义“拒绝”，就是从请求变成了\x22失败\x22，是个函数可以执行返回一个结果，但我们这里推荐大家返回一个错误\x3ccode\x3enew Error()\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e上述例子，你可以\x3ccode\x3ereject(\x27返回一个字符串\x27)\x3c\/code\x3e，随便你返回，但是我们还是\x3cstrong\x3e建议返回一个Error对象，这样更加清晰是“失败的”，这样更规范一点\x3c\/strong\x3e。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e2.2 Promise的then和catch\x3c\/h3\x3e\n\x3cp\x3e我们通过Promise的原型方法\x3ccode\x3ethen\x3c\/code\x3e拿到我们的返回值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(3000)\n.then((result)=\x3e{\n    console.log(result) \/\/ 输出“我延迟了2000毫秒后输出的”\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出“我延迟了2000毫秒后输出的”\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输出下列的值：“我延迟了2000毫秒后输出的”。\x3c\/p\x3e\n\x3cp\x3e如果出错呢？那就用\x3ccode\x3ecatch\x3c\/code\x3e捕获：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(\x27我是字符串\x27)\n.then((result)=\x3e{\n    console.log(result) \/\/ 不进去了\n})\n.catch((err)=\x3e{\n    console.log(err) \/\/ 输出错误：“参数必须是number类型”\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-string\x22\x3e\x27我是字符串\x27\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不进去了\x3c\/span\x3e\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出错误：“参数必须是number类型”\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e是不是很简单？好，现在我增加一点难度，如果多个\x3ccode\x3ePromise\x3c\/code\x3e执行会是怎么样呢？\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e2.3 Promise相互依赖\x3c\/h3\x3e\n\x3cp\x3e我们在写一个Promise：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const setDelaySecond = (seconds) =\x3e {\n  return new Promise((resolve, reject)=\x3e{\n      if (typeof seconds != \x27number\x27 || seconds \x3e 10) reject(new Error(\x27参数必须是number类型，并且小于等于10\x27));\n      setTimeout(()=\x3e {\n        console.log(`先是setDelaySeconds函数输出，延迟了${seconds}秒，一共需要延迟${seconds\x2b2}秒`)\n        resolve(setDelay(2000)) \/\/ 这里依赖上一个Promise\n      }, seconds * 1000)\n  })\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e setDelaySecond = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eseconds\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e seconds != \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e || seconds \x26gt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e) reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27参数必须是number类型，并且小于等于10\x27\x3c\/span\x3e));\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`先是setDelaySeconds函数输出，延迟了\x3cspan class=\x22hljs-subst\x22\x3e${seconds}\x3c\/span\x3e秒，一共需要延迟\x3cspan class=\x22hljs-subst\x22\x3e${seconds\x2b\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e}\x3c\/span\x3e秒`\x3c\/span\x3e)\n        resolve(setDelay(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里依赖上一个Promise\x3c\/span\x3e\n      }, seconds * \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n  })\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在下一个需要依赖的\x3ccode\x3eresolve\x3c\/code\x3e去返回另一个Promise，会发生什么呢？我们执行一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelaySecond(3).then((result)=\x3e{\n  console.log(result)\n}).catch((err)=\x3e{\n  console.log(err);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n}).catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你会发现结果是先执行：\x3cstrong\x3e“先是setDelaySeconds输出，延迟了2秒，一共需要延迟5秒”\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e再执行\x3ccode\x3esetDelay\x3c\/code\x3e的\x3ccode\x3eresolve\x3c\/code\x3e：\x3cstrong\x3e“我延迟了2000毫秒后输出的”\x3c\/strong\x3e。的确做到了依次执行的目的。\x3c\/p\x3e\n\x3cp\x3e有人说，我不想耦合性这么高，想先执行\x3ccode\x3esetDelay\x3c\/code\x3e函数再执行\x3ccode\x3esetDelaySecond\x3c\/code\x3e，但不想用上面那种写法，可以吗，答案是当然可以。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e2.4 Promise链式写法\x3c\/h3\x3e\n\x3cp\x3e先改写一下\x3ccode\x3esetDelaySecond\x3c\/code\x3e，拒绝依赖，降低耦合性\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const setDelaySecond = (seconds) =\x3e {\n  return new Promise((resolve, reject)=\x3e{\n      if (typeof seconds != \x27number\x27 || seconds \x3e 10) reject(new Error(\x27参数必须是number类型，并且小于等于10\x27));\n      setTimeout(()=\x3e {\n        resolve(`我延迟了${seconds}秒后输出的，是第二个函数`)\n      }, seconds * 1000)\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e setDelaySecond = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eseconds\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e seconds != \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e || seconds \x26gt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e) reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27参数必须是number类型，并且小于等于10\x27\x3c\/span\x3e));\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {\n        resolve(\x3cspan class=\x22hljs-string\x22\x3e`我延迟了\x3cspan class=\x22hljs-subst\x22\x3e${seconds}\x3c\/span\x3e秒后输出的，是第二个函数`\x3c\/span\x3e)\n      }, seconds * \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e先执行\x3ccode\x3esetDelay\x3c\/code\x3e在执行\x3ccode\x3esetDelaySecond\x3c\/code\x3e，只需要在第一个\x3ccode\x3ethen\x3c\/code\x3e的结果中\x3cstrong\x3e返回下一个Promise就可以一直链式写下去了，相当于依次执行\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(2000)\n.then((result)=\x3e{\n  console.log(result)\n  console.log(\x27我进行到第一步的\x27);\n  return setDelaySecond(3)\n})\n.then((result)=\x3e{\n  console.log(\x27我进行到第二步的\x27);\n  console.log(result);\n}).catch((err)=\x3e{\n  console.log(err);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第一步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第二步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n}).catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e发现确实达到了可喜的链式（终于脱离异步嵌套苦海，哭），可以看到\x3ccode\x3ethen\x3c\/code\x3e的链式写法非常优美。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e2.5 链式写法需要注意的地方\x3c\/h3\x3e\n\x3cp\x3e这里一定要提到一点：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ethen\x3c\/code\x3e式链式写法的本质其实是一直\x3cstrong\x3e往下传递返回一个新的Promise\x3c\/strong\x3e，也就是说\x3cstrong\x3ethen在下一步接收的是上一步返回的Promise\x3c\/strong\x3e，理解这个对于后面的细节非常重要！！\x3c\/p\x3e\n\x3cp\x3e那么并不是这么简单，then的返回我们可以看出有2个参数(都是回调)：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e第一个回调是resolve的回调，也就是第一个参数用得最多，拿到的是上一步的\x3ccode\x3ePromise\x3c\/code\x3e成功\x3ccode\x3eresolve\x3c\/code\x3e的值。\x3c\/li\x3e\n\x3cli\x3e第二个回调是reject的回调，用的不多，但是求求大家不要写错了，通常是拿到上一个的错误，那么这个错误处理和catch有什么区别和需要注意的地方呢？\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们修改上面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(2000)\n.then((result)=\x3e{\n  console.log(result)\n  console.log(\x27我进行到第一步的\x27);\n  return setDelaySecond(20)\n})\n.then((result)=\x3e{\n  console.log(\x27我进行到第二步的\x27);\n  console.log(result);\n}, (_err)=\x3e {\n  console.log(\x27我出错啦，进到这里捕获错误，但是不经过catch了\x27);\n})\n.then((result)=\x3e{\n  console.log(\x27我还是继续执行的！！！！\x27)\n})\n.catch((err)=\x3e{\n  console.log(err);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第一步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e)\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第二步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n}, (_err)=\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我出错啦，进到这里捕获错误，但是不经过catch了\x27\x3c\/span\x3e);\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我还是继续执行的！！！！\x27\x3c\/span\x3e)\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到输出结果是：进到了\x3ccode\x3ethen\x3c\/code\x3e的第二个参数（reject）中去了，而且最重要的是！不再经过\x3ccode\x3ecatch\x3c\/code\x3e了。\x3c\/p\x3e\n\x3cp\x3e那么我们把catch挪上去，写到\x3ccode\x3ethen\x3c\/code\x3e错误处理前：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(2000)\n.then((result)=\x3e{\n  console.log(result)\n  console.log(\x27我进行到第一步的\x27);\n  return setDelaySecond(20)\n})\n.catch((err)=\x3e{ \/\/ 挪上去了\n  console.log(err); \/\/ 这里catch到上一个返回Promise的错误\n})\n.then((result)=\x3e{\n  console.log(\x27我进行到第二步的\x27);\n  console.log(result);\n}, (_err)=\x3e {\n  console.log(\x27我出错啦，但是由于catch在我前面，所以错误早就被捕获了，我这没有错误了\x27);\n})\n.then((result)=\x3e{\n  console.log(\x27我还是继续执行的！！！！\x27)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第一步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e)\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挪上去了\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里catch到上一个返回Promise的错误\x3c\/span\x3e\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第二步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n}, (_err)=\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我出错啦，但是由于catch在我前面，所以错误早就被捕获了，我这没有错误了\x27\x3c\/span\x3e);\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我还是继续执行的！！！！\x27\x3c\/span\x3e)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到先经过\x3ccode\x3ecatch\x3c\/code\x3e的捕获，后面就没错误了。\x3c\/p\x3e\n\x3cp\x3e可以得出需要注意的：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3ecatch\x3c\/code\x3e写法是针对于整个链式写法的错误捕获的，而\x3ccode\x3ethen\x3c\/code\x3e第二个参数是针对于上一个返回\x3ccode\x3ePromise\x3c\/code\x3e的。\x3c\/li\x3e\n\x3cli\x3e两者的优先级：就是\x3cstrong\x3e看谁在链式写法的前面\x3c\/strong\x3e，在前面的先捕获到错误，后面就没有错误可以捕获了，链式前面的优先级大，而且两者都不是\x3ccode\x3ebreak\x3c\/code\x3e， 可以继续执行后续操作不受影响。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e2.5 链式写法的错误处理\x3c\/h3\x3e\n\x3cp\x3e上述已经写好了关于then里面三个回调中第二个回调（reject）会与catch冲突的问题，那么我们实际写的时候，参数捕获的方式基本写得少，catch的写法会用到更多。\x3c\/p\x3e\n\x3cp\x3e既然有了很多的Promise，那么我需不需要写很多catch呢？\x3c\/p\x3e\n\x3cp\x3e答案当然是：\x3cstrong\x3e不需要！\x3c\/strong\x3e，哪有那么麻烦的写法，只需要在末尾\x3ccode\x3ecatch\x3c\/code\x3e一下就可以了，因为链式写法的错误处理具有“冒泡”特性，\x3cstrong\x3e链式中任何一个环节出问题，都会被\x3ccode\x3ecatch\x3c\/code\x3e到，同时在某个环节后面的代码就不会执行了\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e既然说到这里，我们把\x3ccode\x3ecatch\x3c\/code\x3e移到第一个链式的返回里面会发生什么事呢？看下面代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(\x272000\x27)\n.then((result)=\x3e{\n  console.log(\x27第一步完成了\x27);\n  console.log(result)\n  return setDelaySecond(3)\n})\n.catch((err)=\x3e{ \/\/ 这里移到第一个链式去，发现上面的不执行了，下面的继续执行\n  console.log(err);\n})\n.then((result)=\x3e{\n  console.log(\x27第二步完成了\x27);\n  console.log(result);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-string\x22\x3e\x272000\x27\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第一步完成了\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里移到第一个链式去，发现上面的不执行了，下面的继续执行\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第二步完成了\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e惊喜的发现，\x3cstrong\x3e链式继续走下去了\x3c\/strong\x3e！！输出如下（undefined是因为上一个then没有返回一个Promise）：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbiBBM?w=1622\x26amp;h=296\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbiBBM?w=1622\x26amp;h=296\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e重点来了！敲黑板！！\x3cstrong\x3e链式中的\x3ccode\x3ecatch\x3c\/code\x3e并不是终点！！catch完如果还有then还会继续往下走！\x3c\/strong\x3e不信的话可以把第一个\x3ccode\x3ecatch\x3c\/code\x3e在最后面的那个例子后面再加几个\x3ccode\x3ethen\x3c\/code\x3e，你会发现\x3cstrong\x3e并不会跳出链式执行\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e如果顺序执行\x3ccode\x3esetDelay，setDelay1,setDelaySecond\x3c\/code\x3e，按照上述的逻辑，流程图可以概括如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbiBBR?w=335\x26amp;h=727\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbiBBR?w=335\x26amp;h=727\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ecatch\x3c\/code\x3e只是捕获错误的一个链式表达，并不是break！\x3c\/p\x3e\n\x3cp\x3e所以，\x3cstrong\x3ecatch放的位置也很有讲究\x3c\/strong\x3e，一般放在一些重要的、必须catch的程序的最后。**这些重要的程序中间一旦出现错误，会马上跳过其他后续程序的操作直接执行到最近的catch代码块，但不影响catch后续的操作！！！！\x3c\/p\x3e\n\x3cp\x3e到这就不得不体一个ES2018标准新引入的\x3cstrong\x3ePromise的\x3ccode\x3efinally\x3c\/code\x3e\x3c\/strong\x3e，表示在catch后必须肯定会默认执行的的操作。这里不多展开，细节可以参考：\x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/promise#Promise-prototype-finally\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise的finally\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e2.5 Promise链式中间想返回自定义的值\x3c\/h3\x3e\n\x3cp\x3e其实很简单，用\x3ccode\x3ePromise\x3c\/code\x3e的原型方法\x3ccode\x3eresolve\x3c\/code\x3e即可：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(2000).then((result)=\x3e{\n  console.log(\x27第一步完成了\x27);\n  console.log(result);\n  let message = \x27这是我自己想处理的值\x27; \n  return Promise.resolve(message) \/\/ 这里返回我想在下一阶段处理的值\n})\n.then((result)=\x3e{\n  console.log(\x27第二步完成了\x27);\n  console.log(result); \/\/ 这里拿到上一阶段的返回值\n  \/\/return Promise.resolve(\x27这里可以继续返回\x27)\n})\n.catch((err)=\x3e{\n  console.log(err);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e).then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第一步完成了\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e message = \x3cspan class=\x22hljs-string\x22\x3e\x27这是我自己想处理的值\x27\x3c\/span\x3e; \n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(message) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里返回我想在下一阶段处理的值\x3c\/span\x3e\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第二步完成了\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里拿到上一阶段的返回值\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/return Promise.resolve(\x27这里可以继续返回\x27)\x3c\/span\x3e\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e2.7 如何跳出或停止Promise链式\x3c\/h3\x3e\n\x3cp\x3e不同于一般的\x3ccode\x3efunction\x3c\/code\x3e的\x3ccode\x3ebreak\x3c\/code\x3e的方式，如果你是这样的操作：\x3ccode\x3efunc().then().then().then().catch()\x3c\/code\x3e的方式，你想在第一个\x3ccode\x3ethen\x3c\/code\x3e就跳出链式，后面的不想执行了，不同于一般的\x3ccode\x3ebreak;return null;return false\x3c\/code\x3e等操作，可以说，如何停止Promise链，是一大难点，是整个Promise最复杂的地方。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e1.用链式的思维想，我们拒绝掉某一链，那么不就是相当于直接跳到了catch模块吗？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e我们是不是可以直接“拒绝“掉达到停止的目的？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(2000)\n.then((result)=\x3e{\n  console.log(result)\n  console.log(\x27我进行到第一步的\x27);\n  return setDelaySecond(1)\n})\n.then((result)=\x3e{\n  console.log(\x27我进行到第二步的\x27);\n  console.log(result);\n  console.log(\x27我主动跳出循环了\x27);\n  return Promise.reject(\x27跳出循环的信息\x27) \/\/ 这里返回一个reject,主动跳出循环了\n})\n.then((result)=\x3e{\n  console.log(\x27我不执行\x27);\n})\n.catch((mes)=\x3e{\n  console.dir(mes)\n  console.log(\x27我跳出了\x27);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第一步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第二步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我主动跳出循环了\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.reject(\x3cspan class=\x22hljs-string\x22\x3e\x27跳出循环的信息\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里返回一个reject,主动跳出循环了\x3c\/span\x3e\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我不执行\x27\x3c\/span\x3e);\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3emes\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.dir(mes)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我跳出了\x27\x3c\/span\x3e);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是很容易看到缺点：有时候你并不确定是因为错误跳出的，还是主动跳出的，所以我们可以加一个标志位：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22return Promise.reject({\n    isNotErrorExpection: true \/\/ 返回的地方加一个标志位，判断是否是错误类型，如果不是，那么说明可以是主动跳出循环的\n}) \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.reject({\n    \x3cspan class=\x22hljs-attr\x22\x3eisNotErrorExpection\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回的地方加一个标志位，判断是否是错误类型，如果不是，那么说明可以是主动跳出循环的\x3c\/span\x3e\n}) \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e或者根据上述的代码判断catch的地方输出的类型是不是属于错误对象的，是的话说明是错误，不是的话说明是主动跳出的，你可以自己选择（这就是为什么要统一错误reject的时候输出new Error(\x27错误信息\x27)的原因，规范！）\x3c\/p\x3e\n\x3cp\x3e当然你也可以直接抛出一个错误跳出：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22throw new Error(\x27错误信息\x27) \/\/ 直接跳出，那就不能用判断是否为错误对象的方法进行判断了\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27错误信息\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直接跳出，那就不能用判断是否为错误对象的方法进行判断了\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e2.那有时候我们有这个需求：catch是放在中间（不是末尾），而同时我们又不想执行catch后面的代码，也就是链式的绝对中止，应该怎么办？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e我们看这段代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(2000)\n.then((result)=\x3e{\n  console.log(result)\n  console.log(\x27我进行到第一步的\x27);\n  return setDelaySecond(1)\n})\n.then((result)=\x3e{\n  console.log(\x27我进行到第二步的\x27);\n  console.log(result);\n  console.log(\x27我主动跳出循环了\x27);\n  return Promise.reject(\x27跳出循环的信息\x27) \/\/ 这里直接调用Promise原型方法返回一个reject,主动跳出循环了\n})\n.then((result)=\x3e{\n  console.log(\x27我不执行\x27);\n})\n.catch((mes)=\x3e{\n  console.dir(mes)\n  console.log(\x27我跳出了\x27);\n})\n.then((res)=\x3e{\n    console.log(\x27我不想执行，但是却执行了\x27); \/\/ 问题在这，上述的终止方法治标不治本。\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第一步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第二步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我主动跳出循环了\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.reject(\x3cspan class=\x22hljs-string\x22\x3e\x27跳出循环的信息\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里直接调用Promise原型方法返回一个reject,主动跳出循环了\x3c\/span\x3e\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我不执行\x27\x3c\/span\x3e);\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3emes\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.dir(mes)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我跳出了\x27\x3c\/span\x3e);\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我不想执行，但是却执行了\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 问题在这，上述的终止方法治标不治本。\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时候最后一步\x3ccode\x3ethen\x3c\/code\x3e还是执行了，整条链都其实没有本质上的跳出，那应该怎么办呢？\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e敲黑板！！重点来了！\x3c\/strong\x3e我们看\x3ca href=\x22https:\/\/promisesaplus.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise\/A\x2b\x3c\/a\x3e规范可以知道：\x3c\/p\x3e\n\x3cblockquote\x3eA promise must be in one of three states: pending, fulfilled, or rejected.\x3c\/blockquote\x3e\n\x3cp\x3ePromise其实是有三种状态的：\x3cstrong\x3epending，resolve，rejected\x3c\/strong\x3e，那么我们一直在讨论\x3ccode\x3eresolve和rejected\x3c\/code\x3e这2个状态，是不是忽视了\x3ccode\x3epending\x3c\/code\x3e这个状态呢？pending状态顾名思义就是请求中的状态，成功请求就是resolve，失败就是reject，其实他就是个中间过渡状态。\x3c\/p\x3e\n\x3cp\x3e而我们上面讨论过了，\x3cstrong\x3e\x3ccode\x3ethen\x3c\/code\x3e的下一层级其实得到的是上一层级返回的Promise对象，也就是说原Promise对象与新对象状态保持一致\x3c\/strong\x3e。那么重点来了，如果你想在这一层级进行终止，是不是直接让它永远都\x3ccode\x3epending\x3c\/code\x3e下去，那么后续的操作不就没了吗？是不是就达到这个目的了？？觉得有疑问的可以参考\x3ca href=\x22https:\/\/promisesaplus.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise\/A\x2b\x3c\/a\x3e规范。\x3c\/p\x3e\n\x3cp\x3e我们直接看代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(2000)\n.then((result)=\x3e{\n  console.log(result)\n  console.log(\x27我进行到第一步的\x27);\n  return setDelaySecond(1)\n})\n.then((result)=\x3e{\n  console.log(result);\n  console.log(\x27我主动跳出循环了\x27);\n  \/\/ return Promise.reject(\x27跳出循环的信息\x27)\n  \/\/ 重点在这\n  return new Promise(()=\x3e{console.log(\x27后续的不会执行\x27)}) \/\/ 这里返回的一个新的Promise，没有resolve和reject，那么会一直处于pending状态，因为没返回啊，那么这种状态就一直保持着，中断了这个Promise\n})\n.then((result)=\x3e{\n  console.log(\x27我不执行\x27);\n})\n.catch((mes)=\x3e{\n  console.dir(mes)\n  console.log(\x27我跳出了\x27);\n})\n.then((res)=\x3e{\n  console.log(\x27我也不会执行\x27)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我进行到第一步的\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我主动跳出循环了\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return Promise.reject(\x27跳出循环的信息\x27)\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重点在这\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27后续的不会执行\x27\x3c\/span\x3e)}) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里返回的一个新的Promise，没有resolve和reject，那么会一直处于pending状态，因为没返回啊，那么这种状态就一直保持着，中断了这个Promise\x3c\/span\x3e\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我不执行\x27\x3c\/span\x3e);\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3emes\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.dir(mes)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我跳出了\x27\x3c\/span\x3e);\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我也不会执行\x27\x3c\/span\x3e)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样就解决了上述，错误跳出而导致无法完全终止Promise链的问题。\x3c\/p\x3e\n\x3cp\x3e但是！随之而来也有一个问题，那就是可能会导致\x3cstrong\x3e潜在的内存泄漏\x3c\/strong\x3e，因为我们知道这个一直处于pending状态下的Promise会一直处于被挂起的状态，而我们具体不知道浏览器的机制细节也不清楚，一般的网页没有关系，但大量的复杂的这种pending状态势必会导致内存泄漏，具体的没有测试过，后续可能会跟进测试（nodeJS或webapp里面不推荐这样），而我通过查询也难以找到答案，这篇文章可以推荐看一下：\x3ca href=\x22https:\/\/github.com\/xieranmaya\/blog\/issues\/5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从如何停掉 Promise 链说起\x3c\/a\x3e。可能对你有帮助在此种情况下如何做。\x3c\/p\x3e\n\x3cp\x3e当然一般情况下是不会存在泄漏，只是有这种风险，无法取消Promise一直是它的痛点。而上述两个奇妙的取消方法要具体情形具体使用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e2.8 Promise.all\x3c\/h3\x3e\n\x3cp\x3e其实这几个方法就简单了，就是一个简写串联所有你需要的\x3ccode\x3ePromise\x3c\/code\x3e执行，具体可以参照\x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/promise#Promise-all\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阮一峰的ES6Promise.all教程\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e我这上一个代码例子\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Promise.all([setDelay(1000), setDelaySecond(1)]).then(result=\x3e{\n  console.log(result);\n})\n.catch(err=\x3e{\n  console.log(err);\n})\n\/\/ 输出[\x26quot;我延迟了1000毫秒后输出的\x26quot;, \x26quot;我延迟了1秒后输出的，注意单位是秒\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e), setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出[\x22我延迟了1000毫秒后输出的\x22, \x22我延迟了1秒后输出的，注意单位是秒\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输出的是一个数组，相当于把\x3ccode\x3eall\x3c\/code\x3e方法里面的\x3ccode\x3ePromise\x3c\/code\x3e\x3cstrong\x3e并行执行\x3c\/strong\x3e，注意是并行。\x3cbr\x3e相当于两个Promise同时开始执行，同时返回值，并不是先执行第一个再执行第二个，如果你想串行执行，请参考我后面写的循环\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000016788484?_ea=4854890#articleHeader20\x22\x3ePromise循环串行（第4.2小节）\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e然后把resolve的值保存在数组中输出。类似的还有\x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/promise#Promise-race\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise.race\x3c\/a\x3e这里就不多赘述了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e三、Async\/await介绍\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e3.1 基于Promise的Async\/await\x3c\/h3\x3e\n\x3cp\x3e什么是\x3ccode\x3easync\/await\x3c\/code\x3e呢？可以总结为一句话：\x3cstrong\x3easync\/await是一对好基友，缺一不可，他们的出生是为Promise服务的\x3c\/strong\x3e。可以说async\/await是Promise的爸爸，进化版。为什么这么说呢？且听我细细道来。\x3c\/p\x3e\n\x3cp\x3e为什么要有\x3ccode\x3easync\/await\x3c\/code\x3e存在呢？\x3c\/p\x3e\n\x3cp\x3e前文已经说过了，为了解决大量复杂不易读的Promise异步的问题，才出现的改良版。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e这两个基友必须同时出现，缺一不可\x3c\/strong\x3e，那么先说一下\x3ccode\x3eAsync\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function process() {\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprocess\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面可以看出，\x3cstrong\x3e\x3ccode\x3easync\x3c\/code\x3e必须声明的是一个function\x3c\/strong\x3e，不要去声明别的，要是那样\x3ccode\x3eawait\x3c\/code\x3e就不理你了（报错）。\x3c\/p\x3e\n\x3cp\x3e这样声明也是错的！\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const async demo =  function () {} \/\/ 错误\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e demo =  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 错误\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e必须紧跟着\x3ccode\x3efunction\x3c\/code\x3e。接下来说一下它的兄弟\x3ccode\x3eawait\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e上面说到必须是个函数（function），\x3cstrong\x3e那么\x3ccode\x3eawait\x3c\/code\x3e就必须是在这个\x3ccode\x3easync\x3c\/code\x3e声明的函数内部使用\x3c\/strong\x3e，否则就会报错。\x3c\/p\x3e\n\x3cp\x3e就算你这样写，也是错的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let data = \x27data\x27\ndemo  = async function () {\n    const test = function () {\n        await data\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = \x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e\ndemo  = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e test = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e data\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e必须是直系（作用域链不能隔代），这样会报错：\x3ccode\x3eUncaught SyntaxError: await is only valid in async function\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e讲完了基本规范，我们接下去说一下他们的本质。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e3.2 async的本质\x3c\/h3\x3e\n\x3cp\x3e敲黑板！！！很重要！\x3cstrong\x3easync声明的函数的返回本质上是一个Promise\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e什么意思呢？就是说你只要声明了这个函数是\x3ccode\x3easync\x3c\/code\x3e，那么内部不管你怎么处理，它的返回肯定是个Promise。\x3c\/p\x3e\n\x3cp\x3e看下列例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async function () {\n    return \x27我是Promise\x27\n})()\n\/\/ 返回是Promise\n\/\/Promise\x26nbsp;{\x3cresolved\x3e: \x26quot;我是Promise\x26quot;}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27我是Promise\x27\x3c\/span\x3e\n})()\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回是Promise\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/Promise\x26nbsp;{\x26lt;resolved\x26gt;: \x22我是Promise\x22}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你会发现返回是这个：\x3ccode\x3ePromise\x26nbsp;{\x26lt;resolved\x26gt;: \x22我是Promise\x22}\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e自动解析成\x3ccode\x3ePromise.resolve(\x27我是Promise\x27);\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e等同于：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async function () {\n    return Promise.resolve(\x27我是Promise\x27);\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27我是Promise\x27\x3c\/span\x3e);\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以你想像一般\x3ccode\x3efunction\x3c\/code\x3e的返回那样，拿到返回值，原来的思维要改改了！你可以这样拿到返回值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const demo = async function () {\n    return Promise.resolve(\x27我是Promise\x27);\n    \/\/ 等同于 return \x27我是Promise\x27\n    \/\/ 等同于 return new Promise((resolve,reject)=\x3e{ resolve(\x27我是Promise\x27) })\n}\ndemo.then(result=\x3e{\n    console.log(result) \/\/ 这里拿到返回值\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e demo = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27我是Promise\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等同于 return \x27我是Promise\x27\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 等同于 return new Promise((resolve,reject)=\x26gt;{ resolve(\x27我是Promise\x27) })\x3c\/span\x3e\n}\ndemo.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里拿到返回值\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e上述三种写法都行，要看注释细节都写在里面了！！像对待Promise一样去对待async的返回值！！！\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e好的接下去我们看\x3ccode\x3eawait\x3c\/code\x3e的干嘛用的.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e3.3 await的本质与例子\x3c\/h3\x3e\n\x3cp\x3eawait的本质是\x3cstrong\x3e可以提供等同于”同步效果“的等待异步返回能力的语法糖\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e这一句咋一看很别扭，好的不急，我们从例子开始看：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const demo = async ()=\x3e{\n    let result = await new Promise((resolve, reject) =\x3e {\n      setTimeout(()=\x3e{\n        resolve(\x27我延迟了一秒\x27)\n      }, 1000)\n    });\n    console.log(\x27我由于上面的程序还没执行完，先不执行“等待一会”\x27);\n}\n\/\/ demo的返回当做Promise\ndemo().then(result=\x3e{\n  console.log(\x27输出\x27,result);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e demo = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27我延迟了一秒\x27\x3c\/span\x3e)\n      }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n    });\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我由于上面的程序还没执行完，先不执行“等待一会”\x27\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ demo的返回当做Promise\x3c\/span\x3e\ndemo().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27输出\x27\x3c\/span\x3e,result);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eawait顾名思义就是等待一会\x3c\/strong\x3e，只要\x3ccode\x3eawait\x3c\/code\x3e声明的函数还没有返回，\x3cstrong\x3e那么下面的程序是不会去执行的！！！\x3c\/strong\x3e。这就是字面意义的等待一会（等待返回再去执行）。\x3c\/p\x3e\n\x3cp\x3e那么你到这测试一下，你会发现输出是这个：\x3ccode\x3e输出 undefined\x3c\/code\x3e。这是为什么呢？这也是我想强调的一个地方！！！\x3c\/p\x3e\n\x3cp\x3e你在\x3ccode\x3edemo\x3c\/code\x3e函数里面都没声明返回，哪来的\x3ccode\x3ethen\x3c\/code\x3e？所以正确写法是这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const demo = async ()=\x3e{\n    let result = await new Promise((resolve, reject) =\x3e {\n      setTimeout(()=\x3e{\n        resolve(\x27我延迟了一秒\x27)\n      }, 1000)\n    });\n    console.log(\x27我由于上面的程序还没执行完，先不执行“等待一会”\x27);\n    return result;\n}\n\/\/ demo的返回当做Promise\ndemo().then(result=\x3e{\n  console.log(\x27输出\x27,result); \/\/ 输出 我延迟了一秒\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e demo = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27我延迟了一秒\x27\x3c\/span\x3e)\n      }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n    });\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我由于上面的程序还没执行完，先不执行“等待一会”\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ demo的返回当做Promise\x3c\/span\x3e\ndemo().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27输出\x27\x3c\/span\x3e,result); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 我延迟了一秒\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我推荐的写法是带上\x3ccode\x3ethen\x3c\/code\x3e，规范一点，当然你没有返回也是没问题的，\x3ccode\x3edemo\x3c\/code\x3e会照常执行。下面这种写法是不带返回值的写法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const demo = async ()=\x3e{\n    let result = await new Promise((resolve, reject) =\x3e {\n      setTimeout(()=\x3e{\n        resolve(\x27我延迟了一秒\x27)\n      }, 1000)\n    });\n    console.log(\x27我由于上面的程序还没执行完，先不执行“等待一会”\x27);\n}\ndemo();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e demo = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27我延迟了一秒\x27\x3c\/span\x3e)\n      }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n    });\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我由于上面的程序还没执行完，先不执行“等待一会”\x27\x3c\/span\x3e);\n}\ndemo();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以可以发现，只要你用await声明的异步返回，是必须“等待”到有返回值的时候，代码才继续执行下去。\x3c\/p\x3e\n\x3cp\x3e那事实是这样吗？你可以跑一下这段代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const demo = async ()=\x3e{\n    let result = await setTimeout(()=\x3e{\n      console.log(\x27我延迟了一秒\x27);\n    }, 1000)\n    console.log(\x27我由于上面的程序还没执行完，先不执行“等待一会”\x27);\n    return result\n}\ndemo().then(result=\x3e{\n  console.log(\x27输出\x27,result);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e demo = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我延迟了一秒\x27\x3c\/span\x3e);\n    }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我由于上面的程序还没执行完，先不执行“等待一会”\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n}\ndemo().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27输出\x27\x3c\/span\x3e,result);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你会发现，输出是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22我由于上面的程序还没执行完，先不执行“等待一会”\n输出 1\n我延迟了一秒\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e我由于上面的程序还没执行完，先不执行“等待一会”\n输出 \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n我延迟了一秒\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e奇怪，并没有await啊？\x3ccode\x3esetTimeout\x3c\/code\x3e是异步啊，问题在哪？问题就在于\x3ccode\x3esetTimeout\x3c\/code\x3e\x3cstrong\x3e这是个异步，但是不是\x3ccode\x3ePromise\x3c\/code\x3e\x3c\/strong\x3e！起不到“等待一会”的作用。\x3c\/p\x3e\n\x3cp\x3e所以更准确的说法应该是\x3cstrong\x3e用await声明的Promise异步返回，必须“等待”到有返回值的时候，代码才继续执行下去。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch4\x3e请记住await是在等待一个Promise的异步返回\x3c\/h4\x3e\n\x3cp\x3e当然这种等待的效果只存在于“异步”的情况，await可以用于声明一般情况下的传值吗？\x3c\/p\x3e\n\x3cp\x3e事实是当然可以：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const demo = async ()=\x3e{\n    let message = \x27我是声明值\x27\n    let result = await message;\n    console.log(result); \n    console.log(\x27我由于上面的程序还没执行完，先不执行“等待一会”\x27);\n    return result\n}\ndemo().then(result=\x3e{\n  console.log(\x27输出\x27,result);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e demo = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e message = \x3cspan class=\x22hljs-string\x22\x3e\x27我是声明值\x27\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e message;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result); \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27我由于上面的程序还没执行完，先不执行“等待一会”\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result\n}\ndemo().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27输出\x27\x3c\/span\x3e,result);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输出：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22我是声明值\n我由于上面的程序还没执行完，先不执行“等待一会”\n输出 我是声明值\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e我是声明值\n我由于上面的程序还没执行完，先不执行“等待一会”\n输出 我是声明值\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里只要注意一点：\x3ccode\x3ethen\x3c\/code\x3e的执行总是最后的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e3.4 async\/await 优势实战\x3c\/h3\x3e\n\x3cp\x3e现在我们看一下实战：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const setDelay = (millisecond) =\x3e {\n  return new Promise((resolve, reject)=\x3e{\n      if (typeof millisecond != \x27number\x27) reject(new Error(\x27参数必须是number类型\x27));\n      setTimeout(()=\x3e {\n        resolve(`我延迟了${millisecond}毫秒后输出的`)\n      }, millisecond)\n  })\n}\nconst setDelaySecond = (seconds) =\x3e {\n  return new Promise((resolve, reject)=\x3e{\n      if (typeof seconds != \x27number\x27 || seconds \x3e 10) reject(new Error(\x27参数必须是number类型，并且小于等于10\x27));\n      setTimeout(()=\x3e {\n        resolve(`我延迟了${seconds}秒后输出的，注意单位是秒`)\n      }, seconds * 1000)\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e setDelay = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3emillisecond\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e millisecond != \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e) reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27参数必须是number类型\x27\x3c\/span\x3e));\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {\n        resolve(\x3cspan class=\x22hljs-string\x22\x3e`我延迟了\x3cspan class=\x22hljs-subst\x22\x3e${millisecond}\x3c\/span\x3e毫秒后输出的`\x3c\/span\x3e)\n      }, millisecond)\n  })\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e setDelaySecond = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eseconds\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e seconds != \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e || seconds \x26gt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e) reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27参数必须是number类型，并且小于等于10\x27\x3c\/span\x3e));\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {\n        resolve(\x3cspan class=\x22hljs-string\x22\x3e`我延迟了\x3cspan class=\x22hljs-subst\x22\x3e${seconds}\x3c\/span\x3e秒后输出的，注意单位是秒`\x3c\/span\x3e)\n      }, seconds * \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e比如上面两个延时函数（写在上面），比如我想先延时1秒，在延迟2秒，再延时1秒，最后输出“完成”，这个过程，如果用\x3ccode\x3ethen\x3c\/code\x3e的写法，大概是这样（嵌套地狱写法出门右拐不送）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setDelay(1000)\n.then(result=\x3e{\n    console.log(result);\n    return setDelaySecond(2)\n})\n.then(result=\x3e{\n    console.log(result);\n    return setDelay(1000)\n})\n.then(result=\x3e{\n    console.log(result);\n    console.log(\x27完成\x27)\n})\n.catch(err=\x3e{\n    console.log(err);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27完成\x27\x3c\/span\x3e)\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e咋一看是不是挺繁琐的？如果逻辑多了估计看得更累，现在我们来试一下async\/await\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async ()=\x3e{\n  const result = await setDelay(1000);\n  console.log(result);\n  console.log(await setDelaySecond(2));\n  console.log(await setDelay(1000));\n  console.log(\x27完成了\x27);\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e));\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e));\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27完成了\x27\x3c\/span\x3e);\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看！是不是没有冗余的长长的链式代码，语义化也非常清楚，非常舒服，那么你看到这里，一定还发现了，上面的\x3ccode\x3ecatch\x3c\/code\x3e我们是不是没有在async中实现？接下去我们就分析一下async\/await如何处理错误？\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e3.5 async\/await错误处理\x3c\/h3\x3e\n\x3cp\x3e因为async函数返回的是一个Promise，所以我们可以在外面\x3ccode\x3ecatch\x3c\/code\x3e住错误。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const demo = async ()=\x3e{\n  const result = await setDelay(1000);\n  console.log(result);\n  console.log(await setDelaySecond(2));\n  console.log(await setDelay(1000));\n  console.log(\x27完成了\x27);\n}\ndemo().catch(err=\x3e{\n    console.log(err);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e demo = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e));\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e));\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27完成了\x27\x3c\/span\x3e);\n}\ndemo().catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在async函数的\x3ccode\x3ecatch\x3c\/code\x3e中捕获错误，当做一个Pormise处理，\x3cstrong\x3e同时你不想用这种方法，可以使用\x3ccode\x3etry...catch\x3c\/code\x3e语句：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async ()=\x3e{\n  try{\n    const result = await setDelay(1000);\n    console.log(result);\n    console.log(await setDelaySecond(2));\n    console.log(await setDelay(1000));\n    console.log(\x27完成了\x27);\n  } catch (e) {\n    console.log(e); \/\/ 这里捕获错误\n  }\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27完成了\x27\x3c\/span\x3e);\n  } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里捕获错误\x3c\/span\x3e\n  }\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然这时候你就不需要在外面\x3ccode\x3ecatch\x3c\/code\x3e了。\x3c\/p\x3e\n\x3cp\x3e通常我们的\x3ccode\x3etry...catch\x3c\/code\x3e数量不会太多，几个最多了，\x3cstrong\x3e如果太多了，说明你的代码肯定需要重构了，一定没有写得非常好。还有一点就是try...catch通常只用在需要的时候，有时候不需要catch错误的地方就可以不写。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e有人会问了，我\x3ccode\x3etry...catch\x3c\/code\x3e好像只能包裹代码块，如果我需要拆分开分别处理，\x3cstrong\x3e不想因为一个的错误就整个process都crash掉了\x3c\/strong\x3e，那么难道我要写一堆\x3ccode\x3etry...catch\x3c\/code\x3e吗？我就是别扭，我就是不想写\x3ccode\x3etry...catch\x3c\/code\x3e怎嘛办？下面有一种很好的解决方案，仅供参考：\x3c\/p\x3e\n\x3cp\x3e我们知道await后面跟着的肯定是一个\x3ccode\x3ePromise\x3c\/code\x3e那是不是可以这样写？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async ()=\x3e{\n  const result = await setDelay(1000).catch(err=\x3e{\n      console.log(err)\n  });\n  console.log(result);\n  const result1 = await setDelaySecond(12).catch(err=\x3e{\n      console.log(err)\n  })\n  console.log(result1);\n  console.log(await setDelay(1000));\n  console.log(\x27完成了\x27);\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)\n  });\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result1 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)\n  })\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result1);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e));\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27完成了\x27\x3c\/span\x3e);\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样输出：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22我延迟了1000毫秒后输出的\nError: 参数必须是number类型，并且小于等于10\n    at Promise (test4.html:19)\n    at new Promise (\x3canonymous\x3e)\n    at setDelaySecond (test4.html:18)\n    at test4.html:56\nundefined\n我延迟了1000毫秒后输出的\n完成了\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e我延迟了\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e毫秒后输出的\n\x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e: 参数必须是number类型，并且小于等于\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\n    at \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e (test4.html:\x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e)\n    at \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e (\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eanonymous\x3c\/span\x3e\x26gt;\x3c\/span\x3e)\n    at setDelaySecond (test4.html:18)\n    at test4.html:56\nundefined\n我延迟了1000毫秒后输出的\n完成了\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e是不是就算有错误，也不会影响后续的操作，是不是很棒？\x3cstrong\x3e当然不是，你说这代码也忒丑了吧，乱七八糟的，写得别扭await又跟着catch\x3c\/strong\x3e。那么我们可以改进一下，封装一下提取错误的代码函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ to function\nfunction to(promise) {\n   return promise.then(data =\x3e {\n      return [null, data];\n   })\n   .catch(err =\x3e [err]); \/\/ es6的返回写法\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ to function\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eto\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epromise\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e promise.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e [\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, data];\n   })\n   .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e [err]); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ es6的返回写法\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e返回的是一个数组，第一个是错误，第二个是异步结果，使用如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async ()=\x3e{\n   \/\/ es6的写法，返回一个数组(你可以改回es5的写法觉得不习惯的话)，第一个是错误信息，第二个是then的异步返回数据，这里要注意一下重复变量声明可能导致问题（这里举例是全局，如果用let，const，请换变量名）。\n  [err, result] = await to(setDelay(1000)) \n   \/\/ 如果err存在就是有错，不想继续执行就抛出错误\n  if (err) throw new Error(\x27出现错误，同时我不想执行了\x27);\n  console.log(result);\n  [err, result1] = await to(setDelaySecond(12))\n   \/\/ 还想执行就不要抛出错误\n  if (err) console.log(\x27出现错误，同时我想继续执行\x27, err);\n  console.log(result1);\n  console.log(await setDelay(1000));\n  console.log(\x27完成了\x27);\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ es6的写法，返回一个数组(你可以改回es5的写法觉得不习惯的话)，第一个是错误信息，第二个是then的异步返回数据，这里要注意一下重复变量声明可能导致问题（这里举例是全局，如果用let，const，请换变量名）。\x3c\/span\x3e\n  [err, result] = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e to(setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)) \n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果err存在就是有错，不想继续执行就抛出错误\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27出现错误，同时我不想执行了\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  [err, result1] = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e to(setDelaySecond(\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e))\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 还想执行就不要抛出错误\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27出现错误，同时我想继续执行\x27\x3c\/span\x3e, err);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result1);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e));\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27完成了\x27\x3c\/span\x3e);\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e3.6 async\/await的中断（终止程序）\x3c\/h3\x3e\n\x3cp\x3e首先我们要明确的是，\x3ccode\x3ePromise\x3c\/code\x3e\x3cstrong\x3e本身是无法中止的\x3c\/strong\x3e，\x3ccode\x3ePromise\x3c\/code\x3e本身\x3cstrong\x3e只是一个状态机\x3c\/strong\x3e，存储三个状态（pending，resolved，rejected），一旦发出请求了，\x3cstrong\x3e必须闭环，无法取消\x3c\/strong\x3e，之前处于pending状态只是一个挂起请求的状态，并不是取消，一般不会让这种情况发生，只是用来临时中止链式的进行。\x3c\/p\x3e\n\x3cp\x3e中断（终止）的本质在链式中只是挂起，并不是本质的取消\x3ccode\x3ePromise\x3c\/code\x3e请求，那样是做不到的，\x3ccode\x3ePromise\x3c\/code\x3e也没有\x3ccode\x3ecancel\x3c\/code\x3e的状态。\x3c\/p\x3e\n\x3cp\x3e不同于\x3ccode\x3ePromise\x3c\/code\x3e的链式写法，写在async\/await中想要中断程序就很简单了，因为语义化非常明显，其实就和一般的\x3ccode\x3efunction\x3c\/code\x3e写法一样，想要中断的时候，直接\x3ccode\x3ereturn\x3c\/code\x3e一个值就行，\x3ccode\x3enull\x3c\/code\x3e，空，\x3ccode\x3efalse\x3c\/code\x3e都是可以的。看例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let count = 6;\nconst demo = async ()=\x3e{\n  const result = await setDelay(1000);\n  console.log(result);\n  const result1 = await setDelaySecond(count);\n  console.log(result1);\n  if (count \x3e 5) {\n      return \x27我退出了，下面的不进行了\x27;\n    \/\/ return; \n    \/\/ return false; \/\/ 这些写法都可以\n    \/\/ return null;\n  }\n  console.log(await setDelay(1000));\n  console.log(\x27完成了\x27);\n};\ndemo().then(result=\x3e{\n  console.log(result);\n})\n.catch(err=\x3e{\n  console.log(err);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e count = \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e demo = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result1 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelaySecond(count);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result1);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (count \x26gt; \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27我退出了，下面的不进行了\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return; \x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return false; \/\/ 这些写法都可以\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return null;\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e));\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27完成了\x27\x3c\/span\x3e);\n};\ndemo().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n})\n.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实质就是直接\x3ccode\x3ereturn\x3c\/code\x3e返回了一个\x3ccode\x3ePromise\x3c\/code\x3e，相当于\x3ccode\x3ereturn Promise.resolve(\x27我退出了下面不进行了\x27)\x3c\/code\x3e，当然你也可以返回一个“拒绝”：\x3ccode\x3ereturn Promise.reject(new Error(\x27拒绝\x27))\x3c\/code\x3e那么就会进到错误信息里去。\x3c\/p\x3e\n\x3ch5\x3easync函数实质就是返回一个Promise！\x3c\/h5\x3e\n\x3ch2 id=\x22articleHeader18\x22\x3e四、实战中异步需要注意的地方\x3c\/h2\x3e\n\x3cp\x3e我们经常会使用上述两种写法，也可能混用，有时候会遇到一些情况，这边举例子说明：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3e4.1 Promise获取数据(串行)之then写法注意\x3c\/h3\x3e\n\x3cp\x3e并行的不用多说，很简单，直接循环发出请求就可以或者用\x3ccode\x3ePromise.all\x3c\/code\x3e。如果我们需要串行循环一个请求，那么应该怎么做呢？\x3c\/p\x3e\n\x3cp\x3e我们需要实现\x3cstrong\x3e一个依次分别延迟1秒输出值，一共5秒的程序\x3c\/strong\x3e，首先是Promise的循环，这个循环就相对来说比较麻烦：\x3c\/p\x3e\n\x3ch5\x3e我们经常会犯的错误！就是不重视函数名与函数执行对程序的影响\x3c\/h5\x3e\n\x3cp\x3e先不说循环，我们先举一个错误的例子，现在有一个延迟函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const setDelay = (millisecond) =\x3e {\n  return new Promise((resolve, reject)=\x3e{\n      if (typeof millisecond != \x27number\x27) reject(new Error(\x27参数必须是number类型\x27));\n      setTimeout(()=\x3e {\n        resolve(`我延迟了${millisecond}毫秒后输出的`)\n      }, millisecond)\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e setDelay = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3emillisecond\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e millisecond != \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e) reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27参数必须是number类型\x27\x3c\/span\x3e));\n      setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {\n        resolve(\x3cspan class=\x22hljs-string\x22\x3e`我延迟了\x3cspan class=\x22hljs-subst\x22\x3e${millisecond}\x3c\/span\x3e毫秒后输出的`\x3c\/span\x3e)\n      }, millisecond)\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们想做到：\x3cstrong\x3e“循环串行执行延迟一秒的Promise函数”\x3c\/strong\x3e，期望的结果应该是：隔一秒输出\x3ccode\x3e我延迟了1000毫秒后输出的\x3c\/code\x3e，一共经过循环3次。我们想当然地写出下列的链式写法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22arr = [setDelay(1000), setDelay(1000), setDelay(1000)]\narr[0]\n.then(result=\x3e{\n  console.log(result)\n  return arr[1]\n})\n.then(result=\x3e{\n  console.log(result)\n  return arr[2]\n})\n.then(result=\x3e{\n  console.log(result)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3earr = [setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e), setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e), setDelay(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)]\narr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是很不幸，\x3cstrong\x3e你发现输出是并行的！！！也就是说一秒钟一次性输出了3个值！\x3c\/strong\x3e。那么这是什么情况呢？其实很简单。。。\x3cstrong\x3e就是你把\x3ccode\x3esetDelay(1000)\x3c\/code\x3e这个直接添加到数组的时候，其实就已经执行了，注意你的执行语句\x3ccode\x3e(1000)\x3c\/code\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e这其实是基础，是语言的特性，很多粗心的人（或者是没有好好学习JS的人）会以为这样就把函数添加到数组里面了，殊不知函数已经执行过一次了。\x3c\/p\x3e\n\x3cp\x3e那么这样导致的后果是什么呢？也就是说数组里面保存的每个\x3ccode\x3ePromise\x3c\/code\x3e状态都是\x3ccode\x3eresolve\x3c\/code\x3e完成的状态了，那么你后面链式调用直接\x3ccode\x3ereturn arr[1]\x3c\/code\x3e其实没有去请求，只是\x3cstrong\x3e立即返回了一个resolve的状态\x3c\/strong\x3e。所以你会发现程序是相当于并行的，没有依次顺序调用。\x3c\/p\x3e\n\x3cp\x3e那么解决方案是什么呢？直接函数名存储函数的方式（不执行Promise）来达到目的\x3c\/p\x3e\n\x3cp\x3e我们这样改一下程序：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22arr = [setDelay, setDelay, setDelay]\narr[0](1000)\n.then(result=\x3e{\n  console.log(result)\n  return arr[1](1000)\n})\n.then(result=\x3e{\n  console.log(result)\n  return arr[2](1000)\n})\n.then(result=\x3e{\n  console.log(result)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3earr = [setDelay, setDelay, setDelay]\narr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e](\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e](\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e](\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n})\n.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述相当于把\x3ccode\x3ePromise\x3c\/code\x3e预先存储在一个数组中，在你需要调用的时候，再去执行。当然你也可以用闭包的方式存储起来，需要调用的时候再执行。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader20\x22\x3e4.2 Promise循环获取数据(串行)之for循环\x3c\/h3\x3e\n\x3cp\x3e上述写法是不优雅的，次数一多就GG了，为什么要提一下上面的\x3ccode\x3ethen\x3c\/code\x3e，其实就是为了后面的\x3ccode\x3efor\x3c\/code\x3e循环做铺垫。\x3c\/p\x3e\n\x3cp\x3e上面的程序根据规律改写一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22arr = [setDelay, setDelay, setDelay]\nvar temp\ntemp = arr[0](1000)\nfor (let i = 1; i \x3c= arr.length; i\x2b\x2b) {\n    if (i == arr.length) {\n      temp.then(result=\x3e{\n        console.log(\x27完成了\x27);\n      })\n      break;\n    }\n    temp = temp.then((result)=\x3e{\n        console.log(result);\n        return arr[i-1](1000)\n    });\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3earr = [setDelay, setDelay, setDelay]\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e temp\ntemp = arr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e](\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt;= arr.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (i == arr.length) {\n      temp.then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27完成了\x27\x3c\/span\x3e);\n      })\n      \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n    }\n    temp = temp.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr[i\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e](\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n    });\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e错误处理可以在for循环中套入\x3ccode\x3etry...catch\x3c\/code\x3e，或者在你每个循环点进行\x3ccode\x3e.then().catch()\x3c\/code\x3e、都是可行的。如果你想提取成公共方法，可以再改写一下，利用递归的方式：\x3c\/p\x3e\n\x3cp\x3e首先你需要闭包你的\x3ccode\x3ePromise\x3c\/code\x3e程序\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function timeout(millisecond) {\n  return ()=\x3e {\n    return setDelay(millisecond);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emillisecond\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e setDelay(millisecond);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果不闭包会导致什么后果呢？不闭包的话，你传入的参数值后，\x3cstrong\x3e你的Promise会马上执行，导致状态改变\x3c\/strong\x3e，如果用闭包实现的话，你的Promise会一直保存着，等到你需要调用的时候再使用。而且\x3cstrong\x3e最大的优点是可以预先传入你需要的参数\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e改写数组：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22arr = [timeout(2000), timeout(1000), timeout(1000)]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3earr = [timeout(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e), timeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e), timeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e提取方法，\x3ccode\x3ePromise\x3c\/code\x3e数组作为参数传入：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const syncPromise = function (arr) {\n  const _syncLoop = function (count) {\n    if (count === arr.length - 1) { \/\/ 是最后一个就直接return\n      return arr[count]()\n    }\n    return arr[count]().then((result)=\x3e{\n      console.log(result);\n      return _syncLoop(count\x2b1) \/\/ 递归调用数组下标\n    });\n  }\n  return _syncLoop(0);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e syncPromise = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e _syncLoop = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecount\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (count === arr.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是最后一个就直接return\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr[count]()\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr[count]().then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _syncLoop(count\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 递归调用数组下标\x3c\/span\x3e\n    });\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _syncLoop(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22syncPromise(arr).then(result=\x3e{\n  console.log(result);\n  console.log(\x27完成了\x27);\n})\n\/\/ 或者 添加到Promise类中方法\nPromise.syncAll = function syncAll(){\n  return syncPromise\n}\/\/ 以后可以直接使用\nPromise.syncAll(arr).then(result=\x3e{\n  console.log(result);\n  console.log(\x27完成了\x27);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esyncPromise(arr).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27完成了\x27\x3c\/span\x3e);\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 或者 添加到Promise类中方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.syncAll = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esyncAll\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e syncPromise\n}\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以后可以直接使用\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.syncAll(arr).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27完成了\x27\x3c\/span\x3e);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还有大神总结了一个\x3ccode\x3ereduce\x3c\/code\x3e的写法，其实就是一个迭代数组的过程：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const p = arr.reduce((total, current)=\x3e{\n    return total.then((result)=\x3e{\n        console.log(result);\n        return current()\n    })\n}, Promise.resolve(\x27程序开始\x27))\np.then((result)=\x3e{\n    console.log(\x27结束了\x27, result);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e p = arr.reduce(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etotal, current\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e total.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e current()\n    })\n}, \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-string\x22\x3e\x27程序开始\x27\x3c\/span\x3e))\np.then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27结束了\x27\x3c\/span\x3e, result);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e都是可行的，在\x3ccode\x3ePromise\x3c\/code\x3e的循环领域。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader21\x22\x3e4.3 async\/await循环获取数据(串行)之for循环\x3c\/h3\x3e\n\x3cp\x3e现在就来介绍一下牛逼的async\/await实战，上述的代码你是不是要看吐了，的确，我也觉得好麻烦啊，那么如果用\x3ccode\x3easync\/await\x3c\/code\x3e能有什么改进吗？这就是它出现的意义：\x3c\/p\x3e\n\x3cp\x3e模拟上述代码的循环：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(async ()=\x3e{\n    arr = [timeout(2000), timeout(1000), timeout(1000)]\n    for (var i=0; i \x3c arr.length; i\x2b\x2b) {\n        result = await arr[i]();\n        console.log(result);\n    }\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e ()=\x26gt;{\n    arr = [timeout(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e), timeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e), timeout(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)]\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; arr.length; i\x2b\x2b) {\n        result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e arr[i]();\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n    }\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e。。。这就完了？是的。。。就完了，是不是特别方便！！！！语义化也非常明显！！这里为了保持与上面风格一致，没有加入错误处理，所以实战的时候记得加入你的\x3ccode\x3etry...catch\x3c\/code\x3e语句来捕获错误。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader22\x22\x3e四、后记\x3c\/h2\x3e\n\x3cp\x3e一直想总结一下\x3ccode\x3ePromise\x3c\/code\x3e和\x3ccode\x3easync\/await\x3c\/code\x3e，很多地方可能总结得不够，已经尽力扩大篇幅了，后续有新的知识点和总结点可能会更新（未完待续），但是入门这个基本够用了。\x3c\/p\x3e\n\x3cp\x3e我们常说什么\x3ccode\x3easync\/await\x3c\/code\x3e的出现淘汰了Promise，可以说是大错特错，恰恰相反，正因为有了Promise，才有了改良版的\x3ccode\x3easync\/await\x3c\/code\x3e，从上面分析就可以看出，两者是相辅相成的，缺一不可。\x3c\/p\x3e\n\x3cp\x3e想学好\x3ccode\x3easync\/await\x3c\/code\x3e必须先精通\x3ccode\x3ePromise\x3c\/code\x3e，两者密不可分，有不同意见和改进的欢迎指导！\x3c\/p\x3e\n\x3cp\x3e前端小白，大家互相交流，peace！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>异步Promise及Async/Await可能最完整入门攻略</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016788484">https://segmentfault.com/a/1190000016788484</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/eumgejkx1ln/" target="_blank">https://alili.tech/archive/eumgejkx1ln/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>