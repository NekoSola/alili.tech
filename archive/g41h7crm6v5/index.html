<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript检测原始值、引用值、属性"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript检测原始值、引用值、属性 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/g41h7crm6v5/",
				"appid": "1613049289050283", 
				"title": "JavaScript检测原始值、引用值、属性 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-08T02:30:41"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/p9y8vgc0mz/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/dn63hqg0orn/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fg41h7crm6v5%2f&text=JavaScript%e6%a3%80%e6%b5%8b%e5%8e%9f%e5%a7%8b%e5%80%bc%e3%80%81%e5%bc%95%e7%94%a8%e5%80%bc%e3%80%81%e5%b1%9e%e6%80%a7"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fg41h7crm6v5%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fg41h7crm6v5%2f&text=JavaScript%e6%a3%80%e6%b5%8b%e5%8e%9f%e5%a7%8b%e5%80%bc%e3%80%81%e5%bc%95%e7%94%a8%e5%80%bc%e3%80%81%e5%b1%9e%e6%80%a7"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fg41h7crm6v5%2f&title=JavaScript%e6%a3%80%e6%b5%8b%e5%8e%9f%e5%a7%8b%e5%80%bc%e3%80%81%e5%bc%95%e7%94%a8%e5%80%bc%e3%80%81%e5%b1%9e%e6%80%a7"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fg41h7crm6v5%2f&is_video=false&description=JavaScript%e6%a3%80%e6%b5%8b%e5%8e%9f%e5%a7%8b%e5%80%bc%e3%80%81%e5%bc%95%e7%94%a8%e5%80%bc%e3%80%81%e5%b1%9e%e6%80%a7"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%e6%a3%80%e6%b5%8b%e5%8e%9f%e5%a7%8b%e5%80%bc%e3%80%81%e5%bc%95%e7%94%a8%e5%80%bc%e3%80%81%e5%b1%9e%e6%80%a7&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fg41h7crm6v5%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fg41h7crm6v5%2f&title=JavaScript%e6%a3%80%e6%b5%8b%e5%8e%9f%e5%a7%8b%e5%80%bc%e3%80%81%e5%bc%95%e7%94%a8%e5%80%bc%e3%80%81%e5%b1%9e%e6%80%a7"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fg41h7crm6v5%2f&title=JavaScript%e6%a3%80%e6%b5%8b%e5%8e%9f%e5%a7%8b%e5%80%bc%e3%80%81%e5%bc%95%e7%94%a8%e5%80%bc%e3%80%81%e5%b1%9e%e6%80%a7"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fg41h7crm6v5%2f&title=JavaScript%e6%a3%80%e6%b5%8b%e5%8e%9f%e5%a7%8b%e5%80%bc%e3%80%81%e5%bc%95%e7%94%a8%e5%80%bc%e3%80%81%e5%b1%9e%e6%80%a7"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fg41h7crm6v5%2f&title=JavaScript%e6%a3%80%e6%b5%8b%e5%8e%9f%e5%a7%8b%e5%80%bc%e3%80%81%e5%bc%95%e7%94%a8%e5%80%bc%e3%80%81%e5%b1%9e%e6%80%a7"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript检测原始值、引用值、属性</h1><div class="meta"><div class="postdate"><time datetime="2019-02-08" itemprop="datePublished">2019-02-08</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e上周写过一篇读书笔记\x3ca href=\x22http:\/\/shijiajie.com\/2016\/06\/12\/javascript-maintainable-javascript-practice\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《编写可维护的JavaScript》之编程实践\x3c\/a\x3e，其中 \x3cstrong\x3e第8章 避免『空比较』\x3c\/strong\x3e是博主在工作中遇坑较多的雷区，所以特此把该章节重新整理分享，希望大家不再坑队友(＞﹏＜)。\x3c\/p\x3e\n\x3cp\x3e在 JavaScript 中，我们常常会看到这样的代码：变量与\x3ccode\x3enull\x3c\/code\x3e的比较（这种用法很有问题），用来判断变量是否被赋予了一个合理的值。比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Controller = {\n    process: function(items) {\n        if (items !== null) { \/\/ 不好的写法\n            items.sort();\n            items.forEach(function(item) {\n                \/\/ 执行一些逻辑\n            });\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Controller = {\n    \x3cspan class=\x22hljs-attr\x22\x3eprocess\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitems\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (items !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不好的写法\x3c\/span\x3e\n            items.sort();\n            items.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行一些逻辑\x3c\/span\x3e\n            });\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这段代码中，\x3ccode\x3eprocess()\x3c\/code\x3e方法显然希望\x3ccode\x3eitems\x3c\/code\x3e是一个数组，因为我们看到\x3ccode\x3eitems\x3c\/code\x3e拥有\x3ccode\x3esort()\x3c\/code\x3e和\x3ccode\x3eforEach()\x3c\/code\x3e。这段代码的意图非常明显：如果参数\x3ccode\x3eitems\x3c\/code\x3e不是一个组数，则停止接下来的操作。这种写法的问题在于，和\x3ccode\x3enull\x3c\/code\x3e的比较并不能真正避免错误的发生。\x3ccode\x3eitems\x3c\/code\x3e的值可以是1，也可以是是字符串，甚至可以是任意对象。这些值都和\x3ccode\x3enull\x3c\/code\x3e不相等，进而会导致\x3ccode\x3eprocess()\x3c\/code\x3e方法一旦执行到\x3ccode\x3esort()\x3c\/code\x3e时就会出错。\x3c\/p\x3e\n\x3cp\x3e仅仅和\x3ccode\x3enull\x3c\/code\x3e比较并不能提供足够的信息来判断后续代码的执行是否真的安全。好在 JavaScript 为我们提供了很多种方法来检测变量的真实值。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e检测原始值\x3c\/h2\x3e\n\x3cp\x3e在 JavaScript 中有5种原始类型（也称为简单数据类型）： \x3ccode\x3eString\x3c\/code\x3e、\x3ccode\x3eNumber\x3c\/code\x3e、\x3ccode\x3eBoolean\x3c\/code\x3e、\x3ccode\x3eUndefined\x3c\/code\x3e和\x3ccode\x3eNull\x3c\/code\x3e。如果你希望一个值是\x3ccode\x3eString\x3c\/code\x3e、\x3ccode\x3eNumber\x3c\/code\x3e、\x3ccode\x3eBoolean\x3c\/code\x3e或\x3ccode\x3eUndefined\x3c\/code\x3e，最佳选择是使用\x3ccode\x3etypeof\x3c\/code\x3e运算符，它会返回一个表示类型的字符串。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e对于字符串，\x3ccode\x3etypeof\x3c\/code\x3e返回\x3ccode\x3e\x22string\x22\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e对于数字，\x3ccode\x3etypeof\x3c\/code\x3e返回\x3ccode\x3e\x22number\x22\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e对于布尔值，\x3ccode\x3etypeof\x3c\/code\x3e返回\x3ccode\x3e\x22boolean\x22\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e对于undefined，\x3ccode\x3etypeof\x3c\/code\x3e返回\x3ccode\x3e\x22undefined\x22\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3etypeof\x3c\/code\x3e的基本语法是：\x3ccode\x3etypeof variable\x3c\/code\x3e，你还可以这样用：\x3ccode\x3etypeof(variable)\x3c\/code\x3e，尽管这是合法的 JavaScript 语法，这种用法让\x3ccode\x3etypeof\x3c\/code\x3e看起来像一个函数而非运算符。鉴于此，我们更推荐无括号的写法。\x3c\/p\x3e\n\x3cp\x3e使用\x3ccode\x3etypeof\x3c\/code\x3e来检测这4种原始类型是非常安全的做法。来看下面这些例子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 检测\x26quot;String\x26quot;\nif (typeof name === \x26quot;string\x26quot;) {\n    anotherName = name.substring(3);\n}\n\n\/\/ 检测\x26quot;Number\x26quot;\nif (typeof count === \x26quot;number\x26quot;) {\n    updateCount(count);\n}\n\n\/\/ 检测\x26quot;Boolean\x26quot;\nif (typeof found === \x26quot;boolean\x26quot; \x26amp;\x26amp; found) {\n    message(\x26quot;Found!\x26quot;);\n}\n\n\/\/ 检测\x26quot;Undefined\x26quot;\nif (typeof MyApp === \x26quot;undefined\x26quot;) {\n    MyApp = {\n        \/\/ 其他代码\n    };\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检测\x22String\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e name === \x3cspan class=\x22hljs-string\x22\x3e\x22string\x22\x3c\/span\x3e) {\n    anotherName = name.substring(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检测\x22Number\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e count === \x3cspan class=\x22hljs-string\x22\x3e\x22number\x22\x3c\/span\x3e) {\n    updateCount(count);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检测\x22Boolean\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e found === \x3cspan class=\x22hljs-string\x22\x3e\x22boolean\x22\x3c\/span\x3e \x26amp;\x26amp; found) {\n    message(\x3cspan class=\x22hljs-string\x22\x3e\x22Found!\x22\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检测\x22Undefined\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e MyApp === \x3cspan class=\x22hljs-string\x22\x3e\x22undefined\x22\x3c\/span\x3e) {\n    MyApp = {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其他代码\x3c\/span\x3e\n    };\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3etypeof\x3c\/code\x3e运算符的独特之处在于，将其用于一个未声明的变量也不会报错。未定义的变量和值为\x3ccode\x3eundefined\x3c\/code\x3e的变量通过\x3ccode\x3etypeof\x3c\/code\x3e都将返回\x3ccode\x3e\x22undefined\x22\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e最后一个原始类型\x3ccode\x3enull\x3c\/code\x3e，通过\x3ccode\x3etypeof\x3c\/code\x3e将返回\x3ccode\x3e\x22object\x22\x3c\/code\x3e，这看上去很怪异，被认为是标准规范的严重 bug，因此在编程时要 \x3cstrong\x3e杜绝使用\x3ccode\x3etypeof\x3c\/code\x3e来检测\x3ccode\x3enull\x3c\/code\x3e的类型\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(typeof null);   \/\/ \x26quot;object\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22object\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e简单地和\x3ccode\x3enull\x3c\/code\x3e进行比较通常不会包含足够的信息以判断值的类型是否合法，所以\x3ccode\x3enull\x3c\/code\x3e一般不应用于检测语句。\x3c\/p\x3e\n\x3cp\x3e但有一个例外，如果所期望的值真的是\x3ccode\x3enull\x3c\/code\x3e，则可以直接和\x3ccode\x3enull\x3c\/code\x3e进行比较。例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 如果你需要检测 null，则使用这种方法\nvar element = document.getElementById(\x26quot;my-div\x26quot;);\nif (element !== null) {\n    element.className = \x26quot;found\x26quot;;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果你需要检测 null，则使用这种方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e element = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22my-div\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (element !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    element.className = \x3cspan class=\x22hljs-string\x22\x3e\x22found\x22\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果 DOM 元素不存在，则通过\x3ccode\x3edocument.getElementById()\x3c\/code\x3e得到的值为\x3ccode\x3enull\x3c\/code\x3e。这个方法要么返回一个节点，要么返回\x3ccode\x3enull\x3c\/code\x3e。由于这时\x3ccode\x3enull\x3c\/code\x3e是可预见的一种输出，则可以用恒等运算符\x3ccode\x3e===\x3c\/code\x3e或非恒等运算符\x3ccode\x3e!==\x3c\/code\x3e来检测返回结果。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3etypeof\x3c\/code\x3e运算符的返回值除了上述提到的\x3ccode\x3estring\x3c\/code\x3e、\x3ccode\x3enumber\x3c\/code\x3e、\x3ccode\x3eboolean\x3c\/code\x3e、\x3ccode\x3eundefined\x3c\/code\x3e和\x3ccode\x3eobject\x3c\/code\x3e之外，还有\x3ccode\x3efunction\x3c\/code\x3e。从技术的角度来讲，函数在 JavaScript 中也是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过\x3ccode\x3etypeof\x3c\/code\x3e运算符来区分函数和其他对象是有必要的。这一特性将在后面 \x3cstrong\x3e检测函数\x3c\/strong\x3e 中用到。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e检测引用值\x3c\/h2\x3e\n\x3cp\x3e在 JavaScript 中除了原始值之外的都是引用值（也称为对象），常用的引用类型有：\x3ccode\x3eObject\x3c\/code\x3e、\x3ccode\x3eArray\x3c\/code\x3e、\x3ccode\x3eDate\x3c\/code\x3e和\x3ccode\x3eRegExp\x3c\/code\x3e，这些引用类型都是 JavaScript 的内置对象。\x3ccode\x3etypeof\x3c\/code\x3e运算符在判断这些引用类型时全都返回\x3ccode\x3e\x22object\x22\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(typeof {});             \/\/ \x26quot;object\x26quot;\nconsole.log(typeof []);             \/\/ \x26quot;object\x26quot;\nconsole.log(typeof new Date());     \/\/ \x26quot;object\x26quot;\nconsole.log(typeof new RegExp());   \/\/ \x26quot;object\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e {});             \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22object\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e []);             \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22object\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e());     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22object\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e());   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22object\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e检测某个引用值类型的最好方法是使用\x3ccode\x3einstanceof\x3c\/code\x3e运算符，\x3ccode\x3einstanceof\x3c\/code\x3e的基本语法是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22value instanceof constructor\n\n\/\/ 检测日期\nif (value instanceof Date) {\n    console.log(value.getFullYear);\n}\n\n\/\/ 检测 Error\nif (value instanceof Error) {\n    throw value;\n}\n\n\/\/ 检测正则表达式\nif (value instanceof RegExp) {\n    if (value.test(anotherValue)) {\n        console.log(\x26quot;Matches\x26quot;);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3evalue \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e\n\n\/\/ 检测日期\nif (value instanceof Date) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value.getFullYear);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检测 Error\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (value \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e value;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检测正则表达式\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (value \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (value.test(anotherValue)) {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Matches\x22\x3c\/span\x3e);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3einstanceof\x3c\/code\x3e的一个有意思的特性是它不仅检测构造这个对象的构造器，还检测原型链。原型链包含了很多信息，包括定义对象所采用的继承模式。比如，默认情况下，每个对象都继承自\x3ccode\x3eObject\x3c\/code\x3e，因此每个对象的\x3ccode\x3evalue instanceof Object\x3c\/code\x3e都会返回\x3ccode\x3eture\x3c\/code\x3e。比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var now = new Date();\nconsole.log(now instanceof Object); \/\/ ture\nconsole.log(now instanceof Date);   \/\/ ture\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e now = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(now \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ture\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(now \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e);   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ture\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3einstanceof\x3c\/code\x3e运算符也可以检测自定义的类型，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name){\n    this.name = name;\n}\nvar me = new Person(\x26quot;Nicholas\x26quot;);\nconsole.log(me instanceof Object);  \/\/ ture\nconsole.log(me instanceof Person);  \/\/ ture\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e me = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22Nicholas\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(me \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ture\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(me \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Person);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ture\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段示例代码中创建了\x3ccode\x3ePerson\x3c\/code\x3e类型。变量\x3ccode\x3eme\x3c\/code\x3e是\x3ccode\x3ePerson\x3c\/code\x3e的实例，因此\x3ccode\x3eme instanceof Person\x3c\/code\x3e是\x3ccode\x3etrue\x3c\/code\x3e。上文也提到，所有的对象都被认为是\x3ccode\x3eObject\x3c\/code\x3e的实例，因此\x3ccode\x3eme instanceof Object\x3c\/code\x3e也是\x3ccode\x3eture\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e在 JavaScript 中检测 \x3cstrong\x3e内置类型\x3c\/strong\x3e 和 \x3cstrong\x3e自定义类型\x3c\/strong\x3e 时，最好的做法就是使用\x3ccode\x3einstanceof\x3c\/code\x3e运算符，这也是唯一的方法。\x3c\/p\x3e\n\x3cp\x3e但有一个严重的限制，假设两个浏览器帧（frame）里都有构造函数\x3ccode\x3ePerson\x3c\/code\x3e，帧A中的\x3ccode\x3ePerson\x3c\/code\x3e实例\x3ccode\x3eframeAPersonInstance\x3c\/code\x3e传入到帧B中，则会有如下结果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(frameAPersonInstance instanceof frameAPerson)    \/\/ ture\nconsole.log(frameAPersonInstance instanceof frameBPerson)    \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(frameAPersonInstance \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e frameAPerson)    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ture\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(frameAPersonInstance \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e frameBPerson)    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e尽管两个\x3ccode\x3ePerson\x3c\/code\x3e的定义是完全一样的，但在不同帧（frame）里，他们被认为是不同类型。有两个非常重要的内置类型也有这个问题：\x3ccode\x3eArray\x3c\/code\x3e和\x3ccode\x3eFunction\x3c\/code\x3e，所以检测它们一般不使用\x3ccode\x3einstanceof\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e检测函数\x3c\/h3\x3e\n\x3cp\x3e从技术上讲，JavaScript 中的函数是引用类型，同样存在\x3ccode\x3eFunction\x3c\/code\x3e构造函数，每个函数都是其实例，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function myFunc() {}\n\n\/\/ 不好的写法\nconsole.log(myFunc instanceof Function); \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emyFunc\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不好的写法\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(myFunc \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然而，这个方法亦不能跨帧（frame）使用，因为每个帧都有各自的\x3ccode\x3eFunction\x3c\/code\x3e构造函数，好在\x3ccode\x3etypeof\x3c\/code\x3e运算符也是可以用于函数的，返回\x3ccode\x3e\x22function\x22\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function myFunc() {}\n\n\/\/ 好的写法\nconsole.log(typeof myFunc === \x26quot;function\x26quot;); \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emyFunc\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 好的写法\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e myFunc === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e检测函数最好的方法是使用\x3ccode\x3etypeof\x3c\/code\x3e，因为他可以跨帧（frame）使用。\x3c\/p\x3e\n\x3cp\x3e用\x3ccode\x3etypeof\x3c\/code\x3e来检测函数有一个限制。在 IE 8 和更早版本的 IE 浏览器中，使用\x3ccode\x3etypeof\x3c\/code\x3e来检测 DOM 节点中的函数都返回\x3ccode\x3e\x22object\x22\x3c\/code\x3e而不是\x3ccode\x3e\x22function\x22\x3c\/code\x3e。比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ IE8 及更早版本的IE\nconsole.log(typeof document.createElement);         \/\/ \x26quot;object\x26quot;\nconsole.log(typeof document.getElementById);        \/\/ \x26quot;object\x26quot;\nconsole.log(typeof document.getElementByTagName);   \/\/ \x26quot;object\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ IE8 及更早版本的IE\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement);         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22object\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById);        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22object\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementByTagName);   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22object\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e之所以出现这种怪异的现象是因为浏览器对 DOM 的实现有差异。简言之，这些早版本的 IE 并没有将 DOM 实现为内置的 JavaScript 方法，导致内置\x3ccode\x3etypeof\x3c\/code\x3e运算符将这些函数识别为对象。因为 DOM 是有明确定义的，了解到对象成员如果存在则意味着它是一个方法，开发者往往通过\x3ccode\x3ein\x3c\/code\x3e运算符来检测 DOM 的方法，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 检测 DOM 方法\nif (\x26quot;querySelectorAll\x26quot; in document) {\n    var images = document.querySelectorAll(\x26quot;img\x26quot;);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检测 DOM 方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22querySelectorAll\x22\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e images = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelectorAll(\x3cspan class=\x22hljs-string\x22\x3e\x22img\x22\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码检查\x3ccode\x3equerySelectorAll\x3c\/code\x3e是否定义在\x3ccode\x3edocument\x3c\/code\x3e中，如果是，则使用这个方法。尽管不是最理想的方法，如果想在 IE 8 及更早浏览器中检测 DOM 方法是否存在，这是最安全的做法。在其他所有的情形中，\x3ccode\x3etypeof\x3c\/code\x3e运算符是检测 JavaScript 函数的最佳选择。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e检测数组\x3c\/h3\x3e\n\x3cp\x3eJavaScript 中最古老的跨域问题之一就是在帧（frame）之间来回传递数组。开发者很快发现\x3ccode\x3einstanceof Array\x3c\/code\x3e在此场景中不能返回正确的结果。正如上文提到的，每个帧都有各自的\x3ccode\x3eArray\x3c\/code\x3e构造函数，因此一个帧中的实例在另外一个帧里不会被识别。\x3c\/p\x3e\n\x3cp\x3e关于如何在 JavaScript 中检测数组类型已经有狠多研究了，最终 Kangax 给出了一种优雅的解决方案：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isArray(value) {\n    return Object.prototype.toString.call(value) === \x26quot;[object Array]\x26quot;;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisArray\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.toString.call(value) === \x3cspan class=\x22hljs-string\x22\x3e\x22[object Array]\x22\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eKangax 发现调用某个值的内置\x3ccode\x3etoString()\x3c\/code\x3e方法在所有浏览器中都会返回标准的字符串结果。对于数组来说，返回的字符串为\x3ccode\x3e\x22[object Array]\x22\x3c\/code\x3e，也不用考虑数组实例实在哪个帧（frame）中被构造出来的。这种方法在识别内置对象时往往十分有用，但对于自定义对象请不要用这种方法。\x3c\/p\x3e\n\x3cp\x3eECMAScript5 将\x3ccode\x3eArray.isArray()\x3c\/code\x3e正式引入 JavaScript。唯一的目的就是准确地检测一个值是否为数组。同 Kangax 的函数一样，\x3ccode\x3eArray.isArray()\x3c\/code\x3e也可以检测跨帧（frame）传递的值，因此很多 JavaScript 类库目前都类似地实现了这个方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isArray(value) {\n    if (typeof Array.isArray === \x26quot;function\x26quot;) {\n        return Array.isArray(value);\n    } else {\n        return Object.prototype.toString.call(value) === \x26quot;[object Array]\x26quot;;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisArray\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.toString.call(value) === \x3cspan class=\x22hljs-string\x22\x3e\x22[object Array]\x22\x3c\/span\x3e;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3eIE 9\x2b、FireFox 4\x2b、Safari 5\x2b、Opera 10.5\x2b、Chrome 都实现了\x3ccode\x3eArray.isArray()\x3c\/code\x3e方法。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e检测属性\x3c\/h2\x3e\n\x3cp\x3e另外一种用到\x3ccode\x3enull\x3c\/code\x3e（以及\x3ccode\x3eundefined\x3c\/code\x3e）的场景是当检测一个属性是否在对象中存在时，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 不好的写法：检测假值\nif (object[propertyName]) {\n    \/\/ 一些代码\n}\n\n\/\/ 不好的写法：和null相比较\nif (object[propertyName] != null) {\n    \/\/ 一些代码\n}\n\n\/\/ 不好的写法：和undefined相比较\nif (object[propertyName] != undefined) {\n    \/\/ 一些代码\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不好的写法：检测假值\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (object[propertyName]) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一些代码\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不好的写法：和null相比较\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (object[propertyName] != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一些代码\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不好的写法：和undefined相比较\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (object[propertyName] != \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一些代码\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这段代码里的每个判断，实际上是通过给定的名字来检查属性的值，而并非判断给定的名字所指的属性是否存在。在第一个判断中，当属性值为假值时结果会出错，比如：\x3ccode\x3e0\x3c\/code\x3e、\x3ccode\x3e\x22\x22（空字符串）\x3c\/code\x3e、\x3ccode\x3efalse\x3c\/code\x3e、\x3ccode\x3enull\x3c\/code\x3e和\x3ccode\x3eundefined\x3c\/code\x3e，毕竟这些都是属性的合法值。\x3c\/p\x3e\n\x3cp\x3e判断属性是否存在的最好的方法是使用\x3ccode\x3ein\x3c\/code\x3e运算符。\x3ccode\x3ein\x3c\/code\x3e运算符仅仅会简单地判断属性是否存在，而不去读属性的值，如果实例对象的属性存在、或者继承自对象的原型，\x3ccode\x3ein\x3c\/code\x3e运算符都会返回\x3ccode\x3etrue\x3c\/code\x3e。比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var object = {\n    count: 0,\n    related: null\n};\n\n\/\/ 好的写法\nif (\x26quot;count\x26quot; in object) {\n    \/\/ 这里的代码会执行\n}\n\n\/\/ 不好的写法：检测假值\nif (object[\x26quot;count\x26quot;]) {\n    \/\/ 这里的代码不会执行\n}\n\n\/\/ 好的写法\nif (\x26quot;related\x26quot; in object) {\n    \/\/ 这里的代码会执行\n}\n\n\/\/ 不好的写法，检测是否为\nif (object[\x26quot;related\x26quot;] != null) {\n    \/\/ 这里的代码不会执行\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e object = {\n    \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3erelated\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 好的写法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22count\x22\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e object) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的代码会执行\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不好的写法：检测假值\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (object[\x3cspan class=\x22hljs-string\x22\x3e\x22count\x22\x3c\/span\x3e]) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的代码不会执行\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 好的写法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22related\x22\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e object) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的代码会执行\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不好的写法，检测是否为\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (object[\x3cspan class=\x22hljs-string\x22\x3e\x22related\x22\x3c\/span\x3e] != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的代码不会执行\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你只想检查实例对象的某个属性是否存在，则使用\x3ccode\x3ehasOwnProperty()\x3c\/code\x3e方法。所有继承自\x3ccode\x3eObject\x3c\/code\x3e的 JavaScript 对象都有这个方法，如果实例中存在这个属性则返回\x3ccode\x3etrue\x3c\/code\x3e（如果这个属性只存在于原型里，则返回\x3ccode\x3efalse\x3c\/code\x3e）。需要注意的是，在 IE 8 以及更早版本的 IE 中，DOM 对象并非继承自 Object，因此也不包含这个方法。也就是说，你在调用 DOM 对象的\x3ccode\x3ehasOwnProperty()\x3c\/code\x3e方法之前应当先检测其是否存在。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 对于所有非 DOM 对象来说，这是好的写法\nif (object.hasOwnProperty(\x26quot;related\x26quot;)) {\n    \/\/ 执行这里的代码会\n}\n\n\/\/ 如果你不确定是否为 DOM 对象，则这样来写\nif (\x26quot;hasOwnProperty\x26quot; in object \x26amp;\x26amp; object.hasOwnProperty(\x26quot;related\x26quot;)) {\n    \/\/ 执行这里的代码会\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对于所有非 DOM 对象来说，这是好的写法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (object.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x22related\x22\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行这里的代码会\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果你不确定是否为 DOM 对象，则这样来写\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22hasOwnProperty\x22\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e object \x26amp;\x26amp; object.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x22related\x22\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行这里的代码会\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为存在 IE 8 以及更早版本的 IE 的情形，在判断实例对象的属性是否存在时，我更倾向于使用\x3ccode\x3ein\x3c\/code\x3e运算符，只有在需要判断实例属性时才会用到\x3ccode\x3ehasOwnProperty()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e不管你什么时候需要检测属性的存在性，请使用\x3ccode\x3ein\x3c\/code\x3e运算符或者\x3ccode\x3ehasOwnProperty()\x3c\/code\x3e。这样做可以避免很多 bug。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e扩展阅读\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/book.douban.com\/subject\/21792530\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《编写可维护的JavaScript》\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/book.douban.com\/subject\/10549733\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《JavaScript权威指南(第6版)》\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/book.douban.com\/subject\/10546125\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《JavaScript高级程序设计(第3版)》\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e欢迎来到 \x3ca href=\x22http:\/\/shijiajie.com\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e石佳劼的博客\x3c\/a\x3e，如有疑问，请在\x3ca href=\x22http:\/\/shijiajie.com\/2016\/06\/20\/javascript-maintainable-javascript-validate1\/#ds-thread\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e「原文」评论区\x3c\/a\x3e 留言，我会尽量为您解答。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/7xkhp9.com1.z0.glb.clouddn.com\/blog\/other\/blog_statement_20160618_01.png?imageView2\/2\/w\/650\/interlace\/1\/q\/100\x22 src=\x22https:\/\/static.alili.techhttp:\/\/7xkhp9.com1.z0.glb.clouddn.com\/blog\/other\/blog_statement_20160618_01.png?imageView2\/2\/w\/650\/interlace\/1\/q\/100\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript检测原始值、引用值、属性</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005755082">https://segmentfault.com/a/1190000005755082</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/g41h7crm6v5/" target="_blank">https://alili.tech/archive/g41h7crm6v5/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>