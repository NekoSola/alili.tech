<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 组件性能优化"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 组件性能优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bcpy0n0sq0b/",
				"appid": "1613049289050283", 
				"title": "React 组件性能优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-04T02:30:58"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jjiiiwk33f/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hwwqrkrspyq/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbcpy0n0sq0b%2f&text=React%20%e7%bb%84%e4%bb%b6%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbcpy0n0sq0b%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbcpy0n0sq0b%2f&text=React%20%e7%bb%84%e4%bb%b6%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbcpy0n0sq0b%2f&title=React%20%e7%bb%84%e4%bb%b6%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbcpy0n0sq0b%2f&is_video=false&description=React%20%e7%bb%84%e4%bb%b6%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e7%bb%84%e4%bb%b6%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbcpy0n0sq0b%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbcpy0n0sq0b%2f&title=React%20%e7%bb%84%e4%bb%b6%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbcpy0n0sq0b%2f&title=React%20%e7%bb%84%e4%bb%b6%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbcpy0n0sq0b%2f&title=React%20%e7%bb%84%e4%bb%b6%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbcpy0n0sq0b%2f&title=React%20%e7%bb%84%e4%bb%b6%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 组件性能优化</h1><div class="meta"><div class="postdate"><time datetime="2019-02-04" itemprop="datePublished">2019-02-04</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3eReact组件性能优化\x3c\/h1\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e前言\x3c\/h3\x3e\n\x3cp\x3e众所周知，浏览器的\x3ccode\x3e重绘和重排版(reflows \x26amp; repaints)\x3c\/code\x3e（DOM操作都会引起）才是导致网页性能问题的关键。而React\x3ccode\x3e虚拟DOM\x3c\/code\x3e的目的就是为了减少浏览器的\x3ccode\x3e重绘和重排版\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e说到React优化问题，就必须提下\x3ccode\x3e虚拟DOM\x3c\/code\x3e。\x3ccode\x3e虚拟DOM\x3c\/code\x3e是React核心，通过高新的比较算法，实现了对界面上真正变化的部分进行实际的DOM操作（只是说在大部分场景下这种方式更加效率，而不是一定就是最效率的）。虽然\x3ccode\x3e虚拟DOM\x3c\/code\x3e很牛逼（实际开发中我们根本无需关系其是如何运行的），但是也有缺点。如当React组件如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cComponents\x3e\n  \x3cComponents-1 \/\x3e\n  \x3cComponents-2 \/\x3e\n  \x3cComponents-3 \/\x3e\n\x3c\/Components\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs apache\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-section\x22\x3e\x26lt;Components\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-section\x22\x3e\x26lt;Components-1 \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-section\x22\x3e\x26lt;Components-2 \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-section\x22\x3e\x26lt;Components-3 \/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-section\x22\x3e\x26lt;\/Components\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e数据变化从\x3ccode\x3eComponents-\x26gt;Components-1\x3c\/code\x3e传递下来，React不会只重渲染\x3ccode\x3eComponents-1\x3c\/code\x3e和其父组件，React会以变化（props和state的变化）的最上层的组件为准生成对比的\x3ccode\x3e虚拟DOM\x3c\/code\x3e，就导致了组件没必要的重渲染（即组件render方法的运行）。下面的3张图是借用网上的，是对上面组件更新的图表说明。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e更新绿色点组件（从根组件传递下来应用在绿色组件上的数据发生改变）\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006762530\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006762530\x22 alt=\x22react 组件渲染 更新子组件\x22 title=\x22react 组件渲染 更新子组件\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e理想状态我们想只更新绿色点的组件\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006741744\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006741744\x22 alt=\x22react 组件渲染 理想渲染\x22 title=\x22react 组件渲染 理想渲染\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e实际图中的组件都会重渲染（黄色的点是不必要的渲染，优化的方向）\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006741747\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006741747\x22 alt=\x22react 组件渲染 实际渲染\x22 title=\x22react 组件渲染 实际渲染\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eReact开发团队也考虑到这个问题，为我们提供了一个组件函数处理数据量大的性能问题，\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e，这个方法是我们的性能优化切入点。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e虚拟DOM\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3e虚拟DOM\x3c\/code\x3e其实就是一个 JavaScript 对象。 React 使用\x3ccode\x3e虚拟DOM\x3c\/code\x3e来渲染 UI，当组件状态有更改的时候，React 会自动调用组件的\x26nbsp;\x3ccode\x3erender\x3c\/code\x3e\x26nbsp;方法重新渲染整个组件的 UI。\x3c\/p\x3e\n\x3cp\x3e当然如果真的这样大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个\x3cem\x3e虚拟 DOM\x3c\/em\x3e，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 diff 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e组件渲染方式\x3c\/h3\x3e\n\x3cp\x3e组件渲染方式有两种\x3ccode\x3e初始渲染\x3c\/code\x3e和\x3ccode\x3e更新渲染\x3c\/code\x3e，而我们需要优化的地方就是更新渲染。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e优化关键\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3cp\x3e组件更新生命周期中必调用\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e，字面意思是\x3cstrong\x3e组件是否应该更新\x3c\/strong\x3e。\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e默认返回\x3ccode\x3etrue\x3c\/code\x3e，必更新。所有当我们判断出组件没必要更新是，\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e可以返回\x3ccode\x3efalse\x3c\/code\x3e，就达到优化效果。那如何编写判断代码呢？看下以下几种方式。\x3c\/p\x3e\n\x3ch4\x3e官方PureRenderMixin\x3c\/h4\x3e\n\x3cp\x3eReact 官方提供了 PureRenderMixin 插件，其使用方法如下：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/pure-render-mixin.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方说明\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/官方例子\nimport PureRenderMixin from \x27react-addons-pure-render-mixin\x27;\nclass FooComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  render() {\n    return \x3cdiv className={this.props.className}\x3efoo\x3c\/div\x3e;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/官方例子\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3ePureRenderMixin\x3c\/span\x3e from \x3cspan class=\x22hljs-symbol\x22\x3e\x27react\x3c\/span\x3e-addons-pure-render-mixin\x27;\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFooComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  constructor(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.shouldComponentUpdate = \x3cspan class=\x22hljs-type\x22\x3ePureRenderMixin\x3c\/span\x3e.shouldComponentUpdate.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div className={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.className}\x26gt;foo\x26lt;\/div\x26gt;;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 React 的最新版本里面，提供了 React.PureComponent 的基础类，而不需要使用这个插件。\x3c\/p\x3e\n\x3cp\x3e这个插件其实就是重写了 shouldComponentUpdate 方法，但是这都是最上层对象浅显的比较，没有进行对象深度比较，场景有所限制。那就需要我们自己重写新的PureRenderMixin。\x3c\/p\x3e\n\x3ch4\x3e自定义PureRenderMixin\x3c\/h4\x3e\n\x3cp\x3e以下重写方式是采用ES6，和\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006727526\x22\x3eReact高阶组件写法\x3c\/a\x3e，使用了\x3ccode\x3elodash\x3c\/code\x3e进行深度比较。可以看我在CodePen的例子\x3ca href=\x22http:\/\/codepen.io\/nange\/pen\/PGYBBw\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact组件优化之lodash深度对比\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22nange\/pen\/PGYBBw\/\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import _ from \x27lodash\x27;\n\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n\n  if (typeof objA !== \x27object\x27 || objA === null || typeof objB !== \x27object\x27 || objB === null) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  const bHasOwnProperty = hasOwnProperty.bind(objB);\n  for (let i = 0; i \x3c keysA.length; i\x2b\x2b) {\n    const keyA = keysA[i];\n\n    if (objA[keyA] === objB[keyA]) {\n      continue;\n    }\n\n    \/\/ special diff with Array or Object\n    if (_.isArray(objA[keyA])) {\n      if (!_.isArray(objB[keyA]) || objA[keyA].length !== objB[keyA].length) {\n        return false;\n      } else if (!_.isEqual(objA[keyA], objB[keyA])) {\n        return false;\n      }\n    } else if (_.isPlainObject(objA[keyA])) {\n      if (!_.isPlainObject(objB[keyA]) || !_.isEqual(objA[keyA], objB[keyA])) {\n        return false;\n      }\n    } else if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n\nfunction shallowCompare(instance, nextProps, nextState) {\n  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);\n}\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return shallowCompare(this, nextProps, nextState);\n}\n\/* eslint-disable no-param-reassign *\/\nfunction pureRenderDecorator(component) {\n  \/\/覆盖了component中的shouldComponentUpdate方法\n  component.prototype.shouldComponentUpdate = shouldComponentUpdate;\n  return component;\/\/Decorator不用返回,直接使用高阶组件需要return\n}\n\/*****\n*使用ES6 class 语法糖如下，decorator的没试过，decorator请使用上面的，不要return\n*let pureRenderDecorator = component =\x3e class {\n*  constructor(props) {\n*    super(props);\n*    component.prototype.shouldComponentUpdate = shouldComponentUpdate;\n*  }\n*  render(){\n*    var Component = component;\/\/自定义组件使用时要大写\n*   return (\n*        \x3cComponent {...this.props}\/\x3e\n*    )\n*  }\n*}\n******\/\nexport { shallowEqual };\nexport default pureRenderDecorator;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e _ \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27lodash\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshallowEqual\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobjA, objB\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (objA === objB) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e objA !== \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || objA === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e objB !== \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || objB === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keysA = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(objA);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keysB = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(objB);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (keysA.length !== keysB.length) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bHasOwnProperty = hasOwnProperty.bind(objB);\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; keysA.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keyA = keysA[i];\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (objA[keyA] === objB[keyA]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ special diff with Array or Object\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_.isArray(objA[keyA])) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!_.isArray(objB[keyA]) || objA[keyA].length !== objB[keyA].length) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!_.isEqual(objA[keyA], objB[keyA])) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (_.isPlainObject(objA[keyA])) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!_.isPlainObject(objB[keyA]) || !_.isEqual(objA[keyA], objB[keyA])) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\n\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshallowCompare\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einstance, nextProps, nextState\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshouldComponentUpdate\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextProps, nextState\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e shallowCompare(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, nextProps, nextState);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/* eslint-disable no-param-reassign *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epureRenderDecorator\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecomponent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/覆盖了component中的shouldComponentUpdate方法\x3c\/span\x3e\n  component.prototype.shouldComponentUpdate = shouldComponentUpdate;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e component;\x3cspan class=\x22hljs-comment\x22\x3e\/\/Decorator不用返回,直接使用高阶组件需要return\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/*****\n*使用ES6 class 语法糖如下，decorator的没试过，decorator请使用上面的，不要return\n*let pureRenderDecorator = component =\x26gt; class {\n*  constructor(props) {\n*    super(props);\n*    component.prototype.shouldComponentUpdate = shouldComponentUpdate;\n*  }\n*  render(){\n*    var Component = component;\/\/自定义组件使用时要大写\n*   return (\n*        \x26lt;Component {...this.props}\/\x26gt;\n*    )\n*  }\n*}\n******\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e { shallowEqual };\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e pureRenderDecorator;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方式可以确保props和state数无变化的情况下，不重新渲染组件。但是进行了对象深度比较，是比较不划算的。这点Facebook也是有考虑的，所以就有了\x3ccode\x3eimmutable-js\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch4\x3eimmutable-js\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eimmutable-js\x3c\/code\x3e这里就不详说，这里贴一下React组件优化代码，重写\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { is } from \x27immutable\x27\n...\/\/省略代码\nshouldComponentUpdate(nextProps = {}, nextState = {}){\n  const thisProps = this.props || {},\n  thisState = this.state || {};\n\n  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||\n    Object.keys(thisState).length !== Object.keys(nextState).length) {\n    return true;\n  }\n\n  for (const key in nextProps) {\n    if (thisProps[key] !== nextProps[key] || !is(thisProps[key], nextProps[key])) {\n      \/\/console.debug(thisProps[key],nextProps[key])\n      return true;\n    }\n  }\n\n  for (const key in nextState) {\n    if (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) {\n      return true;\n    }\n  }\n  return false;\n}\n...\/\/省略代码\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { is } from \x3cspan class=\x22hljs-string\x22\x3e\x27immutable\x27\x3c\/span\x3e\n...\x3cspan class=\x22hljs-comment\x22\x3e\/\/省略代码\x3c\/span\x3e\nshouldComponentUpdate(nextProps = {}, nextState = {}){\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e thisProps = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props || {},\n  thisState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state || {};\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e.keys(thisProps).length !== \x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e.keys(nextProps).length ||\n    \x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e.keys(thisState).length !== \x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e.keys(nextState).length) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e in nextProps) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (thisProps[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e] !== nextProps[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e] || !is(thisProps[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e], nextProps[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e])) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/console.debug(thisProps[key],nextProps[key])\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e;\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e in nextState) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (thisState[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e] !== nextState[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e] || !is(thisState[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e], nextState[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e])) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e;\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e;\n}\n...\x3cspan class=\x22hljs-comment\x22\x3e\/\/省略代码\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里面的处理前提是要使用immutable-js对象，上面的代码不是100%适合所有场景（如果全部的props和states都是immutable对象，这个是没问题的），当props中有函数对象（原生的）时，这个就会失效，需要做些而外处理。\x3c\/p\x3e\n\x3cp\x3e对于 \x3ccode\x3eMutable\x3c\/code\x3e 的对象（原生的js对象就是Mutable的）的低效率操作主要体现在\x26nbsp;\x3cstrong\x3e复制\x26nbsp;\x3c\/strong\x3e和\x26nbsp;\x3cstrong\x3e比较\x26nbsp;\x3c\/strong\x3e上，而 \x3ccode\x3eImmutable \x3c\/code\x3e对象就是解决了这两大低效的痛点。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eimmutable-js\x3c\/code\x3e的比较是比\x3ccode\x3elodash\x3c\/code\x3e深度对象比较是更有效率的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e总结\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eimmutable-js\x3c\/code\x3e的思想其实是跟React的\x3ccode\x3e虚拟DOM\x3c\/code\x3e是一致的，都是为了减少不必要的消耗，提高性能。\x3ccode\x3e虚拟DOM\x3c\/code\x3e内部处理比较复杂，而且可能还会带有一些开发人员的副作用（render中运行了一些耗时的程序）,算法比较完后会相对耗时。而 \x3ccode\x3eimmutable-js\x3c\/code\x3e和\x3ccode\x3elodash\x3c\/code\x3e只是纯净的比较数据，效率是相对比较高的，是目前比较适合使用的\x3ccode\x3ePureRender\x3c\/code\x3e方式。建议采用\x3ccode\x3eimmutable-js\x3c\/code\x3e，也可以根据项目性质决定。（ps：持续更新欢迎指正）\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e参考文章\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/imweb.io\/topic\/577512fe732b4107576230b9\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact组件性能优化探索实践\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.alloyteam.com\/2015\/10\/react-virtual-analysis-of-the-dom\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact虚拟DOM浅析\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/ju.outofmemory.cn\/entry\/255112\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eImmutable 在 JavaScript 中的应用\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.stubbornella.org\/content\/2009\/03\/27\/reflows-repaints-css-performance-making-your-javascript-slow\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eREFLOWS \x26amp; REPAINTS:\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 组件性能优化</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006741741">https://segmentfault.com/a/1190000006741741</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/bcpy0n0sq0b/" target="_blank">https://alili.tech/archive/bcpy0n0sq0b/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>