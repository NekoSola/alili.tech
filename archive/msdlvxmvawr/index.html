<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="[译] V8 使用者文档"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>[译] V8 使用者文档 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/msdlvxmvawr/",
				"appid": "1613049289050283", 
				"title": "[译] V8 使用者文档 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-09T02:30:58"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/gm74pqyyg3h/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/dsev9nv5neo/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmsdlvxmvawr%2f&text=%5b%e8%af%91%5d%20V8%20%e4%bd%bf%e7%94%a8%e8%80%85%e6%96%87%e6%a1%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmsdlvxmvawr%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmsdlvxmvawr%2f&text=%5b%e8%af%91%5d%20V8%20%e4%bd%bf%e7%94%a8%e8%80%85%e6%96%87%e6%a1%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmsdlvxmvawr%2f&title=%5b%e8%af%91%5d%20V8%20%e4%bd%bf%e7%94%a8%e8%80%85%e6%96%87%e6%a1%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmsdlvxmvawr%2f&is_video=false&description=%5b%e8%af%91%5d%20V8%20%e4%bd%bf%e7%94%a8%e8%80%85%e6%96%87%e6%a1%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%5b%e8%af%91%5d%20V8%20%e4%bd%bf%e7%94%a8%e8%80%85%e6%96%87%e6%a1%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmsdlvxmvawr%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmsdlvxmvawr%2f&title=%5b%e8%af%91%5d%20V8%20%e4%bd%bf%e7%94%a8%e8%80%85%e6%96%87%e6%a1%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmsdlvxmvawr%2f&title=%5b%e8%af%91%5d%20V8%20%e4%bd%bf%e7%94%a8%e8%80%85%e6%96%87%e6%a1%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmsdlvxmvawr%2f&title=%5b%e8%af%91%5d%20V8%20%e4%bd%bf%e7%94%a8%e8%80%85%e6%96%87%e6%a1%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmsdlvxmvawr%2f&title=%5b%e8%af%91%5d%20V8%20%e4%bd%bf%e7%94%a8%e8%80%85%e6%96%87%e6%a1%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">[译] V8 使用者文档</h1><div class="meta"><div class="postdate"><time datetime="2019-02-09" itemprop="datePublished">2019-02-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e如果你已经阅读过了\x3ca href=\x22https:\/\/developers.google.com\/v8\/get_started\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e上手指南\x3c\/a\x3e，那么你已经知道了如何作为一个单独的虚拟机使用 V8 ，并且熟悉了一些 V8 中的关键概念，如\x3cstrong\x3e句柄\x3c\/strong\x3e，\x3cstrong\x3e域\x3c\/strong\x3e 和\x3cstrong\x3e上下文\x3c\/strong\x3e。在本文档中，还将继续深入讨论这些概念并且介绍其他一些在你的 C\x2b\x2b 应用中使用 V8 的关键点。\x3c\/p\x3e\n\x3cp\x3eV8 的 API 提供了编译和执行脚本，访问 C\x2b\x2b 方法和数据结构，处理错误和启用安全检查的函数。你的应用可以像使用其他的 C\x2b\x2b 库一样使用 V8 。你的 C\x2b\x2b 应用可以通过引入头文件 \x3ccode\x3einclude\/v8.h\x3c\/code\x3e 来访问 V8 API 。\x3c\/p\x3e\n\x3cp\x3e当你想要优化你的应用时，\x3ca href=\x22https:\/\/developers.google.com\/v8\/design\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eV8 设计概要文档\x3c\/a\x3e可以提供很多有用的背景知识。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e这篇文档的受众是那些想要在自己的 C\x2b\x2b 程序中使用 V8 JavaScript 引擎的人。它将能帮助你在 JavaScript 中使用你应用中的 C\x2b\x2b 对象和方法，亦能帮助你在 C\x2b\x2b 应用中使用 JavaScript 对象和方法。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e句柄和垃圾回收\x3c\/h2\x3e\n\x3cp\x3e一个句柄提供了对在堆中的一个 JavaScript 对象地址的引用。V8 的垃圾回收器会在该对象不能再次被访问到时，将其回收。在垃圾回收的过程中，垃圾回收器可能会改变对象在堆中的位置。当垃圾回收器移动对象时，所有引用到该对象的句柄也会被一同更新。\x3c\/p\x3e\n\x3cp\x3e当一个对象在 JavaScript 中已经不可被访问并且没有任何指向它的句柄时，它就会被垃圾回收。V8 的垃圾回收机制是 V8 性能表现的关键。更多信息可参阅 \x3ca href=\x22https:\/\/developers.google.com\/v8\/design\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eV8 设计概要文档\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e句柄分为许多种：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3cstrong\x3e本地句柄\x3c\/strong\x3e会被分配在栈中，并且当对应的析构函数被调用时，它也会被删除。这些本地句柄的生命周期取决于它对应的句柄域（handle scope），句柄域通常在一个函数调用的开始被创建。当句柄域被删除时，垃圾回收器就可以清除之前分配在该句柄域中的所有句柄了，因为它们不能再被 JavaScript 或其他句柄所访问到。这也正是在\x3ca href=\x22https:\/\/developers.google.com\/v8\/get_started\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e上手指南\x3c\/a\x3e中使用的句柄。\x3cbr\x3e本地句柄可通过类 \x3ccode\x3eLocal\x26lt;SomeType\x26gt;\x3c\/code\x3e 创建。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e注意：句柄栈并不是 C\x2b\x2b 调用栈中的一部分，但句柄域却在 C\x2b\x2b 栈中。故句柄域不可通过 \x3ccode\x3enew\x3c\/code\x3e 关键字来分配。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e持久句柄\x3c\/strong\x3e提供了对分配在堆中的 JavaScript 对象的引用。当你需要在超过一次函数中保持对一个对象的引用时，或者句柄的生命周期与 C\x2b\x2b 的块级域不相符时，你应使用持久句柄。例如，在 Google Chrome 中，持久句柄被用来引用 DOM 节点。一个持久句柄可以通过 \x3ccode\x3ePersistentBase::SetWeak\x3c\/code\x3e ，变为弱（weak）持久句柄，当一个对象所剩的唯一引用是来自于一个弱持久句柄时，便会触发垃圾回收。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e一个 \x3ccode\x3eUniquePersistent\x26lt;SomeType\x26gt;\x3c\/code\x3e 依赖于 C\x2b\x2b 构造函数和析构函数来管理下层对象的生命周期。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e一个 \x3ccode\x3ePersistent\x26lt;SomeType\x26gt;\x3c\/code\x3e 可以通过自身的构造函数来创建，但必须手动地通过 \x3ccode\x3ePersistent::Reset\x3c\/code\x3e 来清除。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e还有两种很少会被使用到的句柄，在这里我们仅对它们做一个简单的介绍：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e永久（Eternal）句柄是一种为被认为永远不会被删除的 JavaScript 对象所设计的持久句柄。它的创建开销更低，因为它不需要被垃圾回收。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ePersistent\x26lt;SomeType\x26gt;\x3c\/code\x3e 和 \x3ccode\x3eUniquePersistent\x26lt;SomeType\x26gt;\x3c\/code\x3e 都不能被复制，所以它们不能作为 C\x2b\x2b 11 之前的标准库容器中的值来使用。\x3ccode\x3ePersistentValueMap\x3c\/code\x3e 和 \x3ccode\x3ePersistentValueVector\x3c\/code\x3e 为它们提供了容器类，提供了类似于集合和向量的语义。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e当然，每当你为了创建一个对象而创建一个本地句柄时，往往可能会导致创建了许多句柄。这就是句柄域所存在的意义。你可以将句柄域视作一个保存了许多句柄的容器。当句柄域的析构函数被调用时，所有它里面的句柄都会被从栈中移除。正如你所期望的，这些句柄做指向的对象随后就可以被垃圾回收。\x3c\/p\x3e\n\x3cp\x3e回到我们在\x3ca href=\x22https:\/\/developers.google.com\/v8\/get_started\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e上手指南\x3c\/a\x3e中的例子，在下面的图示中，你可以看到句柄栈和堆中的对象。值得注意的是，\x3ccode\x3eContext::New()\x3c\/code\x3e 的返回值是一个本地句柄，然后我们基于它创建了一个新的持久句柄，用以阐述持久句柄的用途。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006767163\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006767163\x22 alt=\x22local_persist_handles_review.png\x22 title=\x22local_persist_handles_review.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e当 \x3ccode\x3eHandleScope::~HandleScope\x3c\/code\x3e 析构函数被调用时，该句柄域便会被删除。所有被句柄域中的句柄所引用的对象，都将可以在下次垃圾回收时被删除，如果没有其他对于它们的引用存在。垃圾回收器同样还会删除堆中的 \x3ccode\x3esource_obj\x3c\/code\x3e 和 \x3ccode\x3escript_obj\x3c\/code\x3e 对象，因为它们不被任何句柄所引用，并且也不可被 JavaScript 访问。由于 \x3ccode\x3econtext\x3c\/code\x3e 对象是一个持久句柄，所以当句柄域退出时，它并不会被移除，唯一可以删除它的办法就是调用它的 \x3ccode\x3eReset\x3c\/code\x3e 方法。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注意：后文中的句柄如果不加注明，都指的是本地句柄。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e在这个模型下，有一个非常常见的陷阱需要注意：你不可以直接地在一个声明了句柄域的函数中返回一个本地句柄。如果你这么做了，那么你试图返回的本地句柄，将会在函数返回之前，在句柄域的析构函数中被删除。正确的做法是使用 \x3ccode\x3eEscapableHandleScope\x3c\/code\x3e 来代替 \x3ccode\x3eHandleScope\x3c\/code\x3e 创建句柄域，然后调用 \x3ccode\x3eEscape\x3c\/code\x3e 方法，并且传入你想要返回的句柄。例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这个函数会返回一个带有 x，y 和 z 三个元素的新数组\nLocal\x3cArray\x3e NewPointArray(int x, int y, int z) {\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n\n  \/\/ 我们将会创建一些临时的句柄，所以我们先创建一个句柄域\n  EscapableHandleScope handle_scope(isolate);\n\n  \/\/ 创建一个空数组\n  Local\x3cArray\x3e array = Array::New(isolate, 3);\n\n  \/\/ 如果在创建数组时产生异常，则返回一个空数组\n  if (array.IsEmpty())\n    return Local\x3cArray\x3e();\n\n  \/\/ 填充数组\n  array-\x3eSet(0, Integer::New(isolate, x));\n  array-\x3eSet(1, Integer::New(isolate, y));\n  array-\x3eSet(2, Integer::New(isolate, z));\n\n  \/\/ 通过 Escape 返回该数组\n  return handle_scope.Escape(array);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个函数会返回一个带有 x，y 和 z 三个元素的新数组\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26gt; NewPointArray(int x, int y, int z) {\n  v8\x3cspan class=\x22hljs-type\x22\x3e::Isolate\x3c\/span\x3e* isolate = v8\x3cspan class=\x22hljs-type\x22\x3e::Isolate\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::GetCurrent\x3c\/span\x3e();\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 我们将会创建一些临时的句柄，所以我们先创建一个句柄域\x3c\/span\x3e\n  EscapableHandleScope handle_scope(isolate);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个空数组\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果在创建数组时产生异常，则返回一个空数组\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.IsEmpty())\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26gt;();\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 填充数组\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e-\x26gt;\x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eInteger\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate, x));\n  \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e-\x26gt;\x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eInteger\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate, y));\n  \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e-\x26gt;\x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eInteger\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate, z));\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 Escape 返回该数组\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e handle_scope.Escape(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eEscape\x3c\/code\x3e 方法复制参数中的值至一个封闭的域中，然后删除其他本地句柄，最后返回这个可以被安全返回的新句柄副本。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e上下文\x3c\/h2\x3e\n\x3cp\x3e在 V8 中，上下文是一个允许多个分别独立的，不相关的 JavaScript 应用在一个单独的 V8 实例中运行的执行环境。你必须为每一个你想要执行的 JavaScript 代码指定一个上下文。\x3c\/p\x3e\n\x3cp\x3e这样做是必要的么？这么做的原因是，JavaScript 本身提供了一组内建的工具函数和对象，但它们又可以被 JavaScript 代码所修改。例如，两个完全没有关联的 JavaScript 函数同时修改了一个全局对象，那么可能就会造成不可预期的后果。\x3c\/p\x3e\n\x3cp\x3e从 CPU 时间和内存的角度来看，创建一个拥有指定数量的内建对象的执行上下文似乎开销很大。但是，V8 的缓存机制可以确保，虽然创建的第一个上下文开销非常大，但后续的上下文创建的开销都会小很多。这是因为第一次创建上下文时，需要创建内建对象和解析内建的 JavaScript 代码，而后续的上下文创建则只需为它们的上下文创建内建对象即可。如果开启了 V8 的快照特性（可通过选项 \x3ccode\x3esnapshot=yes\x3c\/code\x3e 开启，默认值即为开启），第一次创建上下文的时间花销也会被极大的优化，因为快照中包含了这些所需的内建 JavaScript 代码已然被编译后的版本。除了垃圾回收外，V8 的缓存也是 V8 性能表现的关键，更多详情可参阅\x3ca href=\x22https:\/\/developers.google.com\/v8\/design\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eV8 设计概要文档\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e当你创建了一个上下文后，你可以随意地进入和离开它，没有次数的限制。当你已经在上下文 A 中时，你还可以再次进入另一个上下文 B ，这以为着当前的上下文环境变成了 B 。当你离开了 B 后，A 就再次成为了当前上下文。如图示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000005684493\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000005684493\x22 alt=\x22intro_contexts.png\x22 title=\x22intro_contexts.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e需要注意的是，JavaScript 内建工具函数和对象是相互独立的。当你创建一个上下文时，你可以同时设置可选的安全标识（security token）。更多详情请参阅下文的\x3cstrong\x3e安全模型\x3c\/strong\x3e章节。\x3c\/p\x3e\n\x3cp\x3e在 V8 中使用上下文的最初动机是，在一个浏览器中，每一个窗口和 iframe 都需要有各自独立的 JavaScript 环境。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e模板\x3c\/h2\x3e\n\x3cp\x3e一个模板即为一个上下文中 JavaScript 函数和对象的蓝图。你可以在 JavaScript 对象内使用一个模板来包裹 C\x2b\x2b 函数和数据结构，致使它们可以被 JavaScript 脚本所操纵。例如，Google Chrome 使用模板来将 C\x2b\x2b DOM 节点包裹为 JavaScript 对象，然后在全局命名空间下注册函数。你可以创建一个模板集合，然后在不同的上下文中使用它。模板的数量并没有限制，但是在一个指定的上下文中，每一个模板都只允许有一个它的实例。\x3c\/p\x3e\n\x3cp\x3e在 JavaScript 中，函数和对象间有强烈的二元性。在 Java 或 C\x2b\x2b 中，如果要创建一个新类型的对象，你需要首先定义一个新的类。而在 JavaScript 中，你需要定义一个新的函数，然后把这个函数视作一个构造函数。一个 JavaScript 对象的外形和功能都与它的构造函数关系密切。这些也都反应在了 V8 模板的工作方式中。模板分为两种类型：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e函数模板\x3cbr\x3e一个函数模板就是一个独立函数的蓝图。在一个你想要实例化 JavaScript 函数的上下文中，你可以通过调用模板的 \x3ccode\x3eGetFunction\x3c\/code\x3e 方法来创建一个模板的 JavaScript 实例。当 JavaScript 函数实例被调用时，你还可以为模板关联一个 C\x2b\x2b 回调函数一同被调用。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e对象模板\x3cbr\x3e每一个函数模板都有一个与之关联的对象模板。对象模板用来配置将这个函数作为构造函数而创建的对象。你可以为对象模板关联两种类型的 C\x2b\x2b 回调：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e访问器\x3c\/strong\x3e回调会在指定对象原型被脚本访问时被调用。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e拦截器\x3c\/strong\x3e回调会在任何对象原型被脚本访问时被调用。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e访问器和拦截器的详情会在后文中继续讨论。\x3c\/p\x3e\n\x3cp\x3e下面的例子中，我们将创建一个关联全局对象的模板，然后设置一些内建的全局函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建一个关联全局对象的模板，然后设置一些内建的全局函数。\nLocal\x3cObjectTemplate\x3e global = ObjectTemplate::New(isolate);\nglobal-\x3eSet(String::NewFromUtf8(isolate, \x26quot;log\x26quot;), FunctionTemplate::New(isolate, LogCallback));\n\nPersistent\x3cContext\x3e context = Context::New(isolate, NULL, global);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个关联全局对象的模板，然后设置一些内建的全局函数。\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;ObjectTemplate\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3eglobal\x3c\/span\x3e = ObjectTemplate\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate);\n\x3cspan class=\x22hljs-built_in\x22\x3eglobal\x3c\/span\x3e-\x26gt;\x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::NewFromUtf8\x3c\/span\x3e(isolate, \x3cspan class=\x22hljs-string\x22\x3e\x22log\x22\x3c\/span\x3e), FunctionTemplate\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate, LogCallback));\n\nPersistent\x26lt;Context\x26gt; context = Context\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate, \x3cspan class=\x22hljs-built_in\x22\x3eNULL\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eglobal\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该例子取自于 \x3ccode\x3eprocess.cc\x3c\/code\x3e 中的 \x3ccode\x3eJsHttpProcessor::Initialiser\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e访问器\x3c\/h2\x3e\n\x3cp\x3e访问器为当一个 JavaScript 对象原型被脚本访问时，执行的一个 C\x2b\x2b 回调函数，它计算并返回一个值。访问器需要通过一个对象模板来配置，通过它的 \x3ccode\x3eSetAccessor\x3c\/code\x3e 方法。这个方法的第一个参数为关联的属性，最后一个参数为当脚本试图读写这个属性时执行的回调。\x3c\/p\x3e\n\x3cp\x3e访问的复杂度取决于你想要其控制的数据类型：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e访问静态全局变量\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e访问动态变量\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e访问静态全局变量\x3c\/h3\x3e\n\x3cp\x3e假设有两个名为 \x3ccode\x3ex\x3c\/code\x3e 和 \x3ccode\x3ey\x3c\/code\x3e 的 C\x2b\x2b 整形变量，它们需要成为一个上下文的 JavaScript 中的全局变量。为了达成这个目的，当脚本读或写这些变量时，你需要调用 C\x2b\x2b 访问器函数。这些访问器函数使用 \x3ccode\x3eInteger::New\x3c\/code\x3e 来把 C\x2b\x2b 整形数转换为 JavaScript 整形数，并且使用 \x3ccode\x3eInt32Value\x3c\/code\x3e 来把 JavaScript 整形数转换为 C\x2b\x2b 整形数。例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  void XGetter(Local\x3cString\x3e property,\n                const PropertyCallbackInfo\x3cValue\x3e\x26amp; info) {\n    info.GetReturnValue().Set(x);\n  }\n\n  void XSetter(Local\x3cString\x3e property, Local\x3cValue\x3e value,\n               const PropertyCallbackInfo\x3cValue\x3e\x26amp; info) {\n    x = value-\x3eInt32Value();\n  }\n\n  \/\/ YGetter\/YSetter 十分类似，这里就省略了\n\n  Local\x3cObjectTemplate\x3e global_templ = ObjectTemplate::New(isolate);\n  global_templ-\x3eSetAccessor(String::NewFromUtf8(isolate, \x26quot;x\x26quot;), XGetter, XSetter);\n  global_templ-\x3eSetAccessor(String::NewFromUtf8(isolate, \x26quot;y\x26quot;), YGetter, YSetter);\n  Persistent\x3cContext\x3e context = Context::New(isolate, NULL, global_templ);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e  \x3cspan class=\x22hljs-literal\x22\x3evoid\x3c\/span\x3e XGetter(\x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x26gt; property,\n                const PropertyCallbackInfo\x26lt;Value\x26gt;\x26amp; info) {\n    info.GetReturnValue().\x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e(x);\n  }\n\n  \x3cspan class=\x22hljs-literal\x22\x3evoid\x3c\/span\x3e XSetter(\x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x26gt; property, \x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;Value\x26gt; value,\n               const PropertyCallbackInfo\x26lt;Value\x26gt;\x26amp; info) {\n    x = value-\x26gt;Int32Value();\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ YGetter\/YSetter 十分类似，这里就省略了\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;ObjectTemplate\x26gt; global_templ = ObjectTemplate\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate);\n  global_templ-\x26gt;SetAccessor(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::NewFromUtf8\x3c\/span\x3e(isolate, \x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e), XGetter, XSetter);\n  global_templ-\x26gt;SetAccessor(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::NewFromUtf8\x3c\/span\x3e(isolate, \x3cspan class=\x22hljs-string\x22\x3e\x22y\x22\x3c\/span\x3e), YGetter, YSetter);\n  Persistent\x26lt;Context\x26gt; context = Context\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate, \x3cspan class=\x22hljs-built_in\x22\x3eNULL\x3c\/span\x3e, global_templ);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意代码中的对象模板和上下文几乎在同时创建。模板可以提前创建好，然后在任意数量的上下文中使用它。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e访问动态变量\x3c\/h3\x3e\n\x3cp\x3e在上面的例子中，变量是静态和全局的。那么，如果数据是动态的，像浏览器中的 DOM 树这样呢？假设我们有一个 C\x2b\x2b 类 \x3ccode\x3ePoint\x3c\/code\x3e，它有两个属性 \x3ccode\x3ex\x3c\/code\x3e 和 \x3ccode\x3ey\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  class Point {\n   public:\n    Point(int x, int y) : x_(x), y_(y) { }\n    int x_, y_;\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e  \x3cspan class=\x22hljs-selector-tag\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3ePoint\x3c\/span\x3e {\n   \x3cspan class=\x22hljs-attribute\x22\x3epublic\x3c\/span\x3e:\n    \x3cspan class=\x22hljs-built_in\x22\x3ePoint\x3c\/span\x3e(int x, int y) : \x3cspan class=\x22hljs-built_in\x22\x3ex_\x3c\/span\x3e(x), \x3cspan class=\x22hljs-built_in\x22\x3ey_\x3c\/span\x3e(y) { }\n    \x3cspan class=\x22hljs-selector-tag\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3ex_\x3c\/span\x3e, \x3cspan class=\x22hljs-selector-tag\x22\x3ey_\x3c\/span\x3e;\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了让任意数量的 C\x2b\x2b \x3ccode\x3epoint\x3c\/code\x3e 实例可以通过 JavaScript 访问，我们需要为每一个 C\x2b\x2b \x3ccode\x3epoint\x3c\/code\x3e 实例创建一个 JavaScript 对象。这可以通过外部（external）值和内部（internal）属性共同办到。\x3c\/p\x3e\n\x3cp\x3e首先创建一个对象模板，用以包裹 \x3ccode\x3epoint\x3c\/code\x3e 实例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  Local\x3cObjectTemplate\x3e point_templ = ObjectTemplate::New(isolate);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e  Local\x3cspan class=\x22hljs-params\x22\x3e\x26lt;ObjectTemplate\x26gt;\x3c\/span\x3e point_templ = \x3cspan class=\x22hljs-symbol\x22\x3eObjectTemplate::\x3c\/span\x3eNew(isolate);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每一个 JavaScript 中的 \x3ccode\x3epoint\x3c\/code\x3e 对象都保持了对 C\x2b\x2b 对象的引用，因为它以内部属性的方式被包裹。这些属性不可通过 JavaScript 访问，只能通过 C\x2b\x2b 代码访问到。一个对象可以有任意数量的内部属性，这个数量需通过以下方法来设置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  point_templ-\x3eSetInternalFieldCount(1);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xl\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3epoint_templ\x3c\/span\x3e-\x26gt;\x3c\/span\x3eSetInternalFieldCount(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的例子中，内部属性的数量被设置为了 1，表明这对象有一个内部属性，索引值为 0。\x3c\/p\x3e\n\x3cp\x3e向模板添加 \x3ccode\x3ex\x3c\/code\x3e 和 \x3ccode\x3ey\x3c\/code\x3e 访问器：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  point_templ.SetAccessor(String::NewFromUtf8(isolate, \x26quot;x\x26quot;), GetPointX, SetPointX);\n  point_templ.SetAccessor(String::NewFromUtf8(isolate, \x26quot;y\x26quot;), GetPointY, SetPointY);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs julia\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e  point_templ.SetAccessor(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::\x3c\/span\x3eNewFromUtf8(isolate, \x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e), GetPointX, SetPointX);\n  point_templ.SetAccessor(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::\x3c\/span\x3eNewFromUtf8(isolate, \x3cspan class=\x22hljs-string\x22\x3e\x22y\x22\x3c\/span\x3e), GetPointY, SetPointY);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来，我们通过创建一个新的模板实例来包裹 C\x2b\x2b \x3ccode\x3epoint\x3c\/code\x3e 实例，然后将内部属性 \x3ccode\x3e0\x3c\/code\x3e 设置为 \x3ccode\x3ep\x3c\/code\x3e 的外部包裹。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  Point* p = ...;\n  Local\x3cObject\x3e obj = point_templ-\x3eNewInstance();\n  obj-\x3eSetInternalField(0, External::New(isolate, p));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e  Point* p = ...;\n  Local\x26lt;Object\x26gt; obj = point_templ-\x26gt;NewInstance();\n  obj-\x26gt;SetInternalField(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, External::New(isolate, p));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一个外部对象仅被用来在内部属性中存储引用。JavaScript 对象不能直接地引用 C\x2b\x2b 对象，所以外部值就像从 JavaScript 到 C\x2b\x2b 的“一座桥梁”。所以外部值是句柄的相反面，因为句柄的作用是让我们在 C\x2b\x2b 中可以获取 JavaScript 对象的引用。\x3c\/p\x3e\n\x3cp\x3e以下便是 \x3ccode\x3ex\x3c\/code\x3e 的读和写访问器的定义，\x3ccode\x3ey\x3c\/code\x3e 的定义和 \x3ccode\x3ex\x3c\/code\x3e 的十分类似，只需将 \x3ccode\x3ex\x3c\/code\x3e 替换为 \x3ccode\x3ey\x3c\/code\x3e 即可：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  void GetPointX(Local\x3cString\x3e property,\n                 const PropertyCallbackInfo\x3cValue\x3e\x26amp; info) {\n    Local\x3cObject\x3e self = info.Holder();\n    Local\x3cExternal\x3e wrap = Local\x3cExternal\x3e::Cast(self-\x3eGetInternalField(0));\n    void* ptr = wrap-\x3eValue();\n    int value = static_cast\x3cPoint*\x3e(ptr)-\x3ex_;\n    info.GetReturnValue().Set(value);\n  }\n\n  void SetPointX(Local\x3cString\x3e property, Local\x3cValue\x3e value,\n                 const PropertyCallbackInfo\x3cValue\x3e\x26amp; info) {\n    Local\x3cObject\x3e self = info.Holder();\n    Local\x3cExternal\x3e wrap = Local\x3cExternal\x3e::Cast(self-\x3eGetInternalField(0));\n    void* ptr = wrap-\x3eValue();\n    static_cast\x3cPoint*\x3e(ptr)-\x3ex_ = value-\x3eInt32Value();\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGetPointX\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(Local\x26lt;String\x26gt; property,\n                 \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e PropertyCallbackInfo\x26lt;Value\x26gt;\x26amp; info)\x3c\/span\x3e \x3c\/span\x3e{\n    Local\x26lt;Object\x26gt; self = info.Holder();\n    Local\x26lt;External\x26gt; wrap = Local\x26lt;External\x26gt;::Cast(self-\x26gt;GetInternalField(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e* ptr = wrap-\x26gt;Value();\n    \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e value = \x3cspan class=\x22hljs-keyword\x22\x3estatic_cast\x3c\/span\x3e\x26lt;Point*\x26gt;(ptr)-\x26gt;x_;\n    info.GetReturnValue().Set(value);\n  }\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSetPointX\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(Local\x26lt;String\x26gt; property, Local\x26lt;Value\x26gt; value,\n                 \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e PropertyCallbackInfo\x26lt;Value\x26gt;\x26amp; info)\x3c\/span\x3e \x3c\/span\x3e{\n    Local\x26lt;Object\x26gt; self = info.Holder();\n    Local\x26lt;External\x26gt; wrap = Local\x26lt;External\x26gt;::Cast(self-\x26gt;GetInternalField(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e* ptr = wrap-\x26gt;Value();\n    \x3cspan class=\x22hljs-keyword\x22\x3estatic_cast\x3c\/span\x3e\x26lt;Point*\x26gt;(ptr)-\x26gt;x_ = value-\x26gt;Int32Value();\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e访问器抽象了对于 C\x2b\x2b \x3ccode\x3epoint\x3c\/code\x3e 对象的引用和对其的读写操作。这样这些访问器就可以被用于任意数量的被包裹后的 \x3ccode\x3epoint\x3c\/code\x3e 对象中了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e拦截器\x3c\/h2\x3e\n\x3cp\x3e你还可以在一个脚本访问任意对象属性时，设置一个回调函数。这些回调函数称为拦截器。拦截器分为两种类型：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e具名属性拦截器，它会在访问名称为字符串的属性时被调用，如浏览器环境中的 \x3ccode\x3edocument.theFormName.elementName\x3c\/code\x3e 。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e索引属性拦截器，它会在访问索引属性时被调用，如浏览器环境中的 \x3ccode\x3edocument.forms.elements[0]\x3c\/code\x3e 。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eV8 源码中的 \x3ccode\x3eprocess.cc\x3c\/code\x3e 文件中，包含了一个拦截器的使用实例。下面例子中的 \x3ccode\x3eSetNamedPropertyHandler\x3c\/code\x3e 设置了 \x3ccode\x3eMapGet\x3c\/code\x3e 和 \x3ccode\x3eMapSet\x3c\/code\x3e 这两个拦截器：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Local\x3cObjectTemplate\x3e result = ObjectTemplate::New(isolate);\nresult-\x3eSetNamedPropertyHandler(MapGet, MapSet);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3eLocal\x26lt;ObjectTemplate\x26gt; result = ObjectTemplate::New(isolate);\nresult-\x26gt;SetNamedPropertyHandler(MapGet, MapSet);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eMapGet\x3c\/code\x3e 拦截器源码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void JsHttpRequestProcessor::MapGet(Local\x3cString\x3e name,\n                                    const PropertyCallbackInfo\x3cValue\x3e\x26amp; info) {\n  \/\/ Fetch the map wrapped by this object.\n  map\x3cstring, string\x3e *obj = UnwrapMap(info.Holder());\n\n  \/\/ Convert the JavaScript string to a std::string.\n  string key = ObjectToString(name);\n\n  \/\/ Look up the value if it exists using the standard STL idiom.\n  map\x3cstring, string\x3e::iterator iter = obj-\x3efind(key);\n\n  \/\/ If the key is not present return an empty handle as signal.\n  if (iter == obj-\x3eend()) return;\n\n  \/\/ Otherwise fetch the value and wrap it in a JavaScript string.\n  const string \x26amp;value = (*iter).second;\n  info.GetReturnValue().Set(String::NewFromUtf8(value.c_str(), String::kNormalString, value.length()));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e\x3cspan class=\x22hljs-literal\x22\x3evoid\x3c\/span\x3e JsHttpRequestProcessor\x3cspan class=\x22hljs-type\x22\x3e::MapGet\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x26gt; name,\n                                    const PropertyCallbackInfo\x26lt;Value\x26gt;\x26amp; info) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Fetch the map wrapped by this object.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e\x26gt; *obj = UnwrapMap(info.Holder());\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Convert the JavaScript string to a std::string.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e key = ObjectToString(name);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Look up the value if it exists using the standard STL idiom.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e\x26gt;\x3cspan class=\x22hljs-type\x22\x3e::iterator\x3c\/span\x3e iter = obj-\x26gt;find(key);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If the key is not present return an empty handle as signal.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (iter == obj-\x26gt;end()) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Otherwise fetch the value and wrap it in a JavaScript string.\x3c\/span\x3e\n  const \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e \x26amp;value = (*iter).second;\n  info.GetReturnValue().\x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::NewFromUtf8\x3c\/span\x3e(value.c_str(), \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::kNormalString\x3c\/span\x3e, value.length()));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e和访问器一样，特定的回调函数会在一个属性被访问后触发。它和访问器的区别就是，访问器会回调仅会在一个特定的属性被访问时触发，而拦截器回调则会在任意属性被访问时触发。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e安全模型\x3c\/h2\x3e\n\x3cp\x3e“同源策略”（首次出现于网景浏览器 2.0 中），用于阻止从另一个“源”中加载脚本或文档到本地“源”里。这个源的概念中包含了域名（www.example.com），协议（http 或 https）和端口（如 www.example.com:81 和 www.example.com 不同源）。以上部分全部一样，才能被视为同源。如果没了这层保护，许多网页就可以会遭到其他恶意网页的攻击。\x3c\/p\x3e\n\x3cp\x3e在 V8 中，“源”即为上下文。在一个上下文中访问另一个上下文默认是不被允许的。如果一定访问，那么必须使用安全标识（security tokens）或安全回调（security callbacks）。一个安全标识可以是任意类型的值，但通常是一个 \x3ccode\x3esymbol\x3c\/code\x3e 或一个唯一字符串。当你设置一个上下文时，可以通过 \x3ccode\x3eSetSecurityToken\x3c\/code\x3e 可选地设置一个安全标识。如果你没有明确地指明一个安全标识，那么 V8 将会为该上下文自动生成一个。\x3c\/p\x3e\n\x3cp\x3e当试图去访问一个全局变量时，V8 的安全系统首先会去检查被访问的全局变量的上下文的安全标识与访问代码的上下文的安全标识是否一致，若一致，则允许访问。如果安全标识不一致，那么 V8 将会触发一个回调函数来判断这个访问是否该被允许。你可以通过在对象模板的方法 \x3ccode\x3eSetAccessCheckCallbacks\x3c\/code\x3e ，来设置这个安全回调。这个回调的参数为，将会被访问的对象，将会被访问的属性名，和访问的类型（如读，写或删除）并且返回值即表示是否允许这次访问。\x3c\/p\x3e\n\x3cp\x3e在 Google Chrome 中，这套安全机制运用在以下几处：\x3ccode\x3ewindow.focus()\x3c\/code\x3e，\x3ccode\x3ewindow.blur()\x3c\/code\x3e，\x3ccode\x3ewindow.close()\x3c\/code\x3e，\x3ccode\x3ewindow.location\x3c\/code\x3e，\x3ccode\x3ewindow.open()\x3c\/code\x3e，\x3ccode\x3ehistory.forward()\x3c\/code\x3e，\x3ccode\x3ehistory.back()\x3c\/code\x3e 和 \x3ccode\x3ehistory.go()\x3c\/code\x3e 。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e异常\x3c\/h2\x3e\n\x3cp\x3e当一个错误发生时，V8 将会抛出一个异常。例如，当一个脚本或函数试图去读取一个不存在的属性时，或一个非函数对象被调用时。\x3c\/p\x3e\n\x3cp\x3e如果一次操作失败了，V8 将会返回空句柄。因为在进一步操作前，检查返回值是否是空句柄就变得尤为重要。我们可以通过本地句柄类（\x3ccode\x3eLocal\x3c\/code\x3e）的成员函数 \x3ccode\x3eIsEmpty()\x3c\/code\x3e 来进行检查。\x3c\/p\x3e\n\x3cp\x3e你也可以通过 \x3ccode\x3eTryCatch\x3c\/code\x3e 类捕获异常，例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  TryCatch trycatch(isolate);\n  Local\x3cValue\x3e v = script-\x3eRun();\n  if (v.IsEmpty()) {\n    Local\x3cValue\x3e exception = trycatch.Exception();\n    String::Utf8Value exception_str(exception);\n    printf(\x26quot;Exception: %s\\n\x26quot;, *exception_str);\n    \/\/ ...\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e  TryCatch trycatch(isolate);\n  Local\x26lt;Value\x26gt; v = script-\x26gt;Run();\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (v.IsEmpty()) {\n    Local\x26lt;Value\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3eexception\x3c\/span\x3e = trycatch.\x3cspan class=\x22hljs-keyword\x22\x3eException\x3c\/span\x3e();\n    String::Utf8Value exception_str(\x3cspan class=\x22hljs-keyword\x22\x3eexception\x3c\/span\x3e);\n    printf(\x3cspan class=\x22hljs-string\x22\x3e\x22Exception: %s\\n\x22\x3c\/span\x3e, *exception_str);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果返回值是一个空句柄，并且你没有使用 \x3ccode\x3eTryCatch\x3c\/code\x3e ，那么你的代码必须要终止。如果你使用了 \x3ccode\x3eTryCatch\x3c\/code\x3e ，那么你的代码则可以继续执行。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e继承\x3c\/h2\x3e\n\x3cp\x3eJavaScript 是第一个不基于类的面向对象编程语言。它使用了基于原型的继承。这对于一直使用传统面向对象编程语言（如 C\x2b\x2b 和 Java）的程序员来说，可能会有些困惑。\x3c\/p\x3e\n\x3cp\x3e传统的面向对象编程语言（如 C\x2b\x2b 和 Java）通常基于两个概念：类和继承。JavaScript 是一个基于原型的编程语言，所以它和传统的面向对象编程语言不同，它只有对象。JavaScript 并不原生支持基于类声明的继承。但是 JavaScript 的原型机制简化了为实例添加自定义属性和方法的过程。在 JavaScript 中，你可以为单个实例添加自定义的属性。例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建一个对象 bicycle\nfunction bicycle(){\n}\n\/\/ 创建一个名为 roadbike 的实例\nvar roadbike = new bicycle()\n\/\/ 为 roadbike 定义一个自定义属性 wheels\nroadbike.wheels = 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个对象 bicycle\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebicycle\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个名为 roadbike 的实例\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e roadbike = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e bicycle()\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为 roadbike 定义一个自定义属性 wheels\x3c\/span\x3e\nroadbike.wheels = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e自定义属性仅仅存在于当前这个实例中。如果我们创建了另一个 \x3ccode\x3ebicycle\x3c\/code\x3e 实例，如 \x3ccode\x3emountainbike\x3c\/code\x3e ，\x3ccode\x3emountainbike.wheels\x3c\/code\x3e 将会是 \x3ccode\x3eundefined\x3c\/code\x3e 。\x3c\/p\x3e\n\x3cp\x3e某些时候，这就是我们想要的。而又有些时候，我们想要为所有的实例都添加上这个属性。因为毕竟所有的自行车都有轮子。这是我们就会使用到原型机制。我们只需为对象的 \x3ccode\x3eprototype\x3c\/code\x3e 属性上添加我们想要的自定义属性即可：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建一个对象 bicycle\nfunction bicycle(){\n}\n\/\/ 将 wheels 属性添加到对象的原型上\nbicycle.prototype.wheels = 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个对象 bicycle\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebicycle\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将 wheels 属性添加到对象的原型上\x3c\/span\x3e\nbicycle.prototype.wheels = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，所有的 \x3ccode\x3ebicycle\x3c\/code\x3e 实例都将会拥有 \x3ccode\x3ewheels\x3c\/code\x3e 属性。\x3c\/p\x3e\n\x3cp\x3e在 V8 的模板中，做法也是一样的。每一个 \x3ccode\x3eFunctionTemplate\x3c\/code\x3e 类实例都有一个 \x3ccode\x3ePrototypeTemplate\x3c\/code\x3e 方法来给出函数的原型。你可以在其上添加属性，为这些属性关联 C\x2b\x2b 函数。都会影响到该模板关联所有的实例中。例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 Local\x3cFunctionTemplate\x3e biketemplate = FunctionTemplate::New(isolate);\n biketemplate-\x3ePrototypeTemplate().Set(\n     String::NewFromUtf8(isolate, \x26quot;wheels\x26quot;),\n     FunctionTemplate::New(isolate, MyWheelsMethodCallback)-\x3eGetFunction();\n )\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22\x3e \x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;FunctionTemplate\x26gt; biketemplate = FunctionTemplate\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate);\n biketemplate-\x26gt;PrototypeTemplate().\x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e(\n     \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3e::NewFromUtf8\x3c\/span\x3e(isolate, \x3cspan class=\x22hljs-string\x22\x3e\x22wheels\x22\x3c\/span\x3e),\n     FunctionTemplate\x3cspan class=\x22hljs-type\x22\x3e::New\x3c\/span\x3e(isolate, MyWheelsMethodCallback)-\x26gt;GetFunction();\n )\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码将会使所有的 \x3ccode\x3ebiketemplate\x3c\/code\x3e 实例拥有一个 \x3ccode\x3ewheels\x3c\/code\x3e 方法。当该方法被调用时，C\x2b\x2b 函数 \x3ccode\x3eMyWheelsMethodCallback\x3c\/code\x3e 就会执行。\x3c\/p\x3e\n\x3cp\x3eV8 的 \x3ccode\x3eFunctionTemplate\x3c\/code\x3e 类提供了一个公开成员函数 \x3ccode\x3eInherit()\x3c\/code\x3e ，当你想要一个函数模板继承于另一个函数模板时，你可以使用它，例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void Inherit(Local\x3cFunctionTemplate\x3e parent);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode class=\x22c\x2b\x2b\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-literal\x22\x3evoid\x3c\/span\x3e Inherit(\x3cspan class=\x22hljs-built_in\x22\x3eLocal\x3c\/span\x3e\x26lt;FunctionTemplate\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e最后\x3c\/h2\x3e\n\x3cp\x3e原文链接：\x3ca href=\x22https:\/\/developers.google.com\/v8\/embed\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/developers.google.com\/v8\/embed\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>[译] V8 使用者文档</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005684490">https://segmentfault.com/a/1190000005684490</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/msdlvxmvawr/" target="_blank">https://alili.tech/archive/msdlvxmvawr/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>