<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 原型继承之精髓"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript 原型继承之精髓 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mqqtg7nmv3/",
				"appid": "1613049289050283", 
				"title": "JavaScript 原型继承之精髓 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-14T02:30:37"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jv2v4ljh83q/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/k8jw1tz6zng/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmqqtg7nmv3%2f&text=JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e4%b9%8b%e7%b2%be%e9%ab%93"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmqqtg7nmv3%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmqqtg7nmv3%2f&text=JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e4%b9%8b%e7%b2%be%e9%ab%93"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmqqtg7nmv3%2f&title=JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e4%b9%8b%e7%b2%be%e9%ab%93"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmqqtg7nmv3%2f&is_video=false&description=JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e4%b9%8b%e7%b2%be%e9%ab%93"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e4%b9%8b%e7%b2%be%e9%ab%93&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmqqtg7nmv3%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmqqtg7nmv3%2f&title=JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e4%b9%8b%e7%b2%be%e9%ab%93"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmqqtg7nmv3%2f&title=JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e4%b9%8b%e7%b2%be%e9%ab%93"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmqqtg7nmv3%2f&title=JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e4%b9%8b%e7%b2%be%e9%ab%93"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmqqtg7nmv3%2f&title=JavaScript%20%e5%8e%9f%e5%9e%8b%e7%bb%a7%e6%89%bf%e4%b9%8b%e7%b2%be%e9%ab%93"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 原型继承之精髓</h1><div class="meta"><div class="postdate"><time datetime="2019-02-14" itemprop="datePublished">2019-02-14</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e一篇文章让你搞清楚 JavaScript 继承的本质、\x3ccode\x3eprototype\x3c\/code\x3e、\x3ccode\x3e__proto__\x3c\/code\x3e、\x3ccode\x3econstructor\x3c\/code\x3e 都是什么。\x3c\/p\x3e\n\x3cp\x3e很多小伙伴表示不明白 JavaScript 的继承，说是原型链，看起来又像类，究竟是原型还是类？各种 \x3ccode\x3eprototype\x3c\/code\x3e、\x3ccode\x3e__proto__\x3c\/code\x3e、\x3ccode\x3econstructor\x3c\/code\x3e 内部变量更是傻傻搞不清楚。其实，只要明白继承的本质就很能理解，继承是为了代码复用。复用并不一定得通过类，JS 就采用了一种轻量简明的原型方案来实现。Java\/C\x2b\x2b 等强类型语言中有类和对象的区别，但 JS 只有对象。它的原型也是对象。只要你完全抛开面向对象的继承思路来看 JS 的原型继承，你会发现它轻便但强大。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e目录\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e继承方案的设计要求\x3c\/li\x3e\n\x3cli\x3e被复用的对象：\x3ccode\x3eprototype\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e优雅的 API：ES6 \x3ccode\x3eclass\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e简明的向上查找机制：\x3ccode\x3e__proto__\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e构造函数又是个啥玩意儿\x3c\/li\x3e\n\x3cli\x3e双链合璧：终极全图\x3c\/li\x3e\n\x3cli\x3e总结\x3c\/li\x3e\n\x3cli\x3e参考\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e继承方案的设计要求\x3c\/h2\x3e\n\x3cp\x3e前面我们讲，继承的本质是为了更好地实现代码复用。再仔细思考，可以发现，这里的「代码」指的一定是「数据\x2b行为」的复用，也就是把一组数据和数据相关的行为进行封装。为什么呢？因为，如果只是复用行为，那么使用函数就足够了；而如果只是复用数据，这使用 JavaScript 对象就可以了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const parent = {\n  some: \x27data\x27,\n}\nconst child = {\n  ...parent,\n  uniq: \x27data\x27,\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e parent = {\n  \x3cspan class=\x22hljs-attr\x22\x3esome\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e,\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e child = {\n  ...parent,\n  \x3cspan class=\x22hljs-attr\x22\x3euniq\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e,\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此，只有数据\x2b行为（已经类似于一个「对象」的概念）的封装，才是继承技术所必须出现的地方。为了满足这样的代码复用，一个继承体系的设计需要支持什么需求呢？\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e存储公用的数据和函数\x3c\/li\x3e\n\x3cli\x3e覆盖被继承对象数据或函数的能力\x3c\/li\x3e\n\x3cli\x3e向上查找\/调用被继承对象函数的数据或函数的能力\x3c\/li\x3e\n\x3cli\x3e优雅的语法（API）\x3c\/li\x3e\n\x3cli\x3e增加新成员的能力\x3c\/li\x3e\n\x3cli\x3e支持私有数据\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e「支持私有数据」，这个基本所有方案都没实现，此阶段我们可以不用纠结；而「增加新成员的能力」，基本所有的方案都能做到，也不再赘述，主要来看前四点。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e被复用的对象：\x3ccode\x3eprototype\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3eJavaScript 的继承有多种实现方式，具体有哪些，推荐读者可阅读：[JavaScript 语言精粹][]一书 和 \x3ca href=\x22https:\/\/github.com\/mqyqingfeng\/Blog\/issues\/16\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这篇文章\x3c\/a\x3e。这里，我们直接看一版比较优秀的实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Animal(name) {\n  this.name = name\n  this.getName = function() {\n    return this.name\n  }\n}\n\nfunction Cat(name, age) {\n  Animal.call(this, name)\n  this.age = age || 1\n  this.meow = function() {\n    return `${this.getName()}eowww~~~~~, I\x27m ${this.age} year(s) old`\n  }\n}\n\nconst cat = new Cat(\x27Lily\x27, 2)\nconsole.log(cat.meow()) \/\/ \x27Lilyeowww~~~~~, I\x27m 2 year(s) old\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\n  }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age\x3c\/span\x3e) \x3c\/span\x3e{\n  Animal.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name)\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age || \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.meow = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getName()}\x3c\/span\x3eeowww~~~~~, I\x27m \x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age}\x3c\/span\x3e year(s) old`\x3c\/span\x3e\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cat = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat(\x3cspan class=\x22hljs-string\x22\x3e\x27Lily\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(cat.meow()) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27Lilyeowww~~~~~, I\x27m 2 year(s) old\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个方案，具备增添新成员的能力、调用被继承对象函数的能力等。一个比较重大的缺陷是：对象的所有方法 \x3ccode\x3egetName\x3c\/code\x3e \x3ccode\x3emeow\x3c\/code\x3e，都会随每个实例生成一份新的拷贝。这显然不是优秀的设计方案，我们期望的结果是，继承自同一对象的子对象，其所有的方法都共享自同一个函数实例。\x3c\/p\x3e\n\x3cp\x3e怎么办呢？想法也很简单，就是把它们放到同一个地方去，并且还要跟这个「对象」关联起来。如此一想，用来生成这个「对象」的函数本身就是很好的地方。我们可以把它放在函数的任一一个变量上，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Animal.functions.getName = function() {\n  return this.name\n}\nCat.functions.meow = function() {\n  return `${this.getName()}eowww~~~~~, I\x27m ${this.age} year(s) old`\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eAnimal.functions.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\n}\nCat.functions.meow = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getName()}\x3c\/span\x3eeowww~~~~~, I\x27m \x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age}\x3c\/span\x3e year(s) old`\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但这样调用起来，你就要写 \x3ccode\x3eanimal.functions.getName()\x3c\/code\x3e，并不方便。不要怕，JavaScript 这门语言本身已经帮你内置了这样的支持。它内部所用来存储公共函数的变量，就是你熟知的 \x3ccode\x3eprototype\x3c\/code\x3e。当你调用对象上的方法时（如 \x3ccode\x3ecat.getName()\x3c\/code\x3e），它会自动去 \x3ccode\x3eCat.prototype\x3c\/code\x3e 上去帮你找 \x3ccode\x3egetName\x3c\/code\x3e 函数，而你只需要写 \x3ccode\x3ecat.getName()\x3c\/code\x3e 即可。兼具了功能的实现和语法的优雅。\x3c\/p\x3e\n\x3cp\x3e最后写出来的代码会是这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Animal(name) {\n  this.name = name\n}\nAnimal.prototype.getName = function() {\n  return this.name\n}\n\nfunction Cat(name, age) {\n  Animal.call(this, name)\n  this.age = age || 1\n}\nCat.prototype = Object.create(Animal.prototype, { constructor: Cat })\nCat.prototype.meow = function() {\n  return `${this.getName()}eowww~~~~~, I\x27m ${this.age} year(s) old`\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n}\nAnimal.prototype.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age\x3c\/span\x3e) \x3c\/span\x3e{\n  Animal.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name)\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age || \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n}\nCat.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(Animal.prototype, { \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: Cat })\nCat.prototype.meow = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getName()}\x3c\/span\x3eeowww~~~~~, I\x27m \x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age}\x3c\/span\x3e year(s) old`\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意，\x3cstrong\x3e只有函数才有 \x3ccode\x3eprototype\x3c\/code\x3e 属性\x3c\/strong\x3e，它是用来做原型继承的必需品。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e优雅的 API：ES6 \x3ccode\x3eclass\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cp\x3e然鹅，上面这个写法仍然并不优雅。在何处呢？一个是 \x3ccode\x3eprototype\x3c\/code\x3e 这种暴露语言实现机制的关键词；一个是要命的是，这个函数内部的 \x3ccode\x3ethis\x3c\/code\x3e，依靠的是作为使用者的你记得使用 \x3ccode\x3enew\x3c\/code\x3e 操作符去调用它才能得到正确的初始化。但是这里没有任何线索告诉你，应该使用 \x3ccode\x3enew\x3c\/code\x3e 去调用这个函数，一旦你忘记了，也不会有任何编译期和运行期的错误信息。这样的语言特性，与其说是一个「继承方案」，不如说是一个 bug，一个不应出现的设计失误。\x3c\/p\x3e\n\x3cp\x3e而这两个问题，在 ES6 提供的 \x3ccode\x3eclass\x3c\/code\x3e 关键词下，已经得到了非常妥善的解决，尽管它叫一个 class，但本质上其实是通过 prototype 实现的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Animal {\n  constructor(name) {\n    this.name = name\n  }\n\n  getName() {\n    return this.name\n  }\n}\n\nclass Cat extends Animal {\n  constructor(name, age) {\n    super(name)\n    this.age = age || 1\n  }\n\n  meow() {\n    return `${this.getName()}eowww~~~~~, I\x27m ${this.age} year(s) old`\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n  }\n\n  getName() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\n  }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name, age) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(name)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age || \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n  }\n\n  meow() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getName()}\x3c\/span\x3eeowww~~~~~, I\x27m \x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age}\x3c\/span\x3e year(s) old`\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e如果你没有使用 \x3ccode\x3enew\x3c\/code\x3e 操作符，编译器和运行时都会直接报错。为什么呢，我们将在[下一篇文章][]讲解\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eextends\x3c\/code\x3e 关键字，会使解释器直接在底下完成基于原型的继承功能\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e现在，我们已经看到了一套比较完美的继承 API，也看到其底下使用 \x3ccode\x3eprototype\x3c\/code\x3e 存储公共变量的地点和原理。接下来，我们要解决另外一个问题：\x3ccode\x3eprototype\x3c\/code\x3e 有了，实例对象应该如何访问到它呢？这就关系到 JavaScript 的向上查找机制了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e简明的向上查找机制：\x3ccode\x3e__proto__\x3c\/code\x3e\n\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Animal(name) {\n  this.name = name\n}\nAnimal.prototype.say = function() {\n  return this.name\n}\nconst cat = new Animal(\x27kitty\x27)\n\nconsole.log(cat) \/\/ Animal { name: \x27kitty\x27 }\ncat.hasOwnProperty(\x27say\x27) \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n}\nAnimal.prototype.say = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cat = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Animal(\x3cspan class=\x22hljs-string\x22\x3e\x27kitty\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(cat) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Animal { name: \x27kitty\x27 }\x3c\/span\x3e\ncat.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x27say\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看上面 👆 一个最简单的例子。打出来的 \x3ccode\x3ecat\x3c\/code\x3e 对象本身并没有 \x3ccode\x3esay\x3c\/code\x3e 方法。那么，被实例化的 \x3ccode\x3ecat\x3c\/code\x3e 对象本身，是怎样向上查找到 \x3ccode\x3eAnimal.prototype\x3c\/code\x3e 上的 \x3ccode\x3esay\x3c\/code\x3e 方法的呢？如果你是 JavaScript 引擎的设计者，你会怎样来实现呢？\x3c\/p\x3e\n\x3cp\x3e我拍脑袋这么一想，有几种方案：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在 \x3ccode\x3eAnimal\x3c\/code\x3e 中初始化实例对象 \x3ccode\x3ecat\x3c\/code\x3e 时，顺便存取一个指向 \x3ccode\x3eAnimal.prototype\x3c\/code\x3e 的引用\x3c\/li\x3e\n\x3cli\x3e在 \x3ccode\x3eAnimal\x3c\/code\x3e 中初始化实例对象时，记录其「类型」（也即是 \x3ccode\x3eAnimal\x3c\/code\x3e）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 方案1\nfunction Animal(name) {\n  this.name = name\n  \/\/ 以下代码由引擎自动加入\n  this.__prototype__ = Animal.prototype\n}\n\nconst cat = new Animal(\x27kitty\x27)\ncat.say() \/\/ -\x3e cat.__prototype__.say()\n\n\/\/ 方案2\nfunction Animal(name) {\n  this.name = name\n  \/\/ 以下代码由引擎自动加入\n  this.__type__ = Animal\n}\n\nconst cat = new Animal(\x27kitty\x27)\ncat.say() \/\/ -\x3e cat.__type__.prototype.say()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 方案1\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以下代码由引擎自动加入\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__prototype__ = Animal.prototype\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cat = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Animal(\x3cspan class=\x22hljs-string\x22\x3e\x27kitty\x27\x3c\/span\x3e)\ncat.say() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ -\x26gt; cat.__prototype__.say()\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 方案2\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以下代码由引擎自动加入\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__type__ = Animal\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cat = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Animal(\x3cspan class=\x22hljs-string\x22\x3e\x27kitty\x27\x3c\/span\x3e)\ncat.say() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ -\x26gt; cat.__type__.prototype.say()\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e究其实质，其实就是：\x3cstrong\x3e实例对象需要一个指向其函数的引用（变量）\x3c\/strong\x3e，以拿到这个公共原型 \x3ccode\x3eprototype\x3c\/code\x3e 来实现继承方案的向上查找能力。读者如果有其他方案，不妨留言讨论。\x3c\/p\x3e\n\x3cp\x3e无独有偶，这两种方案，在 JavaScript 中都有实现，只不过变量的命名与我们的取法有所差异：第一种方案中，实际的变量名叫 \x3ccode\x3e__proto__\x3c\/code\x3e 而不是 \x3ccode\x3e__prototype__\x3c\/code\x3e；第二种方案中，实际的变量名叫 \x3ccode\x3econstructor\x3c\/code\x3e，不叫\x3cdel\x3e俗气的\x3c\/del\x3e \x3ccode\x3e__type__\x3c\/code\x3e。实际上，用来实现继承、做向上查找的这个引用，正是 \x3ccode\x3e__proto__\x3c\/code\x3e；至于 constructor，则另有他用。不过要注意的是，尽管基本所有浏览器都支持 \x3ccode\x3e__proto__\x3c\/code\x3e，它并不是规范的一部分，因此并不推荐在你的业务代码中直接使用 \x3ccode\x3e__proto__\x3c\/code\x3e 这个变量。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016828689\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016828689\x22 alt=\x22JavaScript Prototypal Inheritance\x22 title=\x22JavaScript Prototypal Inheritance\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从上图可以清楚看到，\x3ccode\x3eprototype\x3c\/code\x3e 是用来存储类型公共方法的一个对象（正因此每个类型有它基本的方法），而 \x3ccode\x3e__proto__\x3c\/code\x3e 是用来实现向上查找的一个引用。任何对象都会有 \x3ccode\x3e__proto__\x3c\/code\x3e。\x3ccode\x3eObject.prototype\x3c\/code\x3e 的 \x3ccode\x3e__proto__\x3c\/code\x3e 是 null，也即是原型链的终点。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e构造函数又是个啥玩意儿？\x3c\/h2\x3e\n\x3cp\x3e再加入 constructor 这个东西，它与 \x3ccode\x3eprototype\x3c\/code\x3e、\x3ccode\x3e__proto__\x3c\/code\x3e 是什么关系？这个地方，说复杂就很复杂了，让我们尽量把它说简单一些。开始之前，我们需要查阅一下语言规范，看一些基本的定义：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-terms-and-definitions-object\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e对象\x3c\/a\x3e：[对象是一组集合，其中可包含零个或多个属性。对象都有一个原型对象（译者注：即 [[Prototype]]\/\x3ccode\x3e__proto__\x3c\/code\x3e）][specification: overview]\x3c\/li\x3e\n\x3cli\x3e函数：\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-terms-and-definitions-function\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e是对象类型的一员\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3e构造函数：\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-constructor\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e构造函数是个用于创建对象的\x3cstrong\x3e函数对象\x3c\/strong\x3e。每个构造函数都有一个 \x3ccode\x3eprototype\x3c\/code\x3e 对象，用以实现原型式继承，作属性共享用\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里说明了什么呢？说明了构造函数是函数，它比普通函数多一个 \x3ccode\x3eprototype\x3c\/code\x3e 属性；而函数是对象，对象都有一个原型对象 \x3ccode\x3e__proto__\x3c\/code\x3e。这个东西有什么作用呢？\x3c\/p\x3e\n\x3cp\x3e上节我们深挖了用于继承的原型链，它链接的是原型对象。而对象是通过构造函数生成的，也就是说，普通对象、原型对象、函数对象都将有它们的构造函数，这将为我们引出另一条链——\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016828690\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016828690\x22 alt=\x22JavaScript Constructor Chain\x22 title=\x22JavaScript Constructor Chain\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在 JavaScript 中，谁是谁的构造函数，是通过 \x3ccode\x3econstructor\x3c\/code\x3e 来标识的。正常来讲，普通对象（如图中的 \x3ccode\x3ecat\x3c\/code\x3e 和 \x3ccode\x3e{ name: \x27Lin\x27 }\x3c\/code\x3e 对象）是没有 \x3ccode\x3econstructor\x3c\/code\x3e 属性的，它是从原型上继承而来；而图中粉红色的部分即是函数对象（如 \x3ccode\x3eCat\x3c\/code\x3e \x3ccode\x3eAnimal\x3c\/code\x3e \x3ccode\x3eObject\x3c\/code\x3e 等），它们的原型对象是 \x3ccode\x3eFunction.prototype\x3c\/code\x3e，这没毛病。关键是，它们是函数对象，对象就有构造函数，那么函数的构造函数是啥呢？是 \x3ccode\x3eFunction\x3c\/code\x3e。那么问题又来了，\x3ccode\x3eFunction\x3c\/code\x3e 也是函数，它的构造函数是谁呢？\x3cstrong\x3e是它自己\x3c\/strong\x3e：\x3ccode\x3eFunction.constructor === Function\x3c\/code\x3e。由此，\x3ccode\x3eFunction\x3c\/code\x3e 即是构造函数链的终结。\x3c\/p\x3e\n\x3cp\x3e上面我们提到，\x3ccode\x3econstructor\x3c\/code\x3e 也可以用来实现原型链的向上查找，然后它却别有他用。有个啥用呢？一般认为，它是用以支撑 \x3ccode\x3einstanceof\x3c\/code\x3e 关键字实现的数据结构。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e双链合璧：终极全图\x3c\/h2\x3e\n\x3cp\x3e好了，是时候进入最烧脑的部分了。前面我们讲了两条链：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e原型链。它用来实现原型继承，最上层是 \x3ccode\x3eObject.prototype\x3c\/code\x3e，终结于 \x3ccode\x3enull\x3c\/code\x3e，没有循环\x3c\/li\x3e\n\x3cli\x3e构造函数链。它用来表明构造关系，最上层循环终结于 \x3ccode\x3eFunction\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e把这两条链结合到一起，你就会看到\x3cdel\x3e一条双螺旋 DNA\x3c\/del\x3e这几张你经常看到却又看不懂的图：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/juejin.im\/post\/5b729c24f265da280f3ad010\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016828691\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016828691\x22 alt=\x22constructor\/prototype\/proto\x22 title=\x22constructor\/prototype\/proto\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.mollypages.org\/tutorials\/js.mp\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016828692\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016828692\x22 alt=\x22constructor\/prototype\/proto\x22 title=\x22constructor\/prototype\/proto\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e图都是引用自其它文章，点击图片可跳转到原文。其中，第一篇文章 [一张图理解 JS 的原型][] 是我见过解析得最详细的，本文的很多灵感也来自这篇文章。\x3c\/p\x3e\n\x3cp\x3e理解了上面两条链以后，这两个全图实际上就不难理解了。分享一下，怎么来读懂这个图：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e首先看构造函数链。所有的普通对象，\x3ccode\x3econstructor\x3c\/code\x3e 都会指向它们的构造函数；而构造函数也是对象，它们最终会一级一级上溯到 \x3ccode\x3eFunction\x3c\/code\x3e 这个构造函数。\x3ccode\x3eFunction\x3c\/code\x3e 的构造函数是它自己，也即此链的终结；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eFunction\x3c\/code\x3e 的 \x3ccode\x3eprototype\x3c\/code\x3e 是 \x3ccode\x3eFunction.prototype\x3c\/code\x3e，它是个普通的原型对象；\x3c\/li\x3e\n\x3cli\x3e其次看原型链。所有的普通对象，\x3ccode\x3e__proto__\x3c\/code\x3e 都会指向其构造函数的原型对象 \x3ccode\x3e[Class].prototype\x3c\/code\x3e；而所有原型对象，包括构造函数链的终点 \x3ccode\x3eFunction.prototype\x3c\/code\x3e，都会最终上溯到 \x3ccode\x3eObject.prototype\x3c\/code\x3e，终结于 null。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e也即是说，构造函数链的终点 \x3ccode\x3eFunction\x3c\/code\x3e，其原型又融入到了原型链中：\x3ccode\x3eFunction.prototype -\x26gt; Object.prototype -\x26gt; null\x3c\/code\x3e，最终抵达原型链的终点 \x3ccode\x3enull\x3c\/code\x3e。至此这两条契合到了一起。\x3c\/p\x3e\n\x3cp\x3e总结下来，可以概括成这几句话：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eJS 世界的变量除了普通类型外都是对象，包括函数也是对象\x3c\/li\x3e\n\x3cli\x3e所有对象都必须由函数生成，包括普通对象、原型对象及函数对象\x3c\/li\x3e\n\x3cli\x3e所有函数最终都生成自 \x3ccode\x3eFunction\x3c\/code\x3e，包括 \x3ccode\x3eFunction\x3c\/code\x3e 自己\x3c\/li\x3e\n\x3cli\x3e所有对象最终都继承自 \x3ccode\x3eObject.prototype\x3c\/code\x3e，包括 \x3ccode\x3eFunction.prototype\x3c\/code\x3e，终止于 \x3ccode\x3enull\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里还有最后一个所谓「鸡生蛋还是蛋生🐔」的问题：是先有 \x3ccode\x3eObject.prorotype\x3c\/code\x3e，还是先有 \x3ccode\x3eFunction\x3c\/code\x3e？如果先有前者，那么此时 \x3ccode\x3eFunction\x3c\/code\x3e 还不在，这个对象又是由谁创建呢？如果先有后者，那么 \x3ccode\x3eFunction\x3c\/code\x3e 也是个对象，它的原型 \x3ccode\x3eFunction.prototype.__proto__\x3c\/code\x3e 从哪去继承呢？这个问题，看似无解。但从 这篇文章：从__proto__和prototype来深入理解JS对象和原型链 中，我们发现了一个合理的解释，那就是：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3ccode\x3eObject.prototype\x3c\/code\x3e 是个神之对象。它不由 \x3ccode\x3eFunction\x3c\/code\x3e 这个函数构造产生。\x3c\/blockquote\x3e\n\x3cp\x3e证据如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.prototype instanceof Object                \/\/ false\nObject.prototype instanceof Function              \/\/ false\nObject.prototype.__proto__ === Function.prototype \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e              \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.__proto__ === \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e.prototype \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eJS 对象世界的构造次序应该是：\x3ccode\x3eObject.prototype\x3c\/code\x3e -\x26gt; \x3ccode\x3eFunction.prototype\x3c\/code\x3e -\x26gt; \x3ccode\x3eFunction\x3c\/code\x3e -\x26gt; \x3ccode\x3eObject\x3c\/code\x3e -\x26gt; ...\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e讲到这里，我想关于 JavaScript 继承中的一些基本问题可以解释清楚了：\x3c\/p\x3e\n\x3cblockquote\x3eJavaScript 继承是类继承还是原型继承？不是使用了 new 关键字么，应该跟类有关系吧？\x3c\/blockquote\x3e\n\x3cp\x3e是完全的原型继承。尽管用了 \x3ccode\x3enew\x3c\/code\x3e 关键字，但其实只是个语法糖，跟类没有关系。JavaScript 没有类。它与类继承完全不同，只是长得像。好比雷锋和雷峰塔的关系。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3ccode\x3eprototype\x3c\/code\x3e 是什么东西？用来干啥？\x3c\/blockquote\x3e\n\x3cp\x3e\x3ccode\x3eprototype\x3c\/code\x3e 是个对象，只有函数上有。它是用来存储对象的属性（数据和方法）的地方，是实现 JavaScript 原型继承的基础。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3ccode\x3e__proto__\x3c\/code\x3e 是什么东西？用来干啥？\x3c\/blockquote\x3e\n\x3cp\x3e\x3ccode\x3e__proto__\x3c\/code\x3e 是个指向 \x3ccode\x3eprototype\x3c\/code\x3e 的引用。用以辅助原型继承中向上查找的实现。虽然它得到了所有浏览器的支持，但并不是规范所推荐的做法。严谨地说，它是一个指向 \x3ccode\x3e[[Prototype]]\x3c\/code\x3e 的引用。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3ccode\x3econstructor\x3c\/code\x3e 是什么东西？用来干啥？\x3c\/blockquote\x3e\n\x3cp\x3e是对象上一个指向构造函数的引用。用来辅助 \x3ccode\x3einstanceof\x3c\/code\x3e 等关键字的实现。\x3c\/p\x3e\n\x3cblockquote\x3e🐔生蛋还是蛋生🐔？\x3c\/blockquote\x3e\n\x3cp\x3e神生鸡，鸡生蛋。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e参考\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/juejin.im\/post\/5b729c24f265da280f3ad010\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e一张图理解 JS 的原型\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/crockford.com\/javascript\/prototypal.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePrototypal Inheritance in JavaScript\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/blog.vjeux.com\/2011\/javascript\/how-prototypal-inheritance-really-works.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHow Prototypal Inheritance really works\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.ecma-international.org\/ecma-262\/6.0\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eECMAScript 2015(ES6) Specification\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/creeperyang\/blog\/issues\/9\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从__proto__和 prototype 来深入理解 JS 对象和原型链\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/mqyqingfeng\/Blog\/issues\/16\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript 深入之继承的多种方法\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e[MDN: Inheritance in JavaScript][]\x3c\/li\x3e\n\x3cli\x3e[MDN: Inheritance and the prototype chain][]\x3c\/li\x3e\n\x3cli\x3e[MDN: Details of the object model][]\x3c\/li\x3e\n\x3cli\x3e[MDN: \x3ccode\x3e__proto__\x3c\/code\x3e][]\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript 原型继承之精髓</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016828686">https://segmentfault.com/a/1190000016828686</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mqqtg7nmv3/" target="_blank">https://alili.tech/archive/mqqtg7nmv3/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>