<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="笨办法学函数式编程：Elm 初体验"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>笨办法学函数式编程：Elm 初体验 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/7wvxkyaw52a/",
				"appid": "1613049289050283", 
				"title": "笨办法学函数式编程：Elm 初体验 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-12T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/hvenahtvm4i/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/zq6qh2ui8ys/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f7wvxkyaw52a%2f&text=%e7%ac%a8%e5%8a%9e%e6%b3%95%e5%ad%a6%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%ef%bc%9aElm%20%e5%88%9d%e4%bd%93%e9%aa%8c"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f7wvxkyaw52a%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f7wvxkyaw52a%2f&text=%e7%ac%a8%e5%8a%9e%e6%b3%95%e5%ad%a6%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%ef%bc%9aElm%20%e5%88%9d%e4%bd%93%e9%aa%8c"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f7wvxkyaw52a%2f&title=%e7%ac%a8%e5%8a%9e%e6%b3%95%e5%ad%a6%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%ef%bc%9aElm%20%e5%88%9d%e4%bd%93%e9%aa%8c"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f7wvxkyaw52a%2f&is_video=false&description=%e7%ac%a8%e5%8a%9e%e6%b3%95%e5%ad%a6%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%ef%bc%9aElm%20%e5%88%9d%e4%bd%93%e9%aa%8c"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%ac%a8%e5%8a%9e%e6%b3%95%e5%ad%a6%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%ef%bc%9aElm%20%e5%88%9d%e4%bd%93%e9%aa%8c&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f7wvxkyaw52a%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f7wvxkyaw52a%2f&title=%e7%ac%a8%e5%8a%9e%e6%b3%95%e5%ad%a6%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%ef%bc%9aElm%20%e5%88%9d%e4%bd%93%e9%aa%8c"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7wvxkyaw52a%2f&title=%e7%ac%a8%e5%8a%9e%e6%b3%95%e5%ad%a6%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%ef%bc%9aElm%20%e5%88%9d%e4%bd%93%e9%aa%8c"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7wvxkyaw52a%2f&title=%e7%ac%a8%e5%8a%9e%e6%b3%95%e5%ad%a6%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%ef%bc%9aElm%20%e5%88%9d%e4%bd%93%e9%aa%8c"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7wvxkyaw52a%2f&title=%e7%ac%a8%e5%8a%9e%e6%b3%95%e5%ad%a6%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%ef%bc%9aElm%20%e5%88%9d%e4%bd%93%e9%aa%8c"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">笨办法学函数式编程：Elm 初体验</h1><div class="meta"><div class="postdate"><time datetime="2019-02-12" itemprop="datePublished">2019-02-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e翻译自：\x3ca href=\x22https:\/\/gist.github.com\/ohanhi\/0d3d83cf3f0d7bbea9db\x22 rel=\x22nofollow noreferrer\x22\x3ehttps:\/\/gist.github.com\/ohanhi\/0d3d83cf3f0d7bbea9db\x3c\/a\x3e\x3cbr\x3e原作者： Ossi Hanhinen, \x3ca href=\x22https:\/\/twitter.com\/ohanhi\x22 rel=\x22nofollow noreferrer\x22\x3e@ohanhi\x3c\/a\x3e\x3cbr\x3e翻译：Integ, \x3ca href=\x22https:\/\/segmentfault.com\/u\/integ\x22\x3e@integ\x3c\/a\x3e\x3cbr\x3e爱心支持 \x3ca href=\x22http:\/\/futurice.com\/\x22 rel=\x22nofollow noreferrer\x22\x3eFuturice\x3c\/a\x3e \x3cspan class=\x22emoji emoji-green_heart\x22\x3e\x3c\/span\x3e.\x3cbr\x3e授权协议 \x3ca href=\x22https:\/\/creativecommons.org\/licenses\/by\/4.0\/\x22 rel=\x22nofollow noreferrer\x22\x3eCC BY 4.0\x3c\/a\x3e.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2\x3e前言\x3c\/h2\x3e\n\x3cp\x3e不久以前一个好朋友给我安利了 \x3ca href=\x22https:\/\/gist.github.com\/staltz\/868e7e9bc2a7b8c1f754\x22 rel=\x22nofollow noreferrer\x22\x3e\x3cem\x3e响应式编程（Reactive Programming）\x3c\/em\x3e\x3c\/a\x3e。不写 \x3cem\x3e函数式响应编程\x3c\/em\x3e 简直就是犯罪 -- 很明显函数式方法大幅弥补了响应编程的不足。它如何做到的，我并不知道，所以我决定学一下这些东西。\x3c\/p\x3e\n\x3cp\x3e通过了解自己，我很快发现只有用它解决一些实际的问题，我才能领会它的观念模式。写了这么多年 Javascript，我本来早就可以开始使用 RxJS 的。但再一次，因为我了解自己，并且我发现它会给我太多空间来违背常理。我需要一个强制我用函数式思维来解决任何问题的工具，正在这时 Elm 出现了。\x3c\/p\x3e\n\x3ch3\x3eElm 是什么？\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/elm-lang.org\/\x22 rel=\x22nofollow noreferrer\x22\x3eElm\x3c\/a\x3e 是一种编程语言，它会被编译为 HTML5: HTML, CSS 和 JavaScript。根据你显示输出结果的不同，它可能是一个内置了对象的 \x3ccode\x3e\x26lt;canvas\x26gt;\x3c\/code\x3e，或者一个更传统的网页。让我重复一遍，Elm 是一种语言，它会被编译为 \x3cem\x3e三种语言\x3c\/em\x3e 来构建 web 应用。而且，它是一个拥有强类型和 不可变（immutable）数据结构的函数式语言。\x3c\/p\x3e\n\x3cp\x3e好了，你可以猜到我并不是这个领域的专家，为了防止你走丢，我专门在这篇文章的最后列出了下面的术语解释：\x3ca\x3e附录:术语表\x3c\/a\x3e.\x3c\/p\x3e\n\x3ch2\x3eI. 限制是有益的\x3c\/h2\x3e\n\x3cp\x3e我决定尝试使用 Elm 制作一个类似《太空侵略者》的游戏。让我们站在玩家的视角思考一下它是怎么工作的。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e在屏幕下部有一艘代表着玩家的飞船\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e玩家可以通过相应的方向键控制飞船左右移动\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e玩家可以按向上键发射子弹射击\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e好了，我们切换到飞船的视角，再来看下\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e飞船有一个一维的位置坐标\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e飞船可以获得一个速度（向左或向右）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e飞船根据它的速度改变位置\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e飞船可能被击中\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这些基本上给了我一个飞船的数据结构的定义，或者说一个 Elm 术语中的 \x3ca href=\x22http:\/\/elm-lang.org\/guide\/core-language#records\x22 rel=\x22nofollow noreferrer\x22\x3e记录\x3c\/a\x3e。尽管并非必须，我还是喜欢把它定义为一个 aliases 类型，这样就可以使用 \x3ccode\x3eShip\x3c\/code\x3e 来表示它的类型了。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3etype alias Ship =\n  { position : Float  -- just 1 degree of freedom (left-right)\n  , velocity : Float  -- either 0, 1 or -1\n  , shooting : Bool\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e太棒了，现在让我们创建一个飞船吧。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3einitShip : Ship   -- this is the type annotation\ninitShip =\n  { position = 0      -- the type is Float\n  , velocity = 0      -- Float\n  , shooting = False  -- Bool\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以，我们已经到了一个有趣的地步。再看一遍上面的定义，它是一个简单的陈述还是一个函数定义？无所谓！\x3ccode\x3einitShip\x3c\/code\x3e 既可以被认为只是字面量的定义纪录，也可以看作一个永远返回这些纪录的函数。因为函数是纯函数，并且它的数据结构是不可改变的，所以也没有办法区分他们，Wow，cool。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cem\x3e旁注：\x3c\/em\x3e如果你像我一样，你会思考如果试着重新定义 \x3ccode\x3einitShip\x3c\/code\x3e 会发生什么。好的，会发生一个编译时错误：“命名冲突：只能有一个对 \x3ccode\x3efoo\x3c\/code\x3e 的定义”。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e好，我们来开始移动飞船！我记得高中时学过 \x3ccode\x3es = v*dt\x3c\/code\x3e ，或者说距离等于速度乘以时间差。所以这就是我如何改变我的飞船。在 Elm 中会像下面这样实现。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3eapplyPhysics : Float -\x26gt; Ship -\x26gt; Ship\napplyPhysics dt ship =\n  { ship | position = ship.position \x2b ship.velocity * dt }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e类型标记描述了：给出一个 \x3ccode\x3eFloat\x3c\/code\x3e 和一个 \x3ccode\x3eShip\x3c\/code\x3e，我会返回一个 \x3ccode\x3eShip\x3c\/code\x3e，甚至：给出一个 \x3ccode\x3eFloat\x3c\/code\x3e，我会返回 \x3ccode\x3eShip -\x26gt; Ship\x3c\/code\x3e。例如，\x3ccode\x3e(applyPhysics 16.7)\x3c\/code\x3e 实际上会返回一个可以传入一个 \x3ccode\x3eShip\x3c\/code\x3e 参数的函数，并且得到应用了物理方程的飞船作为返回值。这个特性叫做 \x3ca href=\x22http:\/\/en.wikipedia.org\/wiki\/Currying\x22 rel=\x22nofollow noreferrer\x22\x3e柯里化\x3c\/a\x3e 而且所有 Elm 函数自动这样运作。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cem\x3e旁注：\x3c\/em\x3e 然而，这一切有什么意义呢？好吧，假设我要创建一个由两列数据组成的表格。我知道如何构建它类似“给出一个列表和一个简单的值，从列表中找出匹配的项”或者直接写作 \x3ccode\x3efindMatches : List -\x26gt; Item -\x26gt; List\x3c\/code\x3e。但是我需要把一些先前已经知道的列表映射到新的列表中。这就是柯里化伟大的地方：我可以仅仅写出 \x3ccode\x3ecrossReference = map (findMatches listA) listB\x3c\/code\x3e 就可以实现了。 \x3ccode\x3e(findMatches listA)\x3c\/code\x3e 是一个 \x3ccode\x3eItem -\x26gt; List\x3c\/code\x3e 类型的函数，完全就是我们想要的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e现在，回到实际的话题，\x3ccode\x3eapplyPhysics\x3c\/code\x3e 创建了一个新的纪录，使用提供的 \x3ccode\x3eShip\x3c\/code\x3e 作为基础，设置 \x3ccode\x3eposition\x3c\/code\x3e 为一些其他的值。这就是 \x3ccode\x3e{ ship | position = .. }\x3c\/code\x3e 句法的含义。更多的，请参考 \x3ca href=\x22http:\/\/elm-lang.org\/guide\/core-language#records\x22 rel=\x22nofollow noreferrer\x22\x3eUpdating Records\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e更新飞船的其他两个属性也是类似：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3eupdateVelocity : Float -\x26gt; Ship -\x26gt; Ship\nupdateVelocity newVelocity ship =\n  { ship | velocity = newVelocity }\n\nupdateShooting : Bool -\x26gt; Ship -\x26gt; Ship\nupdateShooting isShooting ship =\n  { ship | shooting = isShooting }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e把这些拼在一起，我们就得到了一搜完整的飞船，像下面这样：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3e-- represents pressing the arrow buttons\n-- x and y go from -1 to 1, and stay at 0 if nothing is pressed\ntype alias Keys = { x : Int, y : Int }\n\nupdate : Float -\x26gt; Keys -\x26gt; Ship -\x26gt; Ship\nupdate dt keys ship =\n  let newVel      = toFloat keys.x  -- `let` defines local variables for `in`\n      isShooting  = keys.y \x26gt; 0\n  in  updateVelocity newVel (updateShooting isShooting (applyPhysics dt ship))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在，假设我只是调用 \x3ccode\x3eupdate\x3c\/code\x3e 30 次每分钟，传给他距离上次更新的时间差、被按下的键和先前的 \x3ccode\x3eship\x3c\/code\x3e，我已经有了一个完美的小游戏模型了。除了我看不到任何东西，因为没有进行渲染... 但是理论上它是可行的。\x3c\/p\x3e\n\x3cp\x3e让我们来总结一下目前为止发生了什么。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ealiases 类型定义了数据模型\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e所有数据是不可变的\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e类型标记分清了函数的目标\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e所有函数都是纯函数的\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e事实上，这个预览里根本没有办法意外地改变状态。也没有任何循环。\x3c\/p\x3e\n\x3cp\x3e我已经讲了很多关于这个游戏的底层的东西。定义了一个 model 和所有用于更新它的函数。唯一的麻烦是所有函数依赖于飞船的上一次更新。记住，在 Elm 里，任何情况下，你都不能在共享的作用域中保存状态，包括当前的 module -- 没有办法改变任何已经定义过的东西。那么，如何在程序中改变一个状态呢？\x3c\/p\x3e\n\x3ch2\x3eII. 状态是 Immutable 曾经的样子\x3c\/h2\x3e\n\x3cp\x3e有一些毁三观的事情将要发生了。在面向对象编程中，程序的状态是分散在一些实例中的。这里的 \x3ccode\x3eShip\x3c\/code\x3e 是算是一个类，而且 \x3ccode\x3emyShip\x3c\/code\x3e 应该是这个类的实例。在程序运行的任何一个时间 \x3ccode\x3emyShip\x3c\/code\x3e 都知道自己的位置和其他属性。但在函数式编程中并不是这样，在程序运行时 \x3ccode\x3einitShip\x3c\/code\x3e 与刚开始时完全一样。为了得到当前的状态，我需要知道过去发生了什么。我需要使用那些事情作为参数传递给已经定义好的函数，只有这样我才能得到 \x3ccode\x3eShip\x3c\/code\x3e 当前应该处在的状态。这与曾经的玩法完全不同，所以我要详细讲解这个过程。\x3c\/p\x3e\n\x3ch4\x3e第一步\x3c\/h4\x3e\n\x3cp\x3e在刚开始时 \x3ccode\x3einitShip\x3c\/code\x3e 有一个默认的值： \x3ccode\x3e0, 0, False\x3c\/code\x3e。还有一些函数可以转换一个 \x3ccode\x3eShip\x3c\/code\x3e 成为另一个 \x3ccode\x3eShip\x3c\/code\x3e。详细地说，有个 \x3ccode\x3eupdate\x3c\/code\x3e 函数，它得到用户输入和一个 ship 返回一个更新过的 ship。我要再写一遍这个函数，所以你不用向上翻页找它了。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3eupdate : Float -\x26gt; Keys -\x26gt; Ship -\x26gt; Ship\nupdate dt keys ship =\n  let newVel      = toFloat keys.x\n      isShooting  = keys.y \x26gt; 0\n  in  updateVelocity newVel (updateShooting isShooting (applyPhysics dt ship))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果 \x3ccode\x3einitShip\x3c\/code\x3e 是这个 model 初始的状态，至少，我可以向前走一步了。Elm 程序定义了一个 \x3ccode\x3emain\x3c\/code\x3e 函数，整个程序通过它开始运行。所以，首先让我们试着显示 \x3ccode\x3einitShip\x3c\/code\x3e。我引入了 \x3ccode\x3eGraphics.Element\x3c\/code\x3e 库来调用 \x3ccode\x3eshow\x3c\/code\x3e 函数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3eimport Graphics.Element exposing (..)\n\n-- (other code)\nmain : Element\nmain = show initShip\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这给了我们\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e{ position = 0, shooting = False, velocity = 0 }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在，如果我想再前进一步，我可以在显示飞船之前调用一次 \x3ccode\x3eupdate\x3c\/code\x3e 函数。我试了一下，看到了 \x3ccode\x3ekeys\x3c\/code\x3e，所以左右键被按下时已经有效果了（\x3ccode\x3ex\x3c\/code\x3e 是 -1，\x3ccode\x3ey\x3c\/code\x3e 是 1）。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3edt = 100\nkeys = { x = -1, y = 1 }\nmain = show (update dt keys initShip)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们有了\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3e{ position = 0, shooting = True, velocity = -1 }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很好！搞定了！按下向上键时我的飞船开始射击了，并且它有一个负的速度说明向左键也被按下了。请注意这时 \x3ccode\x3eposition\x3c\/code\x3e 还没有改变。这是因为我定义的更新的顺序是：先应用物理属性，然后才更新其他属性。 \x3ccode\x3einitShip\x3c\/code\x3e 的速度是 0，所以改变物理值并没有移动它。\x3c\/p\x3e\n\x3ch4\x3eSignals\x3c\/h4\x3e\n\x3cp\x3e现在我希望你拿出一些时间来读一下 \x3ca href=\x22http:\/\/elm-lang.org\/guide\/reactivity#signals\x22 rel=\x22nofollow noreferrer\x22\x3eElm-lang 的 Signals\x3c\/a\x3e，如果你感兴趣，甚至可以看一两个关于 Elm Signals 的视频。从现在开始我假设你已经知道什么是 Signals 了。\x3c\/p\x3e\n\x3cp\x3e再来总结一下：一个 signal 就像一个 stream，在任何一个时间点，都有一个简单的值。所以一个鼠标点击的 signal 的计数永远是一个整数 - 换句话说，它是一个 \x3ccode\x3eSignal Int\x3c\/code\x3e 类型。如果我愿意，我也可以搞一个飞船的 signal: \x3ccode\x3eSignal Ship\x3c\/code\x3e，它可以一直保存着当前的 \x3ccode\x3eShip\x3c\/code\x3e。但是我需要重构之前所有的函数并记录下那些复杂的值，事实上是那些值的 signals... 所以我听从了来自 Elm-lang.org 的建议:\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e使用 signals 最常犯的错误是过多的使用它们。它会引诱你用 signals 做任何事情，但在你的代码中尽量不使用它们才是坠吼滴！\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e所以，我的飞船可以再前进一步，但是它没有那么令人激动了。我想要当我按下向左键时它向左移动，反之亦然。更重要的是，我要按向上键时发射子弹!\x3c\/p\x3e\n\x3cp\x3e事实上我已经用一种伟大的方法构建了我的 models 和逻辑，因为那里正好有个已经搞好的 signal 叫做 \x3ca href=\x22http:\/\/package.elm-lang.org\/packages\/elm-lang\/core\/2.0.1\/Time#fps\x22 rel=\x22nofollow noreferrer\x22\x3e\x3ccode\x3efps n\x3c\/code\x3e\x3c\/a\x3e, 它更新 \x3ccode\x3en\x3c\/code\x3e 次每秒。它告诉我们距离上次更新的时间差。这就是我需要的 \x3ccode\x3edt\x3c\/code\x3e。而且，还有一个内置的 signal 被称作 \x3ca href=\x22http:\/\/package.elm-lang.org\/packages\/elm-lang\/core\/2.0.1\/Keyboard#arrows\x22 rel=\x22nofollow noreferrer\x22\x3e\x3ccode\x3eKeyboard.arrows\x3c\/code\x3e\x3c\/a\x3e，它保存了当前的方向键信息跟我定义的 \x3ccode\x3eKeys\x3c\/code\x3e 完全一样。无论何时只要发生变化，这些都会被更新。\x3c\/p\x3e\n\x3cp\x3e好了，为了得到一个有趣的输入 signal，我会不得不联合这两个内置的 signals，以便 “当每次改变 \x3ccode\x3efps\x3c\/code\x3e 时，检查 \x3ccode\x3eKeyboard.arrows\x3c\/code\x3e 的状态，并报告它们两个的值”。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x22它们俩\x22 听起来像一个组合，\x3ccode\x3e(Float, Keys)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x22在每一次更新\x22 听起来像 \x3ca href=\x22http:\/\/package.elm-lang.org\/packages\/elm-lang\/core\/2.0.1\/Signal#sampleOn\x22 rel=\x22nofollow noreferrer\x22\x3e\x3ccode\x3eSignal.sampleOn\x3c\/code\x3e\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在代码中，这应该是下面这样：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3eimport Time exposing (..)\nimport Keyboard\n\n-- (other code)\ninputSignal : Signal (Float, Keys)\ninputSignal =\n  let delta = fps 30\n      -- map the two signals into a tuple signal\n      tuples = Signal.map2 (,) delta Keyboard.arrows\n  -- and update `inputSignal` whenever `delta` changes\n  in  Signal.sampleOn delta tuples\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e碉堡了，现在我需要做的是只是接通我的 \x3ccode\x3emain\x3c\/code\x3e 以使得用户输入能真正的被 \x3ccode\x3eupdate\x3c\/code\x3e 函数获得到。为了实现它，我需要 \x3ccode\x3eSignal.foldp\x3c\/code\x3e，或者想个办法\x22抱紧过去\x22。这个跟搞个简单的 fold 差不多:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3esummed = List.foldl (\x2b) 0 [1,2,3,4,5]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们从 0 开始，然后把它加上 1，再加上 2，以此类推，直到所有的数字被加在一起，最后我们得到返回值为 15。\x3c\/p\x3e\n\x3cp\x3e简单的说，这个很有意义。\x3ccode\x3efoldp\x3c\/code\x3e 一直记录着 \x22开始时间\x22 的值，并且整合所有 signal 的过去状态，直到当前这一刻 -- 整个应用完整的过去一步一步迭代到当前的状态。\x3cbr\x3e我的天.. 让我喘口气。好了，至少现在好点了。\x3c\/p\x3e\n\x3cp\x3e无论怎样，让我们看看它在代码中是什么样的。现在，既然我有了 \x3ccode\x3emain\x3c\/code\x3e 函数来更新它的结果，它应该也会在它的类型上反映出来，所以我会用一个 \x3ccode\x3eSignal Element\x3c\/code\x3e 代替之前的 \x3ccode\x3eElement\x3c\/code\x3e。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3emain : Signal Element\nmain = Signal.map show (Signal.foldp update initShip inputSignal)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里发生了一些事情：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e我使用 \x3ccode\x3eSignal.foldp\x3c\/code\x3e 来更新 signal，初始值是 \x3ccode\x3einitShip\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eFolding\x3c\/code\x3e 仍然返回一个 signal，因为它要继续更新 \x22folded 状态\x22。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e我使用 \x3ccode\x3eSignal.map\x3c\/code\x3e 把当前的 \x22folded 状态\x22 映射到 \x3ccode\x3eshow\x3c\/code\x3e 中。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e只做这些会导致类型错误，尾部会有下面的报错：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode\x3eType mismatch between the following types on line 49, column 38 to 44:\n\n       Temp9243.Ship -\x26gt; Temp9243.Ship\n\n       Temp9243.Keys\n\n   It is related to the following expression:\n\n       update\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e呃... 好吧，至少我知道了问题出在哪里。我的函数的类型签名看上去像这样：\x3ccode\x3eupdate : Float -\x26gt; Keys -\x26gt; Ship -\x26gt; Ship\x3c\/code\x3e。然而，实际上我传给它的参数是 \x3ccode\x3e(Float, Keys)\x3c\/code\x3e 和 \x3ccode\x3eShip\x3c\/code\x3e。嗯，我只需要稍微修改下函数的签名...\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22elm\x22\x3eupdate : (Float, Keys) -\x26gt; Ship -\x26gt; Ship\nupdate (dt, keys) ship =\n  -- the same as before\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e... 嗒嗒，搞定了！ \x3cspan class=\x22emoji emoji-tada\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e我的游戏现在有了一个完整的函数模型，需要的更新和其他任何东西，一共才 50 行代码！完整的代码在这看： \x3ca href=\x22https:\/\/gist.github.com\/ohanhi\/0d3d83cf3f0d7bbea9db#file-game-elm\x22 rel=\x22nofollow noreferrer\x22\x3egame.elm\x3c\/a\x3e。若想要看它的效果，你可以复制粘贴到 \x3ca href=\x22http:\/\/elm-lang.org\/try\x22 rel=\x22nofollow noreferrer\x22\x3eTry Elm\x3c\/a\x3e 这个交互编辑器中（点击编译按钮按，在右边的屏幕上按下方向键)。\x3c\/p\x3e\n\x3cp\x3e再来总结一下刚才发生了什么：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e一个信号是一个时间的函数\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e每个时间点都对应着一个 signal 纯粹的值\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eSignal.foldp\x3c\/code\x3e 最后迭代出结果的原理与 \x3ccode\x3eList.foldl\x3c\/code\x3e 一样\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e程序的每个状态都是明确的起源于所有之前发生的事情\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2\x3eIII. 学到了什么\x3c\/h2\x3e\n\x3cp\x3e这些尝试让我学到了很多。我希望你也一样能有所收获。我个人的主观感觉是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e类型（Types）的确非常漂亮，而且有用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不可修改的数据结构（Immutability）和对全局状态的限制并没有听起来那么难以接受\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e函数式编程在 Elm 中非常简洁，可读性很强\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e函数式编程使输入和输出清晰明确\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e因为所有的这些关于状态的想法是那么的与众不同，它有些难以掌握，但是它确实很有意义\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e因为每个状态都是一个输入的直接结果，所以不需要担心那些混合了各种状态的 bug\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e响应式地监听各种更改, 而不是主动地触发修改，这种感觉很幸福\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e最后一句：\x3cem\x3e如果你喜欢这篇文章，请把它分享给你的好基友。分享就是真爱！\x3c\/em\x3e\x3c\/p\x3e\n\x3ch2\x3e附录: 术语表\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e不可变数据（Immutable data）\x3c\/strong\x3e 意思是一旦你给一个东西赋了值，它再也无法改变。拿 JavaScript 的 \x3ccode\x3eArray\x3c\/code\x3e 来举个反例。如果它是不可变的，\x3ccode\x3emyArray.push(item)\x3c\/code\x3e 就无法修改 \x3ccode\x3emyArray\x3c\/code\x3e 已有的值，但它会返回一个新的追加了一个值的数组。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e强类型\x3c\/strong\x3e 这种编程语言试图防止不可预知的行为导致的错误发生，例如：把一个字符串赋值为一个整数。当出现类型不匹配时 Scala、Haskell 和 Elm 这些语言使用 \x3ca href=\x22http:\/\/en.wikipedia.org\/wiki\/Strong_and_weak_typing#Static_type-checking\x22 rel=\x22nofollow noreferrer\x22\x3e静态类型检查\x3c\/a\x3e 来阻止编译通过。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e纯函数（Pure functions）\x3c\/strong\x3e 给相同的输入永远给出相同的输出，而且没有任何副作用的函数。本质上，这些函数绝对不能依赖输入参数之外的任何东西，并且它不能修改任何东西。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e函数式编程\x3c\/strong\x3e 特指以纯函数为主要表现形式的一种编程范式。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e响应编程（Reactive programming）\x3c\/strong\x3e 概括地说就是组件可以被监听，并且根据事件做出所需要的反应。在 Elm 中，这些可被监听的东西是 signals。使用 signal 的组件知道如何利用它，但是 signal 完全不知道组件或组件们的存在。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>笨办法学函数式编程：Elm 初体验</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000004886629">https://segmentfault.com/a/1190000004886629</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/7wvxkyaw52a/" target="_blank">https://alili.tech/archive/7wvxkyaw52a/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>