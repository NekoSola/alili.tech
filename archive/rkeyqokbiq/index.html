<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="深析filemap.js——关于JS的算法及优化的实践"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>深析filemap.js——关于JS的算法及优化的实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/rkeyqokbiq/",
				"appid": "1613049289050283", 
				"title": "深析filemap.js——关于JS的算法及优化的实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-07T02:30:15"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/6qk3uhezdwj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/jisk6hsev3/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2frkeyqokbiq%2f&text=%e6%b7%b1%e6%9e%90filemap.js%e2%80%94%e2%80%94%e5%85%b3%e4%ba%8eJS%e7%9a%84%e7%ae%97%e6%b3%95%e5%8f%8a%e4%bc%98%e5%8c%96%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2frkeyqokbiq%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2frkeyqokbiq%2f&text=%e6%b7%b1%e6%9e%90filemap.js%e2%80%94%e2%80%94%e5%85%b3%e4%ba%8eJS%e7%9a%84%e7%ae%97%e6%b3%95%e5%8f%8a%e4%bc%98%e5%8c%96%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2frkeyqokbiq%2f&title=%e6%b7%b1%e6%9e%90filemap.js%e2%80%94%e2%80%94%e5%85%b3%e4%ba%8eJS%e7%9a%84%e7%ae%97%e6%b3%95%e5%8f%8a%e4%bc%98%e5%8c%96%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2frkeyqokbiq%2f&is_video=false&description=%e6%b7%b1%e6%9e%90filemap.js%e2%80%94%e2%80%94%e5%85%b3%e4%ba%8eJS%e7%9a%84%e7%ae%97%e6%b3%95%e5%8f%8a%e4%bc%98%e5%8c%96%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b7%b1%e6%9e%90filemap.js%e2%80%94%e2%80%94%e5%85%b3%e4%ba%8eJS%e7%9a%84%e7%ae%97%e6%b3%95%e5%8f%8a%e4%bc%98%e5%8c%96%e7%9a%84%e5%ae%9e%e8%b7%b5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2frkeyqokbiq%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2frkeyqokbiq%2f&title=%e6%b7%b1%e6%9e%90filemap.js%e2%80%94%e2%80%94%e5%85%b3%e4%ba%8eJS%e7%9a%84%e7%ae%97%e6%b3%95%e5%8f%8a%e4%bc%98%e5%8c%96%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frkeyqokbiq%2f&title=%e6%b7%b1%e6%9e%90filemap.js%e2%80%94%e2%80%94%e5%85%b3%e4%ba%8eJS%e7%9a%84%e7%ae%97%e6%b3%95%e5%8f%8a%e4%bc%98%e5%8c%96%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frkeyqokbiq%2f&title=%e6%b7%b1%e6%9e%90filemap.js%e2%80%94%e2%80%94%e5%85%b3%e4%ba%8eJS%e7%9a%84%e7%ae%97%e6%b3%95%e5%8f%8a%e4%bc%98%e5%8c%96%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frkeyqokbiq%2f&title=%e6%b7%b1%e6%9e%90filemap.js%e2%80%94%e2%80%94%e5%85%b3%e4%ba%8eJS%e7%9a%84%e7%ae%97%e6%b3%95%e5%8f%8a%e4%bc%98%e5%8c%96%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">深析filemap.js——关于JS的算法及优化的实践</h1><div class="meta"><div class="postdate"><time datetime="2019-02-07" itemprop="datePublished">2019-02-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e项目地址：\x3ca href=\x22https:\/\/github.com\/jrainlau\/filemap\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e链接描述\x3c\/a\x3e\x3cbr\x3e项目简介：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000005968734\x22\x3ehttps:\/\/segmentfault.com\/a\/1190000005968734\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e关于项目的用法和介绍可以查看上面的两个链接，这篇文章主要内容是对\x3ccode\x3efilemap.js\x3c\/code\x3e的代码进行一步一步的分析，详细介绍其运行原理和优化策略。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e知识点准备：\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eNodeJS\x3c\/code\x3e的基本使用方法（主要是\x3ccode\x3efs\x3c\/code\x3e文件系统）；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eES6\x3c\/code\x3e特性及语法（\x3ccode\x3elet\x3c\/code\x3e, \x3ccode\x3econst\x3c\/code\x3e, \x3ccode\x3efor...of\x3c\/code\x3e, \x3ccode\x3earrow function\x3c\/code\x3e...）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3en叉树先序遍历算法\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e知识点1和2请自行查阅资料，现在对知识点3进行分析。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eN叉树先序遍历算法\x3c\/h2\x3e\n\x3cp\x3e首先明白什么是树。引用\x3ca href=\x22https:\/\/book.douban.com\/subject\/25945449\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e数据结构与算法JavaScript描述\x3c\/a\x3e：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzhGh\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzhGh\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e位于树顶部的节点叫作根节点（11）。它没有父节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点（7、5、9、15、13和20是内部节点）。没有子元素的节点称为外部节点或叶节点（3、6、8、10、12、14、18和25是叶节点）。\x3cbr\x3e一个节点可以有祖先和后代。一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7和节点11，后代有节点3和节点6。\x3cbr\x3e有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上图中树的一棵子树。\x3cbr\x3e节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节点（5、7和11），它的深度为3。\x3cbr\x3e树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它的子节点在第1层，以此类推。上图中的树的高度为3（最大高度已在图中表示——第3层）。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e对于一棵树的遍历，有\x3ccode\x3e先序\x3c\/code\x3e，\x3ccode\x3e中序\x3c\/code\x3e和\x3ccode\x3e后序\x3c\/code\x3e三种遍历方式，在本例中使用的是\x3ccode\x3e先序遍历\x3c\/code\x3e的方式。至于三种遍历方式的异同，请阅读\x3ca href=\x22https:\/\/book.douban.com\/subject\/25945449\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e数据结构与算法JavaScript描述\x3c\/a\x3e，里面有详细的介绍。\x3c\/p\x3e\n\x3cp\x3e首先我们创建一棵树：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let treeObj = {\n    \x271\x27: [\n        { \x272\x27: [{ \x275\x27: [{ \x2711\x27: \x2711\x27 }, { \x2712\x27: \x2712\x27 }, { \x2713\x27: \x2713\x27 }, { \x2714\x27: \x2714\x27 }] }] },\n        { \x273\x27: [{ \x276\x27: \x276\x27 }, { \x277\x27: \x277\x27 }] },\n        { \x274\x27: [{ \x278\x27: \x278\x27 }, { \x279\x27: \x279\x27 }, { \x2710\x27: \x2710\x27 }] }\n    ]\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xquery\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e treeObj = {\n    \x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e: [\n        { \x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e: [{ \x3cspan class=\x22hljs-string\x22\x3e\x275\x27\x3c\/span\x3e: [{ \x3cspan class=\x22hljs-string\x22\x3e\x2711\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x2711\x27\x3c\/span\x3e }, { \x3cspan class=\x22hljs-string\x22\x3e\x2712\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x2712\x27\x3c\/span\x3e }, { \x3cspan class=\x22hljs-string\x22\x3e\x2713\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x2713\x27\x3c\/span\x3e }, { \x3cspan class=\x22hljs-string\x22\x3e\x2714\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x2714\x27\x3c\/span\x3e }] }] },\n        { \x3cspan class=\x22hljs-string\x22\x3e\x273\x27\x3c\/span\x3e: [{ \x3cspan class=\x22hljs-string\x22\x3e\x276\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x276\x27\x3c\/span\x3e }, { \x3cspan class=\x22hljs-string\x22\x3e\x277\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x277\x27\x3c\/span\x3e }] },\n        { \x3cspan class=\x22hljs-string\x22\x3e\x274\x27\x3c\/span\x3e: [{ \x3cspan class=\x22hljs-string\x22\x3e\x278\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x278\x27\x3c\/span\x3e }, { \x3cspan class=\x22hljs-string\x22\x3e\x279\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x279\x27\x3c\/span\x3e }, { \x3cspan class=\x22hljs-string\x22\x3e\x2710\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x2710\x27\x3c\/span\x3e }] }\n    ]\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了简单方便，我把它的key和value都设置成了相同的值。在例子中我们使用的都是key值。\x3cbr\x3e然后分析\x3ccode\x3e先序遍历\x3c\/code\x3e的原理：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzbdS\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzbdS\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e虚线为遍历顺序，可以看出\x3ccode\x3e先序遍历\x3c\/code\x3e可以得到整棵树的结构，这正是我们所需要的。接下来看代码如何实现。先看完整代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let traverseNode = (node, deep) =\x3e {\n    if (typeof node !== \x27string\x27) {\n        let key = Object.keys(node)\n        console.log(key, deep)\n        for (let i = 0; i \x3c node[key].length; i\x2b\x2b) {\n            traverseNode(node[key][i], deep \x2b 1)\n        }\n    }\n}\n\ntraverseNode(treeObj, 1)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3elet traverseNode = (\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e, deep\x3c\/span\x3e) =\x26gt; {\n    if (typeof \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e!== \x27string\x3c\/span\x3e\x27) {\n        let key = Object.keys(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e)\n        console\x3c\/span\x3e.log(key, deep)\n        for (let i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x3cspan class=\x22hljs-tag\x22\x3e\x26lt; node[key].length; i\x2b\x2b) {\n            traverseNode(node[key][i], deep \x2b 1)\n        }\n    }\n}\n\ntraverseNode(treeObj, 1)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们创建了一个\x3ccode\x3etraverseNode()\x3c\/code\x3e函数，它接收两个对象作为参数。\x3ccode\x3enode\x3c\/code\x3e参数为传入的节点，\x3ccode\x3edeep\x3c\/code\x3e参数为节点的起始深度。\x3cbr\x3e首先使用\x3ccode\x3eObject.keys(obj)\x3c\/code\x3e方法取得节点的key值，同时输出深度值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let key = Object.keys(node)\nconsole.log(key, deep)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode\x3elet key = Object.keys(\x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e)\nconsole\x3c\/span\x3e.log(key, deep)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e运行，在控制台将会输出\x3ccode\x3e[ \x271\x27 ] 1\x3c\/code\x3e。接下来我们使用递归来重复这个过程，进行完整的遍历运算：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (let i = 0; i \x3c node[key].length; i\x2b\x2b) {\n    traverseNode(node[key][i], deep \x2b 1)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs matlab\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let \x3cspan class=\x22hljs-built_in\x22\x3ei\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-built_in\x22\x3ei\x3c\/span\x3e \x26lt; node[key].\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; \x3cspan class=\x22hljs-built_in\x22\x3ei\x3c\/span\x3e\x2b\x2b) {\n    traverseNode(node[key][i], deep \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个递归就是我们前文一直在说的\x3ccode\x3e先序遍历\x3c\/code\x3e。对于\x3ccode\x3e二叉树\x3c\/code\x3e：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。\x3cbr\x3e先序遍历会先访问节点本身，然后再访问它的左侧子节点，最后是右侧子节点。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVzhIi\x22 src=\x22https:\/\/static.alili.tech\/img\/bVzhIi\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e在理解完上面这段话以后，不难把\x3ccode\x3e先序遍历\x3c\/code\x3e的思路扩展到\x3ccode\x3en叉树\x3c\/code\x3e：先访问节点本身，然后从左到右访问它的n个子节点。\x3cbr\x3e每一次完整的for循环都意味着“往下走一层”，所以只需要\x3ccode\x3edeep \x2b 1\x3c\/code\x3e即可知道每一个节点对应的深度。\x3c\/p\x3e\n\x3cp\x3e在本例子的遍历过程中，\x3ccode\x3enode\x3c\/code\x3e都是一个个的对象而非字符串。如果检测到\x3ccode\x3enode\x3c\/code\x3e为字符串，证明其已经到了最后一层，需要停止，否则会无限循环导致溢出，所以我们需要添加一个判断：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (typeof node !== \x27string\x27)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs crmsh\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eif (typeof \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e!== \x27string\x3c\/span\x3e\x27)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e大功告成，现在我们尝试运行一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[ \x271\x27 ] 1\n[ \x272\x27 ] 2\n[ \x275\x27 ] 3\n[ \x2711\x27 ] 4\n[ \x2712\x27 ] 4\n[ \x2713\x27 ] 4\n[ \x2714\x27 ] 4\n[ \x273\x27 ] 2\n[ \x276\x27 ] 3\n[ \x277\x27 ] 3\n[ \x274\x27 ] 2\n[ \x278\x27 ] 3\n[ \x279\x27 ] 3\n[ \x2710\x27 ] 3\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scheme\x22\x3e\x3ccode\x3e[ \x3cspan class=\x22hljs-symbol\x22\x3e\x271\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x272\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x275\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x2711\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x2712\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x2713\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x2714\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x273\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x276\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x277\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x274\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x278\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x279\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n[ \x3cspan class=\x22hljs-symbol\x22\x3e\x2710\x3c\/span\x3e\x27 ] \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e完美。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3efilemap.js原理\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3efilemap.js\x3c\/code\x3e通过遍历一个文件夹内部的所有子文件和子文件夹，输出其目录结构。我们使用\x3ccode\x3efs\x3c\/code\x3e文件系统来进行。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后来构造核心部分代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 判断类型。若该路径对应的是文件夹则返回true，否则返回false\nlet isDic = (url) =\x3e fs.statSync(url).isDirectory()\n\nconst traverseFiles = (path, deep) =\x3e {\n  let files = fs.readdirSync(path)\n  for (let i = 0, len = files.length; i \x3c len; i\x2b\x2b) {\n    if (files[i] !== \x27filemap.js\x27) console.log(deep, files[i], \x27\\n\x27) \/\/ 忽略filemap.js本身\n    let dirPath = path \x2b \x27\\\\\x27 \x2b files[i]\n    \/\/ 当且仅当是文件夹时才进行下一轮遍历\n    if (isDic(dirPath)) traverseFiles(dirPath, deep \x2b 1)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断类型。若该路径对应的是文件夹则返回true，否则返回false\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e isDic = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eurl\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e fs.statSync(url).isDirectory()\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e traverseFiles = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3epath, deep\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e files = fs.readdirSync(path)\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, len = files.length; i \x26lt; len; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (files[i] !== \x3cspan class=\x22hljs-string\x22\x3e\x27filemap.js\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(deep, files[i], \x3cspan class=\x22hljs-string\x22\x3e\x27\\n\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 忽略filemap.js本身\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dirPath = path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\\\\\x27\x3c\/span\x3e \x2b files[i]\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当且仅当是文件夹时才进行下一轮遍历\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDic(dirPath)) traverseFiles(dirPath, deep \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e文件目录结构其实就是一棵典型的\x3ccode\x3en叉树\x3c\/code\x3e，通过前文的例子，不难明白这段代码的原理。首先通过\x3ccode\x3efs.readdirSync(path)\x3c\/code\x3e同步地获取某路径对应的所有文件（夹），然后进行递归。可以把它理解为从第二层开始遍历，所以在写法上和前文例子稍有不同。\x3c\/p\x3e\n\x3cp\x3e现在我们已经可以获取文件及其所在的深度了，接下来就是对这些信息进行格式化，使其输出更加直观。为了输出类似\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22|__folder\n    |__file1\n    |__file2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e|__folder\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e|__file1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-string\x22\x3e|__file2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的树状结构，我们需要判断不同的深度对应的缩进，所以我们来定义一个\x3ccode\x3eplaceHolder()\x3c\/code\x3e函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const placeHolder = (num) =\x3e {\n  if (placeHolder.cache[num]) return placeHolder.cache[num] \x2b \x27|__\x27\n  placeHolder.cache[num] = \x27\x27\n  for (let i = 0; i \x3c num; i\x2b\x2b) {\n    placeHolder.cache[num] \x2b= \x27  \x27\n  }\n  return placeHolder.cache[num] \x2b \x27|__\x27\n}\nplaceHolder.cache = {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e placeHolder = (\x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (placeHolder.cache[\x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e]) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e placeHolder.cache[\x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27|__\x27\x3c\/span\x3e\n  placeHolder.cache[\x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e] = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e; i\x2b\x2b) {\n    placeHolder.cache[\x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e] \x2b= \x3cspan class=\x22hljs-string\x22\x3e\x27  \x27\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e placeHolder.cache[\x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27|__\x27\x3c\/span\x3e\n}\nplaceHolder.cache = {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里涉及到一个\x3ccode\x3e缓存函数执行结果\x3c\/code\x3e的优化策略。由于该函数多次被使用，如果每一次都是从头开始进行for循环，在性能上有着巨大的浪费。所以我们可以把它的执行结果缓存起来，当以后遇到相同情况时只需要取出缓存的结果即可，无需重新运算，大大提升了性能。\x3c\/p\x3e\n\x3cp\x3e现在我们把核心代码改写一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let isDic = (url) =\x3e fs.statSync(url).isDirectory()\n\nconst traverseFiles = (path, deep) =\x3e {\n  let files = fs.readdirSync(path)\n  for (let i = 0, len = files.length; i \x3c len; i\x2b\x2b) {\n    if (files[i] !== \x27filemap.js\x27) console.log(placeHolder(deep), files[i], \x27\\n\x27) \/\/ 忽略filemap.js本身\n    let dirPath = path \x2b \x27\\\\\x27 \x2b files[i]\n    if (isDic(dirPath)) traverseFiles(dirPath, deep \x2b 1)\n  }\n}\n\ntraverseFiles(\x27.\/\x27, 1)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e isDic = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eurl\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e fs.statSync(url).isDirectory()\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e traverseFiles = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3epath, deep\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e files = fs.readdirSync(path)\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, len = files.length; i \x26lt; len; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (files[i] !== \x3cspan class=\x22hljs-string\x22\x3e\x27filemap.js\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(placeHolder(deep), files[i], \x3cspan class=\x22hljs-string\x22\x3e\x27\\n\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 忽略filemap.js本身\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dirPath = path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\\\\\x27\x3c\/span\x3e \x2b files[i]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDic(dirPath)) traverseFiles(dirPath, deep \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n  }\n}\n\ntraverseFiles(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在根目录中运行\x3ccode\x3enode filemap.js\x3c\/code\x3e，我们就能够得到完美的文件目录树状结构图了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e功能进一步扩展\x3c\/h2\x3e\n\x3cp\x3e现在是“无差别”地对所有文件夹进行展开。如果想要忽略某些文件夹，比如\x3ccode\x3e.git\x3c\/code\x3e或者\x3ccode\x3enode_modules\x3c\/code\x3e之类的文件夹，应该如何做呢？参考命令行输入参数的方法，这个需求不难实现。\x3cbr\x3e首先获取需要忽略的文件夹名：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let ignoreCase = {}\nif(process.argv[2] === \x27-i\x27){\n    for (let i of process.argv.slice(3)) {\n      ignoreCase[i] = true\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3elet ignoreCase = {}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eif\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(process.argv[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e] === \x3cspan class=\x22hljs-string\x22\x3e\x27-i\x27\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e of process\x3cspan class=\x22hljs-selector-class\x22\x3e.argv\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.slice\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)) {\n      ignoreCase[i] = true\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eignoreCase\x3c\/code\x3e保存着需要忽略的文件夹名。这里使用对象而不是数组的原因是，当判断一个\x3ccode\x3eitem\x3c\/code\x3e是否被已经被保存的时候，\x3ccode\x3eitem.indexOf(Array)\x3c\/code\x3e的效率并没有\x3ccode\x3eObject[item]\x3c\/code\x3e来得高。使用\x3ccode\x3efor...of\x3c\/code\x3e循环能够直接取得对象。\x3c\/p\x3e\n\x3cp\x3e接下来我们可以在核心代码中多加一个判断：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let isDic = (url) =\x3e fs.statSync(url).isDirectory()\n\nconst traverseFiles = (path, deep) =\x3e {\n  let files = fs.readdirSync(path)\n  let con = false\n  for (let i = 0, len = files.length; i \x3c len; i\x2b\x2b) {\n    if (files[i] !== \x27filemap.js\x27) console.log(placeHolder(deep), files[i], \x27\\n\x27)\n    con = ignoreCase[files[i]] === undefined? true: false\n    let dirPath = path \x2b \x27\\\\\x27 \x2b files[i]\n    if (isDic(dirPath) \x26amp;\x26amp; con) traverseFiles(dirPath, deep \x2b 1)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e isDic = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eurl\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e fs.statSync(url).isDirectory()\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e traverseFiles = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3epath, deep\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e files = fs.readdirSync(path)\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e con = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, len = files.length; i \x26lt; len; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (files[i] !== \x3cspan class=\x22hljs-string\x22\x3e\x27filemap.js\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(placeHolder(deep), files[i], \x3cspan class=\x22hljs-string\x22\x3e\x27\\n\x27\x3c\/span\x3e)\n    con = ignoreCase[files[i]] === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e? \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dirPath = path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\\\\\x27\x3c\/span\x3e \x2b files[i]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDic(dirPath) \x26amp;\x26amp; con) traverseFiles(dirPath, deep \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e被忽略的文件夹将不会进行递归运算。\x3cbr\x3e最后别忘了在退出进程：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22process.exit()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eprocess.\x3cspan class=\x22hljs-keyword\x22\x3eexit\x3c\/span\x3e()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至此，完整的\x3ccode\x3efilemap.js\x3c\/code\x3e已经完成，其所有代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * @author Jrain Lau\n * @email jrainlau@163.com\n * @date 2016-07-14\n *\/\n \n\x27use strict\x27\nconst fs = require(\x27fs\x27)\n\nlet ignoreCase = {}\nif(process.argv[2] === \x27-i\x27){\n    for (let i of process.argv.slice(3)) {\n      ignoreCase[i] = true\n    }\n}\n\nconsole.log(\x27\\n\\nThe files tree is:\\n=================\\n\\n\x27)\n\nconst placeHolder = (num) =\x3e {\n  if (placeHolder.cache[num]) return placeHolder.cache[num] \x2b \x27|__\x27\n  placeHolder.cache[num] = \x27\x27\n  for (let i = 0; i \x3c num; i\x2b\x2b) {\n    placeHolder.cache[num] \x2b= \x27  \x27\n  }\n  return placeHolder.cache[num] \x2b \x27|__\x27\n}\nplaceHolder.cache = {}\n\nlet isDic = (url) =\x3e fs.statSync(url).isDirectory()\n\nconst traverseFiles = (path, deep) =\x3e {\n  let files = fs.readdirSync(path)\n  let con = false\n  for (let i = 0, len = files.length; i \x3c len; i\x2b\x2b) {\n    if (files[i] !== \x27filemap.js\x27) console.log(placeHolder(deep), files[i], \x27\\n\x27)\n    con = ignoreCase[files[i]] === undefined? true: false\n    let dirPath = path \x2b \x27\\\\\x27 \x2b files[i]\n    if (isDic(dirPath) \x26amp;\x26amp; con) traverseFiles(dirPath, deep \x2b 1)\n  }\n}\n\ntraverseFiles(\x27.\/\x27, 1)\n\nprocess.exit()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * @author Jrain Lau\n * @email jrainlau@163.com\n * @date 2016-07-14\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e \n\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e ignoreCase = {}\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(process.argv[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e] === \x3cspan class=\x22hljs-string\x22\x3e\x27-i\x27\x3c\/span\x3e){\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e process.argv.slice(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)) {\n      ignoreCase[i] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    }\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27\\n\\nThe files tree is:\\n=================\\n\\n\x27\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e placeHolder = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3enum\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (placeHolder.cache[num]) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e placeHolder.cache[num] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27|__\x27\x3c\/span\x3e\n  placeHolder.cache[num] = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; num; i\x2b\x2b) {\n    placeHolder.cache[num] \x2b= \x3cspan class=\x22hljs-string\x22\x3e\x27  \x27\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e placeHolder.cache[num] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27|__\x27\x3c\/span\x3e\n}\nplaceHolder.cache = {}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e isDic = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eurl\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e fs.statSync(url).isDirectory()\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e traverseFiles = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3epath, deep\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e files = fs.readdirSync(path)\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e con = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, len = files.length; i \x26lt; len; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (files[i] !== \x3cspan class=\x22hljs-string\x22\x3e\x27filemap.js\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(placeHolder(deep), files[i], \x3cspan class=\x22hljs-string\x22\x3e\x27\\n\x27\x3c\/span\x3e)\n    con = ignoreCase[files[i]] === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e? \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dirPath = path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\\\\\x27\x3c\/span\x3e \x2b files[i]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDic(dirPath) \x26amp;\x26amp; con) traverseFiles(dirPath, deep \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n  }\n}\n\ntraverseFiles(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n\nprocess.exit()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用时只需要带上参数\x3ccode\x3e-i 文件夹1 文件夹2 ...\x3c\/code\x3e即可控制文件夹的展开与否。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e后记\x3c\/h2\x3e\n\x3cp\x3e在学习\x3ca href=\x22https:\/\/book.douban.com\/subject\/25945449\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e数据结构与算法JavaScript描述\x3c\/a\x3e的过程中，有时候真的觉得特别困，后来发挥自己喜欢折腾的个性，想办法把枯燥的东西进行实践，不知不觉就会变得有趣了。在\x3ccode\x3efilemap.js\x3c\/code\x3e的早期版本中有着许多bug和性能问题，比如不合理使用三元表达式，没有缓存函数执行结果，判断文件类型考虑不周等等情况。文中所涉及到的优化策略，有很多是来自他人的指点和一次次的修改才最终得出来的，在此非常感谢给予我帮助的人。\x3c\/p\x3e\n\x3cp\x3e最后感谢你的阅读。我是Jrain，欢迎关注\x3ca href=\x22https:\/\/segmentfault.com\/blog\/jrain\x22\x3e我的专栏\x3c\/a\x3e，将不定期分享自己的学习体验，开发心得，搬运墙外的干货。下次见啦！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>深析filemap.js——关于JS的算法及优化的实践</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005987714">https://segmentfault.com/a/1190000005987714</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/rkeyqokbiq/" target="_blank">https://alili.tech/archive/rkeyqokbiq/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>