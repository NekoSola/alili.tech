<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="浅析git"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>浅析git | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/irsx05cvpw/",
				"appid": "1613049289050283", 
				"title": "浅析git | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-14T02:30:37"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ih3uz00lojq/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ktv7qxcssoc/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2firsx05cvpw%2f&text=%e6%b5%85%e6%9e%90git"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2firsx05cvpw%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2firsx05cvpw%2f&text=%e6%b5%85%e6%9e%90git"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2firsx05cvpw%2f&title=%e6%b5%85%e6%9e%90git"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2firsx05cvpw%2f&is_video=false&description=%e6%b5%85%e6%9e%90git"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b5%85%e6%9e%90git&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2firsx05cvpw%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2firsx05cvpw%2f&title=%e6%b5%85%e6%9e%90git"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2firsx05cvpw%2f&title=%e6%b5%85%e6%9e%90git"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2firsx05cvpw%2f&title=%e6%b5%85%e6%9e%90git"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2firsx05cvpw%2f&title=%e6%b5%85%e6%9e%90git"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">浅析git</h1><div class="meta"><div class="postdate"><time datetime="2019-02-14" itemprop="datePublished">2019-02-14</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e浅析git\x3c\/h2\x3e\n\x3cblockquote\x3e笔者在此整理了常见的git命令，git的重要性无需多言，与其再百度海中搜索git命令，不妨尝试收藏笔者的此篇作品。希望对你的学习有所帮助。\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e版本控制系统之git\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3eGit:\x3c\/p\x3e\n\x3cp\x3e(一)简介：\x3cbr\x3eGit 是一款免费的、开源的、分布式的版本控制系统。旨在快速高效地处理无论规模大小的任何软件工程。\x3cbr\x3e每一个 Git克隆 都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。其最大特色就是“分支”及“合并”操作非常快速、简便。\x3c\/p\x3e\n\x3cp\x3e(二)Git与svn的主要区别:\x3cbr\x3eGit是分布式SCM，而SVN是基于服务器的，也就是说每个开发者本地都有一套git库，每个人维护自己的版本（或者合并其他人的版本），而SVN是每个人写完代码后都及时的checkin到服务器上，进行合并。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eGit的优势：\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e说到优势，那么自然是相对与SVN而言的\x3cbr\x3e1.版本库本地化，支持离线提交，相对独立不影响协同开发。每个开发者都拥有自己的版本控制库，在自己的版本库上可以任意的执行提交代码、创建分支等行为。例如，开发者认为自己提交的代码有问题？没关系，因为版本库是自己的，回滚历史、反复提交、归并分支并不会影响到其他开发者。\x3c\/p\x3e\n\x3cp\x3e2.更少的“仓库污染”。git对于每个工程只会产生一个.git目录，这个工程所有的版本控制信息都在这个目录中，不会像SVN那样在每个目录下都产生.svn目录。\x3c\/p\x3e\n\x3cp\x3e3.把内容按元数据方式存储，完整克隆版本库。所有版本信息位于.git目录中，它是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签、分支、版本记录等。\x3c\/p\x3e\n\x3cp\x3e4.支持快速切换分支方便合并，比较合并性能好。在同一目录下即可切换不同的分支，方便合并，且合并文件速度比SVN快。\x3c\/p\x3e\n\x3cp\x3e5.分布式版本库，无单点故障，内容完整性好。内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e本地创建git远程仓库：\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e我这里使用的是：centos7.2、并且在服务器中已经创建git账户；如果没有创建git账户的朋友，需要先创建git，并且在服务器端安装git\x3c\/p\x3e\n\x3cp\x3e1.在本地建立一个空白的git仓库:\x3cbr\x3eGit –bare init\x3cbr\x3e注：--bare参数相当与只创建一个空白的仓库，只包含记录版本库历史记录的.git目录下面的文件，不会包含实际项目源文件的拷贝;\x3c\/p\x3e\n\x3cp\x3e2.将本地创建的仓库添加到远程服务器，使用的linux上传命令；\x3cbr\x3eScp –r 文件夹 linux用户名@ip:\/文件目录\x3cbr\x3e如：scp –r gittest.git root@123.207.172.12:\/data.\/git      \x3cbr\x3e(这里是将本地的gittest.git文件夹拷贝到服务器中 \/data\/git文件夹下)\x3c\/p\x3e\n\x3cp\x3e3.此时可以直接将本地的gittest文件夹关联远程仓库，也可以在本地再次克隆git仓库；使用命令如下：\x3cbr\x3eGit clone git@123.207.172.15:\/data\/git\/gittest.git\x3c\/p\x3e\n\x3cp\x3e4.可以直接创建一个文件，进行上传测试；如:\x3cbr\x3ecd gittest 进入文件夹\x3cbr\x3evi app.js 然后随便输入字符，esc\x2bwq!进行保存退出；\x3cbr\x3e然后将操作添加至暂存区：\x3cbr\x3eGit add .\x3cbr\x3e创建本地仓库的版本：\x3cbr\x3eGit commit –m “haha”\x3cbr\x3e提交至远程服务器仓库：\x3cbr\x3eGit push origin master;\x3cbr\x3e注：如果此时出现此种错误：\x3cbr\x3eremote: error: insufficient permission for adding an object to repository database .\/objects\x3cbr\x3e这时注意自己的服务器git账户是否有写的权限；一般是因为git账户对gittest.git文件夹权限不够；此时登陆自己的服务器，给git账户进行权限的赋予；命令为：\x3cbr\x3eChown –R git:git \/data\/git\/gittest.git\x3cbr\x3e权限操作完毕后，再次进行本地仓库与远程仓库的同步，一般此时不再会进行报错；\x3cbr\x3e注：服务器git仓库的创建也可以直接在linux操作系统中进行；\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e本地git创建仓库与github的远程仓库相关联:\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e1.首先登陆github官网；进行注册、登录\x3c\/p\x3e\n\x3cp\x3e2.创建新的仓库\x3c\/p\x3e\n\x3cp\x3e3.在本地创建git仓库\x3c\/p\x3e\n\x3cp\x3emkdir githubtest\x3cbr\x3egit init\x3cbr\x3evi app.js\x3cbr\x3e注：https协议和ssh协议的区别就是每次远程操作都需要输入github的用户名和密码；\x3cbr\x3e4.https协议：\x3cbr\x3eGit remote add origin \x3ca href=\x22https:\/\/github.com\/misterguang\/githubtest.git\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/misterguan...\x3c\/a\x3e\x3cbr\x3eGit add .\x3cbr\x3eGit commit –m “haha”\x3cbr\x3eGit push –u origin master\x3cbr\x3e此时需要输入github的用户名和密码\x3c\/p\x3e\n\x3cp\x3e此时会报错: error: failed to push some refs to\x3cbr\x3e（此种原因一般为在github的远程仓库有文件，在本地仓库没有，所以此时应该先将远程仓库合并到本地仓库，再进行提交）\x3cbr\x3egit pull --rebase origin master\x3cbr\x3e注意：这里的rebase和merge的区别，简单理解，rebase在log中无分叉，而merge有\x3cbr\x3e再次提交，将会成功；\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3essh协议:\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e首先需要创建密钥\x3cbr\x3essh-keygen –t rsa –C 837990335@qq.com\x3cbr\x3e可以一路回车；\x3cbr\x3e(Enter file in which to save the key (\/c\/Users\/dream\/.ssh\/id_rsa):\x3cbr\x3e这里默认就可以，这是存放ssh密钥的路径)\x3c\/p\x3e\n\x3cp\x3e（Enter passphrase (empty for no passphrase):这里为ssh的密码，可以为空）\x3c\/p\x3e\n\x3cp\x3e然后到C:Users用户 .ssh中找到id_rsa.pub,然后复制里面的密钥到github\x3cbr\x3e例：C:Usersdream.ssh\x3cbr\x3e在github的ssh and gpg keys中new ssh key\x3cbr\x3eTitle为此ssh的标记\x3cbr\x3eKey为你本地的密钥\x3cbr\x3e测试下：\x3cbr\x3essh git@github.com\x3cbr\x3e如果输出You\x27ve successfully authenticated；说明链接成功；\x3cbr\x3e下面的操作跟https的一样：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eGit的分支管理:\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e查看本地分支：$ git branch\x3cbr\x3e查看远程分支：$ git branch -r\x3cbr\x3e创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支\x3cbr\x3e切换分支：$ git checkout [name]\x3cbr\x3e创建新分支并立即切换到新分支：$ git checkout -b [name]\x3cbr\x3e删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项\x3cbr\x3e合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并\x3cbr\x3e创建远程分支(本地分支push到远程)：$ git push origin [name]\x3cbr\x3e删除远程分支：$ git push origin :heads\/[name]\x26nbsp;或\x26nbsp;$ gitpush origin :[name]\x26nbsp;\x3c\/p\x3e\n\x3cp\x3e项目开发的分支：\x3cbr\x3eMaster:用于发布版本的分支；（用于大版本号更新时使用）\x3cbr\x3eDev：开发时的主分支；\x3cbr\x3eFeature：功能分支；（开发某个局部分支，从dev分支上分出来的）\x3cbr\x3eRelease：创建一个预发布分支（从dev分支上分出来，合并到master分支上，进行tag标注）\x3cbr\x3eBug：bug分支（从master分支上分出来，修改完毕后合并到master和dev分支）\x3c\/p\x3e\n\x3cp\x3e分支合并\x3cbr\x3e在git进行分支的合并时\x3cbr\x3e如果使用默认的fast-farward merge\x3cbr\x3e直接修改当前HEAD指针的指向然后再修改当前HEAD指针，说白了就是修改两个指针的指向，而并没有生成新的commit对象。\x3c\/p\x3e\n\x3cp\x3e如果使用—no-ff 进行合并\x3cbr\x3e这样会在master分支上创建一个版本；\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3egit如何解决代码冲突:\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e1.逻辑冲突\x3cbr\x3egit自动处理（合并\/应用补丁）成功，但是逻辑上是有问题的。\x3cbr\x3e比如另外一个人修改了文件名，但我还使用老的文件名，这种情况下自动处理是能成功的，但实际上是有问题的。\x3cbr\x3e又比如，函数返回值含义变化，但我还使用老的含义，这种情况自动处理成功，但可能隐藏着重大BUG。这种问题，主要通过自动化测试来保障。所以最好是能够写出比较完备的自动化测试用例。\x3cbr\x3e这种冲突的解决，就是做一次BUG修正。不是真正解决git报告的冲突。\x3cbr\x3e2.内容冲突\x3cbr\x3e两个用户修改了同一个文件的同一块区域，git会报告内容冲突。我们常见的都是这种，后面的解决办法也主要针对这种冲突。如图中是：app.js冲突:\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbiV8Z?w=552\x26amp;h=78\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbiV8Z?w=552\x26amp;h=78\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e然后手动修改冲突的文件:\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbiV88?w=479\x26amp;h=77\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbiV88?w=479\x26amp;h=77\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e再次进行文件的提交，版本的创建；\x3cbr\x3e3.树冲突\x3cbr\x3e文件名修改造成的冲突，称为树冲突。\x3cbr\x3e比如，a用户把app.js改名为master.js，b用户把app.js文件改名为test.js，那么b将这两个commit合并时，会产生冲突。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbiV9O?w=592\x26amp;h=66\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbiV9O?w=592\x26amp;h=66\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e此时打开文件，把需要的删除的文件删除掉即可，如把master.js删除掉；\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbiV90?w=590\x26amp;h=133\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbiV90?w=590\x26amp;h=133\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e然后，再次重新创建版本即可:\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3egit常用操作命令:\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e1.查看、添加、提交、删除、找回，重置修改文件\x3cbr\x3egit help \x26lt;command\x26gt; # 显示command的help\x3cbr\x3egit show # 显示某次提交的内容 git show $id\x3cbr\x3egit co -- \x26lt;file\x26gt; # 抛弃工作区修改\x3cbr\x3egit co . # 抛弃工作区修改\x3cbr\x3egit add \x26lt;file\x26gt; # 将工作文件修改提交到本地暂存区\x3cbr\x3egit add . # 将所有修改过的工作文件提交暂存区\x3cbr\x3egit rm \x26lt;file\x26gt; # 从版本库中删除文件\x3cbr\x3egit rm \x26lt;file\x26gt; --cached # 从版本库中删除文件，但不删除文件\x3cbr\x3egit reset \x26lt;file\x26gt; # 从暂存区恢复到工作文件\x3cbr\x3egit reset -- . # 从暂存区恢复到工作文件\x3cbr\x3egit reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改\x3cbr\x3egit ci \x26lt;file\x26gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am \x22some comments\x22\x3cbr\x3egit ci --amend # 修改最后一次提交记录\x3cbr\x3egit revert \x26lt;$id\x26gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象\x3cbr\x3egit revert HEAD # 恢复最后一次提交的状态\x3cbr\x3e2.查看文件diff\x3cbr\x3egit diff \x26lt;file\x26gt; # 比较当前文件和暂存区文件差异 git diff\x3cbr\x3egit diff \x26lt;id1\x26gt;\x26lt;id1\x26gt;\x26lt;id2\x26gt; # 比较两次提交之间的差异\x3cbr\x3egit diff \x26lt;branch1\x26gt;..\x26lt;branch2\x26gt; # 在两个分支之间比较\x3cbr\x3egit diff --staged # 比较暂存区和版本库差异\x3cbr\x3egit diff --cached # 比较暂存区和版本库差异\x3cbr\x3egit diff --stat # 仅仅比较统计信息\x3cbr\x3e3.查看提交记录\x3cbr\x3egit log git log \x26lt;file\x26gt; # 查看该文件每次提交记录\x3cbr\x3egit log -p \x26lt;file\x26gt; # 查看每次详细修改内容的diff\x3cbr\x3egit log -p -2 # 查看最近两次详细修改内容的diff\x3cbr\x3egit log --stat #查看提交统计信息\x3cbr\x3etig\x3cbr\x3eMac上可以使用tig代替diff和log，brew install tig\x3c\/p\x3e\n\x3cp\x3e4.查看、切换、创建和删除分支\x3cbr\x3egit br -r # 查看远程分支\x3cbr\x3egit br \x26lt;new_branch\x26gt; # 创建新的分支\x3cbr\x3egit br -v # 查看各个分支最后提交信息\x3cbr\x3egit br --merged # 查看已经被合并到当前分支的分支\x3cbr\x3egit br --no-merged # 查看尚未被合并到当前分支的分支\x3cbr\x3egit co \x26lt;branch\x26gt; # 切换到某个分支\x3cbr\x3egit co -b \x26lt;new_branch\x26gt; # 创建新的分支，并且切换过去\x3cbr\x3egit co -b \x26lt;new_branch\x26gt; \x26lt;branch\x26gt; # 基于branch创建新的new_branch\x3cbr\x3egit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除\x3cbr\x3egit co $id -b \x26lt;new_branch\x26gt; # 把某次历史提交记录checkout出来，创建成一个分支\x3cbr\x3egit br -d \x26lt;branch\x26gt; # 删除某个分支\x3cbr\x3egit br -D \x26lt;branch\x26gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)\x3cbr\x3e5.\x26nbsp;分支合并和rebase\x3cbr\x3egit merge \x26lt;branch\x26gt; # 将branch分支合并到当前分支\x3cbr\x3egit merge origin\/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交\x3cbr\x3egit rebase master \x26lt;branch\x26gt; # 将master rebase到branch，相当于： git co \x26lt;branch\x26gt; \x26amp;\x26amp; git rebase master \x26amp;\x26amp; git co master \x26amp;\x26amp; git merge \x26lt;branch\x26gt;\x3cbr\x3e6.\x26nbsp;Git补丁管理(方便在多台机器上开发同步时用)\x3cbr\x3egit diff \x26gt; ..\/sync.patch # 生成补丁\x3cbr\x3egit apply ..\/sync.patch # 打补丁\x3cbr\x3egit apply --check ..\/sync.patch #测试补丁能否成功\x3cbr\x3e7.\x26nbsp;Git暂存管理\x3cbr\x3egit stash # 暂存\x3cbr\x3egit stash list # 列所有stash\x3cbr\x3egit stash apply # 恢复暂存的内容\x3cbr\x3egit stash drop # 删除暂存区\x3cbr\x3e8.Git远程分支管理\x3cbr\x3egit pull # 抓取远程仓库所有分支更新并合并到本地\x3cbr\x3egit pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并\x3cbr\x3egit fetch origin # 抓取远程仓库更新\x3cbr\x3egit merge origin\/master # 将远程主分支合并到本地当前分支\x3cbr\x3egit co --track origin\/branch # 跟踪某个远程分支创建相应的本地分支\x3cbr\x3egit co -b \x26lt;local_branch\x26gt; origin\/\x26lt;remote_branch\x26gt; # 基于远程分支创建本地分支，功能同上\x3cbr\x3egit push # push所有分支\x3cbr\x3egit push origin master # 将本地主分支推到远程主分支\x3cbr\x3egit push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)\x3cbr\x3egit push origin \x26lt;local_branch\x26gt; # 创建远程分支， origin是远程仓库名\x3cbr\x3egit push origin \x26lt;local_branch\x26gt;:\x26lt;remote_branch\x26gt; # 创建远程分支\x3cbr\x3egit push origin :\x26lt;remote_branch\x26gt; #先删除本地分支(git br -d \x26lt;branch\x26gt;)，然后再push删除远程分支\x3cbr\x3e9.Git远程仓库管理\x3cbr\x3eGitHub\x3cbr\x3egit remote -v # 查看远程服务器地址和仓库名称\x3cbr\x3egit remote show origin # 查看远程服务器仓库状态\x3cbr\x3egit remote add origin git@ github:robbin\/robbin_site.git # 添加远程仓库地址\x3cbr\x3egit remote set-url origin git@ github.com:robbin\/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm \x26lt;repository\x26gt; # 删除远程仓库\x3cbr\x3e10.创建远程仓库\x3cbr\x3egit clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库\x3cbr\x3escp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上\x3cbr\x3emkdir robbin_site.git \x26amp;\x26amp; cd robbin_site.git \x26amp;\x26amp; git --bare init # 在服务器创建纯仓库\x3cbr\x3egit remote add origin git@ github.com:robbin\/robbin_site.git # 设置远程仓库地址\x3cbr\x3egit push -u origin master # 客户端首次提交\x3cbr\x3egit push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track\x3cbr\x3egit remote set-head origin master # 设置远程仓库的HEAD指向master分支\x3cbr\x3e也可以命令设置跟踪远程库和本地库\x3cbr\x3egit branch --set-upstream master origin\/master\x3cbr\x3egit branch --set-upstream develop origin\/develop\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e项目自动化:\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e现在的前端开发已经不再仅仅只是静态网页的开发了，日新月异的前端技术已经让前端代码的逻辑和交互效果越来越复杂，更加的不易于管理，模块化开发和预处理框架把项目分成若干个小模块，增加了最后发布的困难，没有一个统一的标准，让前端的项目结构千奇百怪。前端自动化构建在整个项目开发中越来越重要。\x3c\/p\x3e\n\x3cp\x3e(一)工具化\x3cbr\x3e在前端的技术栈发展过程中，出现了很多的工具，形成了工具化，能够用工具完成的绝不要手工完成，来帮助开发者提升效率。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e前端工作流工具： Gulp，Grunt\x3c\/li\x3e\n\x3cli\x3e前端js模块编译工具：Babel，Browserify，Webpack\x3c\/li\x3e\n\x3cli\x3e包管理器： npm，bower\x3c\/li\x3e\n\x3cli\x3e前端开发系列工具： livereload，数据mock，代码监控，代码检查。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e(二)工程化\x3cbr\x3e工程化是一个发展趋势，以工具化为基础。\x3c\/p\x3e\n\x3cp\x3e工程的核心是流程自动化，又称为构建，这些包括了：代码质量检测，代码压缩，代码合并，代码优化，代码编译，单元测试等等部分。构建就是把这些以工作流程的方式组合起来，然后用一个命令行运行这整个流程。它有点像批处理，但是是程序开发中使用的特殊批处理。\x3c\/p\x3e\n\x3cp\x3e(三)自动化\x3cbr\x3e自动化是以工程化为基础，是在流程自动化上更进一步的自动化。\x3cbr\x3e持续集成就是全自动化的一个终极体现。他的主要流程是：版本控制库 -\x26gt;构建 -\x26gt;测试 -\x26gt;报告.\x3c\/p\x3e\n\x3cp\x3e(四)代码规范\x3cbr\x3e代码规范可以提高代码的可阅读性和避免一些低级错误。为了将代码规范的检查放到前端开发工程中，各种前端语言都有对应的hint或者lint工具。\x3c\/p\x3e\n\x3cp\x3e(五)预处理\x3cbr\x3eSASS\x3cbr\x3e甚至为了避免这一点，引入了各种预编译语言，css的预编译less，现在流行的是sass，功能也更加强大，语法错误无法通过编译，来弥补css这种缺陷。\x3c\/p\x3e\n\x3cp\x3e(六)ES6\x3cbr\x3ejs的预处理语言也有很多，只是为了让有其他语言经验的开发者更容易的上手js的编码。\x3c\/p\x3e\n\x3cp\x3e因为浏览器的实现大多还是 ES5 的标准，为了使用最新的 ES6 语法，通常的做法是采用 Babel 将 ES6 编译为 ES5。\x3c\/p\x3e\n\x3cp\x3e(七)js模块化\x3cbr\x3eamd,cmd,common,es6\x3c\/p\x3e\n\x3cp\x3e(八)文件处理\x3cbr\x3e通常一个前端项目会分有一个 src 目录和 dist 目录， src 放置源码，dist 放置编译后的代码。所以在前端工程的流程中会涉及到文件的拷贝，删除，移动等流程。\x3c\/p\x3e\n\x3cp\x3e(九)开发效率\x3cbr\x3e通常的前端开发过程是，修改前端代码，调用命令编译代码，然后浏览器 F5 刷新。这个过程可以做到自动化，通过代码监控工具，指定要监控的目录和文件，如果对应文件有改变，调用编译工具编译源码，然后通过 livereload 自动刷新浏览器。 gulp-browserify也可以实现同样的功能。\x3c\/p\x3e\n\x3cp\x3e(十)数据的mock\x3cbr\x3e现代化前端项目开发大多是前后端分离的方式，也就是后端基本是提供 API 服务，在真实开发环境中，通常的问题是，后端 API 极其不稳定或者没开发，为了不阻碍前端的开发，通常的做法是，前后端先约定 API 接口定义，然后前端根据定义 mock 接口。\x3c\/p\x3e\n\x3cp\x3e(十一)前端工作流\x3cbr\x3e为了解决前端工程中复杂的流程，出现了很多开源前端流程处理工具。这些工作流工具不仅仅是其本身，都是一个流程生态体系，每个工具都涉及到对应的插件库，几乎我们能想到的前端工程问题都有对用的插件能够解决。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eGulp:\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3eGulp 是基于node.js的一个前端自动化构建工具，开发这可以使用它构建自动化工作流程（前端集成开发环境）。\x26nbsp;\x3cbr\x3e使用gulp你可以简化工作量，让你把重点放在功能的开发上，从而提高你的开发效率和工作质量。\x26nbsp;gulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快\x3c\/p\x3e\n\x3cp\x3e(一)安装：\x3cbr\x3e需要在全局或者项目中同时安装；\x3cbr\x3eCnpm install -g gulp \x3cbr\x3eCnpm install –save-dev gulp\x3c\/p\x3e\n\x3cp\x3e(二)配置文件\x3c\/p\x3e\n\x3cp\x3e使用gulpfile.js进行配置，基于gulp工作流的项目结构如下：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVbiWaU?w=139\x26amp;h=73\x22 src=\x22https:\/\/static.alili.tech\/img\/bVbiWaU?w=139\x26amp;h=73\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e(三)Api:\x3c\/p\x3e\n\x3cp\x3e1.gulp.src(globs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个\x26nbsp;Vinyl files\x26nbsp;的\x26nbsp;stream\x26nbsp;它可以被\x26nbsp;piped\x26nbsp;到别的插件中。文件的入口\x3cbr\x3eA.路径匹配：\x3cbr\x3e1)*\x26nbsp;            ：能匹配\x26nbsp;a.js,x.y,abc,abc\/,但不能匹配a\/b.js\x3cbr\x3e2)\x3cem\x3e.\x3c\/em\x3e\x26nbsp;            ：能匹配\x26nbsp;a.js,style.css,a.b,x.y\x3cbr\x3e3)\x3cem\x3e\/\x3c\/em\x3e\/*.js\x26nbsp;    ：能匹配\x26nbsp;a\/b\/c.js,x\/y\/z.js,不能匹配a\/b.js,a\/b\/c\/d.js\x3cbr\x3e4)**\x26nbsp;能匹配    ：\x26nbsp;abc,a\/b.js,a\/b\/c.js,x\/y\/z,x\/y\/z\/a.b,能用来匹配所有的目录和文件\x3cbr\x3e5)\x3cem\x3e*\/\x3c\/em\x3e.js\x26nbsp;    ：能匹配\x26nbsp;foo.js,a\/foo.js,a\/b\/foo.js,a\/b\/c\/foo.js\x3cbr\x3e6)a\/**\/z\x26nbsp;        ：能匹配\x26nbsp;a\/z,a\/b\/z,a\/b\/c\/z,a\/d\/g\/h\/j\/k\/z\x3cbr\x3e7)a\/\x3cstrong\x3eb\/z\x26nbsp;    ：能匹配\x26nbsp;a\/b\/z,a\/sb\/z,但不能匹配a\/x\/sb\/z,因为只有单\x3c\/strong\x3e单独出现才能匹配多级目录\x3cbr\x3e8)?.js\x26nbsp;        ：能匹配\x26nbsp;a.js,b.js,c.js\x3cbr\x3e9)a??\x26nbsp;            ：能匹配\x26nbsp;a.b,abc,但不能匹配ab\/,因为它不会匹配路径分隔符\x3cbr\x3e10)[xyz].js\x26nbsp;    ：只能匹配\x26nbsp;x.js,y.js,z.js,不会匹配xy.js,xyz.js等,整个中括号只代表一个字符\x3cbr\x3e11)\x3csup id=\x22fnref-1\x22\x3e\x3ca href=\x22#fn-1\x22 class=\x22footnote-ref\x22\x3e1\x3c\/a\x3e\x3c\/sup\x3e.js\x26nbsp;    ：能匹配\x26nbsp;a.js,b.js,c.js等,不能匹配x.js,y.js,z.js\x3c\/p\x3e\n\x3cp\x3eB.匹配多种文件\x3cbr\x3e\/\/使用数组的方式来匹配多种文件\x3cbr\x3egulp.src([\x27js\/\x3cem\x3e.js\x27,\x27css\/\x3c\/em\x3e.css\x27,\x27*.html\x27])\x3c\/p\x3e\n\x3cp\x3e2.gulp.dest(path[, options]) 能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。输出文件\x3cbr\x3e根路径：如果在src中不设置base时，所有的默认根路径，都是从出现匹配符的地方开始截取：\x3cbr\x3e如：\x3cbr\x3egulp.src(\x27app\/src\/\x3cem\x3e*\/\x3c\/em\x3e.css\x27) \/\/此时base的值为app\/src,也就是说它的base路径为app\/src\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 \/\/设该模式匹配到了文件 app\/src\/css\/normal.css\n.pipe(gulp.dest(\x27dist\x27)) \/\/用dist替换掉base路径，最终得到 dist\/css\/normal.css\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/设该模式匹配到了文件 app\/src\/css\/normal.css\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-class\x22\x3e.pipe\x3c\/span\x3e(gulp.dest(\x3cspan class=\x22hljs-string\x22\x3e\x27dist\x27\x3c\/span\x3e)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/用dist替换掉base路径，最终得到 dist\/css\/normal.css\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果增加base基路径：\x3c\/p\x3e\n\x3cp\x3egulp.src(script\/lib\/*.js, {base:\x27script\x27}) \/\/配置了base参数，此时base路径为script \/\/假设匹配到的文件为script\/lib\/jquery.js .pipe(gulp.dest(\x27build\x27)) \/\/此时生成的文件路径为 build\/lib\/jquery.js\x3cbr\x3e3.gulp.task(name[, deps], fn) 定义一个使用\x26nbsp;Orchestrator\x26nbsp;实现的任务（task）。\x3c\/p\x3e\n\x3cp\x3e1)参数：\x3cbr\x3eName：任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。\x3cbr\x3eDeps：类型：\x26nbsp;Array，一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。\x3cbr\x3eFn：该函数定义任务所要执行的一些操作。\x3c\/p\x3e\n\x3cp\x3e2)异步任务\x3cbr\x3eA.使用callback：\x3c\/p\x3e\n\x3cp\x3evar gulp = require(\x27gulp\x27);\x3cbr\x3e\/\/ 返回一个 callback，因此系统可以知道它什么时候完成\x3cbr\x3egulp.task(\x27one\x27, function(cb) {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 做一些事 -- 异步的或者其他的\ncb(err); \/\/ 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gcode\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 做一些事 -- 异步的或者其他的\x3c\/span\x3e\ncb\x3cspan class=\x22hljs-comment\x22\x3e(err)\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e});\x3cbr\x3e\/\/ 定义一个所依赖的 task 必须在这个 task 执行之前完成\x3cbr\x3egulp.task(\x27two\x27, [\x27one\x27], function() {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ \x27one\x27 完成后\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e 完成后\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e});\x3c\/p\x3e\n\x3cp\x3egulp.task(\x27default\x27, [\x27two\x27]);\x3c\/p\x3e\n\x3cp\x3eB.使用promise\x3c\/p\x3e\n\x3cp\x3evar gulp = require(\x27gulp\x27);\x3cbr\x3e\/\/ 返回一个 callback，因此系统可以知道它什么时候完成\x3cbr\x3egulp.task(\x27one\x27, function(cb) {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 做一些事 -- 异步的或者其他的\nreturn new Promise((res, rej) =\x3e {\n    setTimeout(() =\x3e {\n        res(1344)\n    }, 5000)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 做一些事 -- 异步的或者其他的\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Promise(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(res, rej)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        res(\x3cspan class=\x22hljs-number\x22\x3e1344\x3c\/span\x3e)\n    }, \x3cspan class=\x22hljs-number\x22\x3e5000\x3c\/span\x3e)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e});\x3cbr\x3e\/\/ 定义一个所依赖的 task 必须在这个 task 执行之前完成\x3cbr\x3egulp.task(\x27two\x27, [\x27one\x27], function() {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ \x27one\x27 完成后\nconsole.log(\x26quot;two开始\x26quot;)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27one\x27 完成后\x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22two开始\x22\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e});\x3c\/p\x3e\n\x3cp\x3egulp.task(\x27default\x27, [\x27two\x27]);\x3cbr\x3e注意：5s后才开始执行的two任务\x3c\/p\x3e\n\x3cp\x3e3)对于同步任务：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  gulp.task(\x27one\x27,function(cb){\n    var stream = gulp.src(\x27client\/**\/*.js\x27)\n        .pipe(dosomething()) \/\/dosomething()中有某些异步操作\n        .pipe(gulp.dest(\x27build\x27));\n      return stream;\n  });\n  \n  gulp.task(\x27two\x27,[\x27one\x27],function(){\n    console.log(\x27two is done\x27);\n  });\n\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  gulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecb\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stream = gulp.src(\x3cspan class=\x22hljs-string\x22\x3e\x27client\/**\/*.js\x27\x3c\/span\x3e)\n        .pipe(dosomething()) \x3cspan class=\x22hljs-comment\x22\x3e\/\/dosomething()中有某些异步操作\x3c\/span\x3e\n        .pipe(gulp.dest(\x3cspan class=\x22hljs-string\x22\x3e\x27build\x27\x3c\/span\x3e));\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e stream;\n  });\n  \n  gulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27two\x27\x3c\/span\x3e,[\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e],\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27two is done\x27\x3c\/span\x3e);\n  });\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e4.gulp.watch(glob[, opts], tasks)监视文件，并且可以在文件发生改动时做一些事情；\x3cbr\x3e1)监听文件改变，并执行相应的task任务\x3cbr\x3evar watcher = gulp.watch(\x27js\/\x3cem\x3e*\/\x3c\/em\x3e.js\x27, [\x27uglify\x27, \x27reload\x27]);\x3cbr\x3ewatcher.on(\x27change\x27, function(event) {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(\x27File \x27 \x2b event.path \x2b \x27 was \x27 \x2b event.type \x2b \x27, running tasks...\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mel\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econsole.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27File \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 was \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.type \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27, running tasks...\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e});\x3c\/p\x3e\n\x3cp\x3e2)监听文件改变，并执行回调函数\x3c\/p\x3e\n\x3cp\x3egulp.watch(\x27js\/\x3cem\x3e*\/\x3c\/em\x3e.js\x27, function(event) {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(\x27File \x27 \x2b event.path \x2b \x27 was \x27 \x2b event.type \x2b \x27, running tasks...\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mel\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econsole.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27File \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 was \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.type \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27, running tasks...\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e});\x3c\/p\x3e\n\x3cp\x3e(四)第三方插件：\x3c\/p\x3e\n\x3cp\x3e1.gulp-load-plugins：用来加载插件，避免我们再头部声明一堆插件，做到想用就用\x3cbr\x3e2.less：用于编译 .less文件\x3cbr\x3e3.autoprefixer：自动添加css前缀\x3cbr\x3e4.babel：es6 编译成 es5\x3cbr\x3e5.uglify：JS压缩\x3cbr\x3e6.minify：CSS压缩\x3cbr\x3e7.rename：重命名\x3cbr\x3e8.sourcemaps：资源映射\x3cbr\x3e9.concat：合并文件\x3cbr\x3e10.del：删除文件、文件夹\x3cbr\x3e11.inject：文件注入\x3cbr\x3e12.notify：提示信息\x3cbr\x3e13.browser-sync：热启动\x3cbr\x3e14.http-proxy-middleware：配合browser-sync进行跨域\x3cbr\x3e15.changed：只有发生了改变的文件才能进入流中\x3cbr\x3e16.sequence：让task按顺序完成\x3cbr\x3e17.rev：添加MD5\x3cbr\x3e18.watch：监听文件变化\x3c\/p\x3e\n\x3cp\x3e(五)实现项目自动化构建：\x3c\/p\x3e\n\x3cp\x3e使用gulp构建项目，项目中支持：\x3cbr\x3e1)js的模块化（可以实现模块化（common与require的切换））；\x3cbr\x3e2)sass的编译；\x3cbr\x3e3)jslint的代码校验；\x3cbr\x3e4)划分本地启动配置和线上打包配置；\x3cbr\x3e5)实现文件的md5加密；\x3cbr\x3e6)实现本地的开发服务；\x3cbr\x3e7)实现mock数据\x3cbr\x3e8)实现本地实时刷新\x3c\/p\x3e\n\x3cblockquote\x3e本篇文章内容还未补全，之后会做更多修改，以期待完成补全，不过对于初学git以及node的同学来说已然是够用了\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3col\x3e\x3cli id=\x22fn-1\x22\x3exyz \x3ca href=\x22#fnref-1\x22 class=\x22footnote-backref\x22\x3e↩\x3c\/a\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>浅析git</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016867526">https://segmentfault.com/a/1190000016867526</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/irsx05cvpw/" target="_blank">https://alili.tech/archive/irsx05cvpw/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>