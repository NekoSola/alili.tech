<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="精益 React 学习指南 （Lean React）- 1.4 React 组件生命周期和方法"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>精益 React 学习指南 （Lean React）- 1.4 React 组件生命周期和方法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mp02bxg2l4/",
				"appid": "1613049289050283", 
				"title": "精益 React 学习指南 （Lean React）- 1.4 React 组件生命周期和方法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-10T02:30:42"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ia6hx9lm5fo/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/cu2zqalg5g5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmp02bxg2l4%2f&text=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.4%20React%20%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e6%96%b9%e6%b3%95"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmp02bxg2l4%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmp02bxg2l4%2f&text=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.4%20React%20%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e6%96%b9%e6%b3%95"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmp02bxg2l4%2f&title=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.4%20React%20%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e6%96%b9%e6%b3%95"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmp02bxg2l4%2f&is_video=false&description=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.4%20React%20%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e6%96%b9%e6%b3%95"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.4%20React%20%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e6%96%b9%e6%b3%95&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmp02bxg2l4%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmp02bxg2l4%2f&title=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.4%20React%20%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e6%96%b9%e6%b3%95"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmp02bxg2l4%2f&title=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.4%20React%20%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e6%96%b9%e6%b3%95"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmp02bxg2l4%2f&title=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.4%20React%20%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e6%96%b9%e6%b3%95"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmp02bxg2l4%2f&title=%e7%b2%be%e7%9b%8a%20React%20%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%ef%bc%88Lean%20React%ef%bc%89-%201.4%20React%20%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%92%8c%e6%96%b9%e6%b3%95"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">精益 React 学习指南 （Lean React）- 1.4 React 组件生命周期和方法</h1><div class="meta"><div class="postdate"><time datetime="2019-02-10" itemprop="datePublished">2019-02-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000005136764\x22\x3e书籍完整目录\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e1.4 React 组件生命周期\x3c\/h1\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVvOnw\x22 src=\x22https:\/\/static.alili.tech\/img\/bVvOnw\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22http:\/\/facebook.github.io\/react\/docs\/component-specs.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方文档\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e1.4.1 组件\x3c\/h2\x3e\n\x3cp\x3eReact 中组件有自己的生命周期方法，简单理解可以为组件从 \x3cstrong\x3e出生（实例化） -\x26gt;  激活 -\x26gt; 销毁\x3c\/strong\x3e 生命周期 hook。通过这些 hook 方法可以自定义组件的特性。 除此之外，还可以设置一些额外的规格配置。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVvOd6\x22 src=\x22https:\/\/static.alili.tech\/img\/bVvOd6\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这些生命周期方法都可以在调用 \x3cstrong\x3eReact.createClass\x3c\/strong\x3e 的参数对象中传入， 我们已经使用过了一些方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3erender\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3egetInitialState\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3egetDefaultProps\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3epropTypes\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e1.4.2 mixins\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e类型：\x3c\/strong\x3e \x3ccode\x3earray mixins\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3emixins 可以理解为 React 的插件列表，通过这种模式在不同组件之间共享方法数据或者行为只需共享 mixin 就行，mixins 内定义的生命周期方法在组件的生命周期内都会被调用。\x3c\/p\x3e\n\x3cp\x3e可能的一些疑问：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eQ1. 如果组件已经定义了某个生命周期方法， mixin 内也定义了该方法，那么 mixin 内会被调用还是 组件的会被调用？\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eQ2. 多个插件都定义了相同生命周期的方法呢？\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eQ3. 那如果多个插件定义了 getInitialState 这种配置方法呢，有何影响？\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e插件模式并非继承的模式，对于问题 1、2 的答案是一样的，都会被调用，调用顺序为 mixins 数组中的顺序。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eA1: 都会被调用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eA2: 都会被调用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eA3: React 会对返回结果做智能的合并，所有插件的 getInitialState 都会生效，前提条件是它们返回的字段不冲突，如果发生字段冲突，React 会提示报错。 同理如果是非 组件的规格方法，出于共享目的的一些方法在多个 mixin 中也不能冲突。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eeg：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var MyMixin1 = {\n    componentDidMount: function() {\n        console.log(\x27auto do something when component did mount\x27);\n    }\n};\n\nvar MyMixin2 = {\n    someMethod: function() {\n        console.log(\x27doSomething\x27);\n    }\n};\n\nvar MyComponnet = React.createClass({\n    mixins: [MyMixin1, MyMixin2],\n    componentDidMount: function() {\n        \/\/ 调用 mixin1 共享的方法\n        this.someMethod();\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e MyMixin1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ecomponentDidMount\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27auto do something when component did mount\x27\x3c\/span\x3e);\n    }\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e MyMixin2 = {\n    \x3cspan class=\x22hljs-attr\x22\x3esomeMethod\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27doSomething\x27\x3c\/span\x3e);\n    }\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e MyComponnet = React.createClass({\n    \x3cspan class=\x22hljs-attr\x22\x3emixins\x3c\/span\x3e: [MyMixin1, MyMixin2],\n    \x3cspan class=\x22hljs-attr\x22\x3ecomponentDidMount\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用 mixin1 共享的方法\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.someMethod();\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e更多 mixins 的使用会在第三章中讲解。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e1.4.3 statics\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e类型：\x3c\/strong\x3e \x3ccode\x3eobject statics\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3estatics 可以定义组件的类方法\x3c\/p\x3e\n\x3cp\x3eeg:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var MyComponent = React.createClass({\n  statics: {\n    customMethod: function(foo) {\n      return foo === \x27bar\x27;\n    }\n  }\n});\n\nMyComponent.customMethod(\x27bar\x27);  \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3evar MyComponent = React.createClass({\n  statics: {\n    customMethod: function(foo) {\n      return foo === \x27bar\x27;\n    }\n  }\n});\n\nMyComponent.customMethod(\x27bar\x27);  \/\/ true\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact 的组件是 OOP 的思维，MyComponent 是一个 class，class  分为类方法和实例方法，实例方法可以访问 this, 然而类方法不能，所以我们不能在 Class 中返回状态或者属性。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e1.4.4 displayName\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e类型：\x3c\/strong\x3e \x3ccode\x3estring displayName\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e为了显示调试信息，每个组件都会有一个名称，JSX 在转为 JS 的时候自动的设置 displayName, 如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Input (JSX):\nvar MyComponent = React.createClass({ });\n\n\/\/ Output (JS):\nvar MyComponent = React.createClass({displayName: \x26quot;MyComponent\x26quot;, });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Input (JSX):\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e MyComponent = React.createClass({ });\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Output (JS):\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e MyComponent = React.createClass({\x3cspan class=\x22hljs-attr\x22\x3edisplayName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22MyComponent\x22\x3c\/span\x3e, });\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然我们也可以自定义 displayName\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e1.4.5 生命周期方法\x3c\/h2\x3e\n\x3cp\x3e下图描述了整个组件的生命周期，包含的主要几种情况：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e组件被实例化的时候\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件属性改变的时候\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件状态被改变的时候\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件被销毁的时候\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVwhwG\x22 src=\x22https:\/\/static.alili.tech\/img\/bVwhwG\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e1.4.6 componentWillMount\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void componentWillMount()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e componentWillMount()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e条件\x3c\/strong\x3e：第一次渲染阶段在调用 render 方法前会被调用\x3cbr\x3e\x3cstrong\x3e作用\x3c\/strong\x3e：该方法在整个组件生命周期只会被调用一次，所以可以利用该方法做一些组件内部的初始化工作\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e1.4.7 componentDidMount\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void componentDidMount()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e componentDidMount()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e条件\x3c\/strong\x3e：第一次渲染成功过后，组件对应的 DOM 已经添加到页面后调用\x3cbr\x3e\x3cstrong\x3e作用\x3c\/strong\x3e：这个阶段表示组件对应的 DOM 已经存在，我们可以在这个时候做一些依赖 DOM 的操作或者其他的一些如请求数据，和第三方库整合的操作。如果嵌套了子组件，子组件会比父组件优先渲染，所以这个时候可以获取子组件对应的 DOM。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e1.4.8 componentWillReceiveProps(newProps)\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void componentWillReceiveProps(\n  object nextProps\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e componentWillReceiveProps(\n  object nextProps\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e条件：\x3c\/strong\x3e 当组件获取新属性的时候，第一次渲染不会调用\x3cbr\x3e\x3cstrong\x3e用处：\x3c\/strong\x3e 这个时候可以根据新的属性来修改组件状态 \x3cbr\x3eeg:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    componentWillReceiveProps: function(nextProps) {\n      this.setState({\n        likesIncreasing: nextProps.likeCount \x3e this.props.likeCount\n      });\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    componentWillReceiveProps: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextProps\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n        \x3cspan class=\x22hljs-attr\x22\x3elikesIncreasing\x3c\/span\x3e: nextProps.likeCount \x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.likeCount\n      });\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e注意：\x3c\/strong\x3e 这个时候虽说是获取新属性，但并不能确定属性一定改变了，例如一个组件被多次渲染到 DOM 中，如下面：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    var Component = React.createClass({\n        componentWillReceiveProps: function(nextProps) {\n            console.log(\x27componentWillReceiveProps\x27, nextProps.data.bar);\n        },\n        rener: function() {\n            return \x3cdiv\x3e {this.props.data.bar} \x3c\/div\x3e\n        }\n    });\n\n    var container = document.getElementById(\x27container\x27);\n    var mydata = {bar: \x27drinks\x27};\n    ReactDOM.render(\x3cComponent data={mydata} \/\x3e, container);\n    ReactDOM.render(\x3cComponent data={mydata} \/\x3e, container);\n    ReactDOM.render(\x3cComponent data={mydata} \/\x3e, container);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e    var Component = React.createClass({\n        componentWillReceiveProps: function(nextProps) {\n            console.log(\x27componentWillReceiveProps\x27, nextProps.data.bar);\n        },\n        rener: function() {\n            return \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e {this.props.data.bar} \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        }\n    });\n\n    var container = document.getElementById(\x27container\x27);\n    var mydata = {bar: \x27drinks\x27};\n    ReactDOM.render(\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eComponent\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{mydata}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, container);\n    ReactDOM.render(\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eComponent\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{mydata}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, container);\n    ReactDOM.render(\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eComponent\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{mydata}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, container);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e结果会输出两次 componentWillReceiveProps，虽然属性数据没有改变，但是仍然会调用  componentWillReceiveProps 方法。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e参考 Facebook \x3ca href=\x22http:\/\/facebook.github.io\/react\/blog\/2016\/01\/08\/A-implies-B-does-not-imply-B-implies-A.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e(A=\x26gt;B) =\x26gt; (B =\x26gt; A)\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e1.4.9 shouldComponentUpdate(nextProps, nextState)\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22boolean shouldComponentUpdate(\n  object nextProps, object nextState\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eboolean shouldComponentUpdate(\n  object nextProps, object nextState\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e条件：\x3c\/strong\x3e 接收到新属性或者新状态的时候在 render 前会被调用（除了调用 forceUpdate 和初始化渲染以外）\x3cbr\x3e\x3cstrong\x3e用处：\x3c\/strong\x3e 该方法让我们有机会决定是否重渲染组件，如果返回 false，那么不会重渲染组件，借此可以优化应用性能（在组件很多的情况）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e1.4.10 componentWillUpdate\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void componentWillUpdate(\n  object nextProps, object nextState\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e componentWillUpdate(\n  object nextProps, object nextState\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e条件\x3c\/strong\x3e：当组件确定要更新，在 render 之前调用\x3cbr\x3e\x3cstrong\x3e用处\x3c\/strong\x3e：这个时候可以确定一定会更新组件，可以执行更新前的操作\x3cbr\x3e\x3cstrong\x3e注意\x3c\/strong\x3e：方法中不能使用 setState ，setState 的操作应该在 componentWillReceiveProps 方法中调用\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e1.4.11 componentDidUpdate\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22void componentDidUpdate(\n  object prevProps, object prevState\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e componentDidUpdate(\n  object prevProps, object prevState\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e条件\x3c\/strong\x3e：更新被应用到 DOM 之后\x3cbr\x3e\x3cstrong\x3e用处\x3c\/strong\x3e：可以执行组件更新过后的操作\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e1.4.12 生命周期与单向数据流\x3c\/h2\x3e\n\x3cp\x3e我们知道 React 的核心模式是单向数据流，这不仅仅是对于组件级别的模式，在组件内部 的生命周期中也是应该符合单向数据的模式。数据从组件的属性流入，再结合组件的状态，流入生命周期方法，直到渲染结束这都应该是一个单向的过程，其间不能随意改变组件的状态。 \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVvOSu\x22 src=\x22https:\/\/static.alili.tech\/img\/bVvOSu\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e1.4.13 实例练习：通过 mixin 打印出组件生命周期的执行顺序\x3c\/h2\x3e\n\x3cp\x3e@todo\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>精益 React 学习指南 （Lean React）- 1.4 React 组件生命周期和方法</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005161417">https://segmentfault.com/a/1190000005161417</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mp02bxg2l4/" target="_blank">https://alili.tech/archive/mp02bxg2l4/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>