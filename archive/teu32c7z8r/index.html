<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="函数式 js 接口实现原理，以及 lodash/fp 模块"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>函数式 js 接口实现原理，以及 lodash/fp 模块 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/teu32c7z8r/",
				"appid": "1613049289050283", 
				"title": "函数式 js 接口实现原理，以及 lodash/fp 模块 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-08T02:30:41"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/mo16qg273ab/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/lrtc8swue1h/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fteu32c7z8r%2f&text=%e5%87%bd%e6%95%b0%e5%bc%8f%20js%20%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%ef%bc%8c%e4%bb%a5%e5%8f%8a%20lodash%2ffp%20%e6%a8%a1%e5%9d%97"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fteu32c7z8r%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fteu32c7z8r%2f&text=%e5%87%bd%e6%95%b0%e5%bc%8f%20js%20%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%ef%bc%8c%e4%bb%a5%e5%8f%8a%20lodash%2ffp%20%e6%a8%a1%e5%9d%97"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fteu32c7z8r%2f&title=%e5%87%bd%e6%95%b0%e5%bc%8f%20js%20%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%ef%bc%8c%e4%bb%a5%e5%8f%8a%20lodash%2ffp%20%e6%a8%a1%e5%9d%97"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fteu32c7z8r%2f&is_video=false&description=%e5%87%bd%e6%95%b0%e5%bc%8f%20js%20%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%ef%bc%8c%e4%bb%a5%e5%8f%8a%20lodash%2ffp%20%e6%a8%a1%e5%9d%97"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%87%bd%e6%95%b0%e5%bc%8f%20js%20%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%ef%bc%8c%e4%bb%a5%e5%8f%8a%20lodash%2ffp%20%e6%a8%a1%e5%9d%97&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fteu32c7z8r%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fteu32c7z8r%2f&title=%e5%87%bd%e6%95%b0%e5%bc%8f%20js%20%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%ef%bc%8c%e4%bb%a5%e5%8f%8a%20lodash%2ffp%20%e6%a8%a1%e5%9d%97"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fteu32c7z8r%2f&title=%e5%87%bd%e6%95%b0%e5%bc%8f%20js%20%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%ef%bc%8c%e4%bb%a5%e5%8f%8a%20lodash%2ffp%20%e6%a8%a1%e5%9d%97"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fteu32c7z8r%2f&title=%e5%87%bd%e6%95%b0%e5%bc%8f%20js%20%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%ef%bc%8c%e4%bb%a5%e5%8f%8a%20lodash%2ffp%20%e6%a8%a1%e5%9d%97"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fteu32c7z8r%2f&title=%e5%87%bd%e6%95%b0%e5%bc%8f%20js%20%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%ef%bc%8c%e4%bb%a5%e5%8f%8a%20lodash%2ffp%20%e6%a8%a1%e5%9d%97"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">函数式 js 接口实现原理，以及 lodash/fp 模块</h1><div class="meta"><div class="postdate"><time datetime="2019-02-08" itemprop="datePublished">2019-02-08</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3e函数式 js 接口\x3c\/h3\x3e\n\x3cp\x3e之前在 youtube 上看到一个技术视频，讲“underscore.js的接口为什么不好用”，以及什么样的接口更好用。演讲者是 lodash.js 的作者，他提出了一种“全面函数式”的 js 接口设计模式。大概类似这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 传统接口\n_.map([1, 2, 3], function (el) {return el * 2}); \/\/ return [2, 4, 6]\n\n\/\/ 函数式接口\nvar fn = _.map([1, 2, 3]); \/\/ return a function\nfn(function (el) {return el * 2}); \/\/ return [2, 4, 6];\n\n\/\/ 或者\n_.map([1, 2, 3])(function (el) {return el * 2}); \/\/ return [2, 4, 6];\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 传统接口\x3c\/span\x3e\n_.map([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e], \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(el)\x3c\/span\x3e \x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e el * \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e}); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return [2, 4, 6]\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 函数式接口\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fn = _.map([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return a function\x3c\/span\x3e\nfn(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(el)\x3c\/span\x3e \x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e el * \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e}); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return [2, 4, 6];\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 或者\x3c\/span\x3e\n_.map([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e])(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(el)\x3c\/span\x3e \x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e el * \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e}); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return [2, 4, 6];\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e找到一点感觉没有？其实就是函数式编程语言中广泛存在的“科里化”函数。当实参填满形参表的时候，执行结算返回结果，否则返回一个临时函数，继续接受实参。\x3c\/p\x3e\n\x3cp\x3e看到这个写法眼前一亮，感觉有大规模简化代码的潜力。当时实际试了一下发下很多地方用不了，因为之前写的代码受 jQuery 影响，有很多这样的接口：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22foobar.attribute(name); \/\/ 读属性\nfoobar.attribute(name, newValue); \/\/ 写属性\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3efoobar.attribute(\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 读属性\x3c\/span\x3e\nfoobar.attribute(\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e, newValue); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 写属性\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的接口是按照上述方法 curry 化会使得读属性变得不可能，根本原因是参数数量不同时 attribute 函数的语义根本不一样。使用 jQuery 的时候感觉这种写法非常爽，后来就跟着这么写，但是目前看来这样的接口设计是有问题的。\x3c\/p\x3e\n\x3cp\x3e言归正传，今天聊聊这样的接口如何实现，以及 lodash 中的 fp 模块。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e实现原理\x3c\/h3\x3e\n\x3cp\x3e说到底就是个 currying 的问题，currying 在很多语言中是内置功能，但是 js 没有，所以我们要实现一个 currying 工具函数。首先贴一个最简易的 currying 实现，它的功能非常简单，输入一个函数 fn1 和部分实参，返回一个保存部分实参，继续接收实参的函数 fn2，调用fn2，它会合并实参数组，并调用 fn1。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 函数柯里化\n * @param fn 输入函数\n * @return 柯里化后的函数\n *\/\nvar curry = function (fn) {\n    if (!isFunction(fn)) {\n        return;\n    }\n\n    var args = slice(arguments, 1);\n \n    return function () {\n        return fn.apply(this, args.concat(slice(arguments, 0)));\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 函数柯里化\n * @param fn 输入函数\n * @return 柯里化后的函数\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e curry = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isFunction(fn)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = slice(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fn.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args.concat(slice(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)));\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eisFunction 和 slice 大家都知道我就不贴了。看一下如何调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function add(a, b) {\n    return a \x2b b;\n}\n\naddOne = curry(add, 1);\n\naddOne(2); \/\/ return 3\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs oxygene\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(a, b)\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e{\n    return a \x2b b;\n}\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-title\x22\x3eaddOne\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3ecurry\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e, 1)\x3c\/span\x3e;\x3c\/span\x3e\n\naddOne(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return 3\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有时候我们需要输入的部分实参是数组列表形式，所以我们包装一下刚才的 curry 函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 函数柯里化\n * @param fn 输入函数\n * @param arr 参数列表\n * @return 柯里化后的函数\n *\/\nvar curryApply = function (fn, arr) {\n    if (!isFunction(fn)) {\n        return;\n    }\n\n    var args = arr.slice(0);\n    args.unshift(fn);\n    return curry.apply(this, args);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 函数柯里化\n * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e fn 输入函数\n * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e arr 参数列表\n * \x3cspan class=\x22hljs-doctag\x22\x3e@return\x3c\/span\x3e 柯里化后的函数\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e curryApply = function (fn, arr) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isFunction(fn)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = arr.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    args.unshift(fn);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e curry.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的 curry 函数有个问题，就是连续多次补充实参，我们还需要封装一个支持连续调用的版本：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 自动柯里化\n * @param fn 输入函数\n * @param n 输入函数参数个数\n * @return 柯里化后的函数\n *\/\nvar autoCurry = function (fn, n) {\n    if (!isFunction(fn)) {\n        return;\n    }\n\n    function retFn() {\n        var len = arguments.length;\n        var args = slice(arguments, 0);\n        var nextn = n - len;\n \n        if (nextn \x3e 0) {\n            return autoCurry(curryApply(retFn, args), nextn);\n        }\n    \n        return fn.apply(this, args);\n    }\n    \n    return retFn;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 自动柯里化\n * @param fn 输入函数\n * @param n 输入函数参数个数\n * @return 柯里化后的函数\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e autoCurry = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efn, n\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isFunction(fn)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eretFn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = slice(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nextn = n - len;\n \n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextn \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e autoCurry(curryApply(retFn, args), nextn);\n        }\n    \n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fn.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args);\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e retFn;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eautoCurry 使用的递归的方法，输出函数可以可以通过简单调用的方式连续补充实参，当实参和预设的参数数量相等时，执行输入函数。使用方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function compute(a, b, c) {\n    return (a \x2b b) * c;\n}\n\nvar curryedCompute = autoCurry(compute, 3);\n\ncompute(1, 2, 3); \/\/ return 9\ncurryedCompute(1)(2)(3); \/\/ return 9\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3efunction compute(a, b, c) {\n    return (a \x2b b) * c;\n}\n\nvar curryedCompute = autoCurry(compute, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\ncompute(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return 9\x3c\/span\x3e\ncurryedCompute(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return 9\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e大家如果使用 node.js 的话，可能知道 npm 中有个 curry 模块，实现的功能是一样的，不同的是当你不输入参数个数 n 时，curry 模块 会使用 Function 对象的 length 属性作为预设的 n 值。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3elodash\/fp\x3c\/h3\x3e\n\x3cp\x3e到这里实现原理就讲清楚了。本着不造轮子的原则，如果大家想尝试一下函数式风格的基础 js 库的话，建议使用 lodash\/fp 这个模块。大家都知道 lodash 是 underscore 的 better implemention，而 lodash\/fp 就是科里化的 lodash。与简单的 currying 不同的是，为了方便使用，lodash\/fp 的设计者调换了一些接口的参数顺序，比如开头提到的 _.map 接口，如果简单 currying 的话第一个参数应该是数组[1, 2, 3]，但是大多数时候，我们想要持有的是一个算法，用这个算法处理不同的数据。所以我们希望暂存的实际上是第二个参数 fn，所以 lodash\/fp 的接口是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ The `lodash\/map` iteratee receives three arguments:\n\/\/ (value, index|key, collection)\n_.map([\x276\x27, \x278\x27, \x2710\x27], parseInt);\n\/\/ → [6, NaN, 2]\n\n\/\/ The `lodash\/fp\/map` iteratee is capped at one argument:\n\/\/ (value)\nfp.map(parseInt)([\x276\x27, \x278\x27, \x2710\x27]);\n\/\/ → [6, 8, 10]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ The `lodash\/map` iteratee receives three arguments:\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ (value, index|key, collection)\x3c\/span\x3e\n_.\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e([\x3cspan class=\x22hljs-string\x22\x3e\x276\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x278\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x2710\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-built_in\x22\x3eparseInt\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ → [6, NaN, 2]\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ The `lodash\/fp\/map` iteratee is capped at one argument:\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ (value)\x3c\/span\x3e\nfp.\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3eparseInt\x3c\/span\x3e)([\x3cspan class=\x22hljs-string\x22\x3e\x276\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x278\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x2710\x27\x3c\/span\x3e]);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ → [6, 8, 10]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于 lodash\/fp 更详细的说明，请看：\x3ca href=\x22https:\/\/github.com\/lodash\/lodash\/wiki\/FP-Guide\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/lodash\/lodash\/wiki\/FP-Guide\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>函数式 js 接口实现原理，以及 lodash/fp 模块</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005760112">https://segmentfault.com/a/1190000005760112</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/teu32c7z8r/" target="_blank">https://alili.tech/archive/teu32c7z8r/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>