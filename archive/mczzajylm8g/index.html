<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="浅说虚拟列表的实现原理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>浅说虚拟列表的实现原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mczzajylm8g/",
				"appid": "1613049289050283", 
				"title": "浅说虚拟列表的实现原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-13T02:31:22"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/a3kge8g54k/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/t5dhdeu5ma/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmczzajylm8g%2f&text=%e6%b5%85%e8%af%b4%e8%99%9a%e6%8b%9f%e5%88%97%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmczzajylm8g%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmczzajylm8g%2f&text=%e6%b5%85%e8%af%b4%e8%99%9a%e6%8b%9f%e5%88%97%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmczzajylm8g%2f&title=%e6%b5%85%e8%af%b4%e8%99%9a%e6%8b%9f%e5%88%97%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmczzajylm8g%2f&is_video=false&description=%e6%b5%85%e8%af%b4%e8%99%9a%e6%8b%9f%e5%88%97%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b5%85%e8%af%b4%e8%99%9a%e6%8b%9f%e5%88%97%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmczzajylm8g%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmczzajylm8g%2f&title=%e6%b5%85%e8%af%b4%e8%99%9a%e6%8b%9f%e5%88%97%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmczzajylm8g%2f&title=%e6%b5%85%e8%af%b4%e8%99%9a%e6%8b%9f%e5%88%97%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmczzajylm8g%2f&title=%e6%b5%85%e8%af%b4%e8%99%9a%e6%8b%9f%e5%88%97%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmczzajylm8g%2f&title=%e6%b5%85%e8%af%b4%e8%99%9a%e6%8b%9f%e5%88%97%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">浅说虚拟列表的实现原理</h1><div class="meta"><div class="postdate"><time datetime="2019-02-13" itemprop="datePublished">2019-02-13</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e在 \x3ca href=\x22https:\/\/github.com\/dwqs\/blog\/issues\/63\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e列表数据的展示优化\x3c\/a\x3e 一文中，提到了对于列表形态的数据展示的按需渲染。这种方式是指根据容器元素的高度以及列表项元素的高度来显示长列表数据中的某一个部分，而不是去完整地渲染长列表，以提高无限滚动的性能。而按需显示方案的实现就是本文标题中说的虚拟列表。\x3c\/p\x3e\n\x3cblockquote\x3e虚拟列表的实现有多种方案，本文以 \x3ca href=\x22https:\/\/github.com\/dwqs\/react-virtual-list\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-virtual-list\x3c\/a\x3e 组件为基础进行分析。原文链接：\x3ca href=\x22https:\/\/github.com\/dwqs\/blog\/issues\/70\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/dwqs\/blog\/...\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e什么是虚拟列表？\x3c\/h2\x3e\n\x3cp\x3e在正文之前，先对虚拟列表做个简单的定义。\x3c\/p\x3e\n\x3cp\x3e根据上文，虚拟列表是按需显示思路的一种实现，即\x3cstrong\x3e虚拟列表是一种根据滚动容器元素的可视区域来渲染长列表数据中某一个部分数据的技术。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e简而言之，虚拟列表指的就是「可视区域渲染」的列表。有三个概念需要了解一下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3e滚动容器元素\x3c\/strong\x3e：一般情况下，滚动容器元素是 \x3ccode\x3ewindow\x3c\/code\x3e 对象。然而，我们可以通过布局的方式，在某个页面中任意指定一个或者多个滚动容器元素。只要某个元素能在内部产生横向或者纵向的滚动，那这个元素就是滚动容器元素考虑每个列表项只是渲染一些纯文本。在本文中，只讨论元素的纵向滚动。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e可滚动区域\x3c\/strong\x3e：滚动容器元素的内部内容区域。假设有 100 条数据，每个列表项的高度是 50，那么可滚动的区域的高度就是 100 * 50。可滚动区域当前的具体高度值一般可以通过(滚动容器)元素的 \x3ccode\x3escrollHeight\x3c\/code\x3e 属性获取。用户可以通过滚动来改变列表在可视区域的显示部分。\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3e可视区域\x3c\/strong\x3e：滚动容器元素的视觉可见区域。如果容器元素是 \x3ccode\x3ewindow\x3c\/code\x3e 对象，可视区域就是浏览器的视口大小(即\x3ca href=\x22https:\/\/user-images.githubusercontent.com\/7871813\/43363609-26e0d164-933b-11e8-85e5-1ec21d5ba398.png\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e视觉视口\x3c\/a\x3e)；如果容器元素是某个 \x3ccode\x3ediv\x3c\/code\x3e 元素，其高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可视区域。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e实现虚拟列表就是在处理用户滚动时，要改变列表在可视区域的渲染部分，其具体步骤如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e计算当前可见区域起始数据的 startIndex\x3c\/li\x3e\n\x3cli\x3e计算当前可见区域结束数据的 endIndex\x3c\/li\x3e\n\x3cli\x3e计算当前可见区域的数据，并渲染到页面中\x3c\/li\x3e\n\x3cli\x3e计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上\x3c\/li\x3e\n\x3cli\x3e计算 endIndex 对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到列表上\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e建议参考下图理解一下上面的步骤：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016734600?w=549\x26amp;h=609\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016734600?w=549\x26amp;h=609\x22 alt=\x22步骤图\x22 title=\x22步骤图\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e元素 L 代指当前列表中的最后一个元素\x3c\/blockquote\x3e\n\x3cp\x3e从上图可以看出，\x3ccode\x3estartOffset\x3c\/code\x3e 和 \x3ccode\x3eendOffset\x3c\/code\x3e 会撑开容器元素的内容高度，让其可持续的滚动；此外，还能保持滚动条处于一个正确的位置。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e为什么需要虚拟列表？\x3c\/h2\x3e\n\x3cp\x3e虚拟列表是对长列表的一种优化方案。在前端开发中，会碰到一些不能使用分页方式来加载列表数据的业务形态，我们称这种列表叫做长列表。比如，在一些外汇交易系统中，前端会准实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。\x3c\/p\x3e\n\x3cp\x3e在本篇文章中，我们把长列表定义成数据长度大于 999，并且不能使用分页的形式来展示的列表。\x3c\/p\x3e\n\x3cp\x3e如果对长列表不作优化，完整地渲染一个长列表，到底需要多长时间呢？接下来会写一个简单的 demo 来测试以下。\x3c\/p\x3e\n\x3cblockquote\x3e本文 demo 的测试环境：Macbook Pro(Core i7 2.2G, 16G), Chrome 69，React 16.4.1\x3c\/blockquote\x3e\n\x3cp\x3e在 demo 中，我们先测一下浏览器渲染 10000 个简单的节点需要多长时间：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27\n\nconst count = 10000\n\nfunction createMarkup (doms) {\n  return doms.length ? { __html: doms.join(\x27 \x27) } : { __html: \x27\x27 }\n}\n\nexport default class DOM extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      simpleDOMs: []\n    }\n\n    this.onCreateSimpleDOMs = this.onCreateSimpleDOMs.bind(this)\n  }\n\n  onCreateSimpleDOMs () {\n    const array = []\n\n    for (var i = 0; i \x3c count; i\x2b\x2b) {\n      array.push(\x27\x3cdiv\x3e\x27 \x2b i \x2b \x27\x3c\/div\x3e\x27)\n    }\n\n    this.setState({\n      simpleDOMs: array\n    })\n  }\n\n  render () {\n    return (\n      \x3cdiv style=\x22{{\x22 marginLeft: \x2710px\x27 \x22}}\x22\x3e\n        \x3ch3\x3eCreat large of DOMs：\x3c\/h3\x3e\n        \x3cbutton onClick={this.onCreateSimpleDOMs}\x3eCreate Simple DOMs\x3c\/button\x3e\n        \x3cdiv dangerouslySetInnerHTML={createMarkup(this.state.simpleDOMs)} \/\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e count = \x3cspan class=\x22hljs-number\x22\x3e10000\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateMarkup\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3edoms\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e doms.length ? { \x3cspan class=\x22hljs-attr\x22\x3e__html\x3c\/span\x3e: doms.join(\x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e) } : { \x3cspan class=\x22hljs-attr\x22\x3e__html\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDOM\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3esimpleDOMs\x3c\/span\x3e: []\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onCreateSimpleDOMs = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onCreateSimpleDOMs.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n  }\n\n  onCreateSimpleDOMs () {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = []\n\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; count; i\x2b\x2b) {\n      array.push(\x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;\x27\x3c\/span\x3e \x2b i \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/div\x26gt;\x27\x3c\/span\x3e)\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      \x3cspan class=\x22hljs-attr\x22\x3esimpleDOMs\x3c\/span\x3e: array\n    })\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22{{\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3emarginLeft:\x3c\/span\x3e \x27\x3cspan class=\x22hljs-attr\x22\x3e10px\x3c\/span\x3e\x27 \x22}}\x22\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3eCreat large of DOMs：\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.onCreateSimpleDOMs}\x3c\/span\x3e\x26gt;\x3c\/span\x3eCreate Simple DOMs\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3edangerouslySetInnerHTML\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{createMarkup(this.state.simpleDOMs)}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    )\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当点击 Button 时，会调用 \x3ccode\x3eonCreateSimpleDOMs\x3c\/code\x3e 创建 10000 个简单节点。从 Chrome 的 Performance 标签页看到的数据如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016734601?w=1406\x26amp;h=608\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016734601?w=1406\x26amp;h=608\x22 alt=\x22simple doms\x22 title=\x22simple doms\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从上图可以看到，从 Event Click 到 Paint，总共用了大约 693ms，渲染时的主要时间消耗情况如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eRecalculate Style：40.80ms\x3c\/li\x3e\n\x3cli\x3eLayout：518.55ms\x3c\/li\x3e\n\x3cli\x3eUpdate Layer Tree：11.84ms\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e在 Recalculate Style 和 Layout 阶段，ReactDOM 调用了 \x3ccode\x3esetInnerHTML\x3c\/code\x3e 方法，其内部主要通过 \x3ccode\x3einnerHTML\x3c\/code\x3e 方法，将创建好的 html 片段添加到对应节点\x3c\/blockquote\x3e\n\x3cp\x3e然后，我们创建 10000 个稍微复杂点的节点。修改组件如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27\n\nfunction createMarkup (doms) {\n  return doms.length ? { __html: doms.join(\x27 \x27) } : { __html: \x27\x27 }\n}\n\nexport default class DOM extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      complexDOMs: []\n    }\n\n    this.onCreateComplexDOMs = this.onCreateComplexDOMs.bind(this)\n  }\n\n  onCreateComplexDOMs () {\n    const array = []\n    for (var i = 0; i \x3c 5000; i\x2b\x2b) {\n      array.push(`\n        \x3cdiv class=\x27list-item\x27\x3e\n          \x3cp\x3e#${i} eligendi voluptatem quisquam\x3c\/p\x3e\n          \x3cp\x3eModi autem fugiat maiores. Doloremque est sed quis qui nobis. Accusamus dolorem aspernatur sed rem.\x3c\/p\x3e\n        \x3c\/div\x3e\n      `)\n    }\n\n    this.setState({\n      complexDOMs: array\n    })\n  }\n\n  render () {\n    return (\n      \x3cdiv style=\x22{{\x22 marginLeft: \x2710px\x27 \x22}}\x22\x3e\n        \x3ch3\x3eCreat large of DOMs：\x3c\/h3\x3e\n        \x3cbutton onClick={this.onCreateComplexDOMs}\x3eCreate Complex DOMs\x3c\/button\x3e\n        \x3cdiv dangerouslySetInnerHTML={createMarkup(this.state.complexDOMs)} \/\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateMarkup\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3edoms\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e doms.length ? { \x3cspan class=\x22hljs-attr\x22\x3e__html\x3c\/span\x3e: doms.join(\x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e) } : { \x3cspan class=\x22hljs-attr\x22\x3e__html\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDOM\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3ecomplexDOMs\x3c\/span\x3e: []\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onCreateComplexDOMs = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onCreateComplexDOMs.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n  }\n\n  onCreateComplexDOMs () {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e array = []\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e5000\x3c\/span\x3e; i\x2b\x2b) {\n      array.push(\x3cspan class=\x22hljs-string\x22\x3e`\n        \x26lt;div class=\x27list-item\x27\x26gt;\n          \x26lt;p\x26gt;#\x3cspan class=\x22hljs-subst\x22\x3e${i}\x3c\/span\x3e eligendi voluptatem quisquam\x26lt;\/p\x26gt;\n          \x26lt;p\x26gt;Modi autem fugiat maiores. Doloremque est sed quis qui nobis. Accusamus dolorem aspernatur sed rem.\x26lt;\/p\x26gt;\n        \x26lt;\/div\x26gt;\n      `\x3c\/span\x3e)\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      \x3cspan class=\x22hljs-attr\x22\x3ecomplexDOMs\x3c\/span\x3e: array\n    })\n  }\n\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22{{\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3emarginLeft:\x3c\/span\x3e \x27\x3cspan class=\x22hljs-attr\x22\x3e10px\x3c\/span\x3e\x27 \x22}}\x22\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3eCreat large of DOMs：\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.onCreateComplexDOMs}\x3c\/span\x3e\x26gt;\x3c\/span\x3eCreate Complex DOMs\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3edangerouslySetInnerHTML\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{createMarkup(this.state.complexDOMs)}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    )\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当点击 Button 时，会调用 \x3ccode\x3eonCreateComplexDOMs\x3c\/code\x3e。从 Chrome 的 Performance 标签页看到的数据如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016734602\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016734602\x22 alt=\x22complex doms\x22 title=\x22complex doms\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从上图可以看到，从 Event Click 到 Paint，总共用了大约 964.2ms，渲染时的主要时间消耗情况如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eRecalculate Style：117.07ms\x3c\/li\x3e\n\x3cli\x3eLayout：538.00ms\x3c\/li\x3e\n\x3cli\x3eUpdate Layer Tree：31.15ms\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e对于上述测试各进行 5 次，然后取各指标的平均值，统计结果如下：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e-\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eRecalculate Style\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eLayout\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eUpdate Layer Tree\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eTotal\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e渲染简单节点\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e199.66ms\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e523.72ms\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e12.572ms\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e735.952ms\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e渲染复杂节点\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e114.684ms\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e806.05ms\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e31.328ms\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e952.512ms\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cblockquote\x3e\x3col\x3e\n\x3cli\x3eTotal = Recalculate Style \x2b Layout \x2b Update Layer Tree\x3c\/li\x3e\n\x3cli\x3edemo 的测试代码：\x3ca href=\x22https:\/\/github.com\/dwqs\/react-demos\/tree\/master\/src\/general\/dom\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etest code\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\x3c\/blockquote\x3e\n\x3cp\x3e从上面的测试结果中可以看到，渲染 10000 个节点就需要 700ms\x2b，实际业务中的列表每个节点都需要 20 个左右的节点，布局也会复杂很多，在 Recalculate Style 和 Layout 阶段也会耗费更长的时间。那么，700ms 也仅能渲染 300 ~ 500 个左右的列表项，所以完整的长列表渲染基本上很难达到业务上的要求的。而非完整的长列表渲染一般有两种方式：按需渲染和延迟渲染(即懒渲染)。常见的无限滚动便是延迟渲染的一种实现，而虚拟列表则是按需渲染的一种实现。\x3c\/p\x3e\n\x3cp\x3e延迟渲染不在本文讨论范围。接下来，本文会简单介绍虚拟列表的一种实现方案。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e实现\x3c\/h2\x3e\n\x3cp\x3e本章节将会创建一个 \x3ccode\x3eVirtualizedList\x3c\/code\x3e 组件，并结合代码，慢慢梳理虚拟列表的实现。\x3c\/p\x3e\n\x3cp\x3e为了简化，我们设定 \x3ccode\x3ewindow\x3c\/code\x3e 为滚动容器元素，给 \x3ccode\x3ehtml\x3c\/code\x3e 和 \x3ccode\x3ebody\x3c\/code\x3e 元素均添加样式规则 \x3ccode\x3eheight: 100%\x3c\/code\x3e，设定可视区域为浏览器的窗口大小。\x3ccode\x3eVirtualizedList\x3c\/code\x3e 在 DOM 元素的布局上将参考\x3ca href=\x22https:\/\/mobile.twitter.com\/home\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTwitter 的移动端\x3c\/a\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class VirtualizedList extends Component {\n  constructor (props) {\n    super(props)\n    \n    this.state = {\n      startOffset: 0,\n      endOffset: 0,\n      visibleData: []\n    }\n    \n    this.data = new Array(1000).fill(true)\n    this.startIndex = 0\n    this.endIndex = 0\n    this.scrollTop = 0\n  }\n  \n  render () {\n    const {startOffset, endOffset} = this.state\n    \n    return (\n      \x3cdiv className=\x27wrapper\x27\x3e\n        \x3cdiv style=\x22{{\x22 paddingTop: `${startOffset}px`, paddingBottom: `${endOffset}px` \x22}}\x22\x3e\n          {\n            \/\/ render list\n          }\n        \x3c\/div\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eVirtualizedList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props)\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3estartOffset\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3eendOffset\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3evisibleData\x3c\/span\x3e: []\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e).fill(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startIndex = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.endIndex = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollTop = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n  }\n  \n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {startOffset, endOffset} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27wrapper\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22{{\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epaddingTop:\x3c\/span\x3e `${\x3cspan class=\x22hljs-attr\x22\x3estartOffset\x3c\/span\x3e}\x3cspan class=\x22hljs-attr\x22\x3epx\x3c\/span\x3e`, \x3cspan class=\x22hljs-attr\x22\x3epaddingBottom:\x3c\/span\x3e `${\x3cspan class=\x22hljs-attr\x22\x3eendOffset\x3c\/span\x3e}\x3cspan class=\x22hljs-attr\x22\x3epx\x3c\/span\x3e` \x22}}\x22\x26gt;\x3c\/span\x3e\n          {\n            \/\/ render list\n          }\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在虚拟列表上的实现上，也分为两种情形：列表项是固定高度的和列表项是动态高度的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e列表项是固定高度的\x3c\/h3\x3e\n\x3cp\x3e既然列表项是固定高度的，那约定没个列表项的高度为 60，列表数据的长度为 1000。\x3c\/p\x3e\n\x3cp\x3e首先，我们根据可视区域的高度估算可视区域能渲染的元素个数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const height = 60\nconst bufferSize = 5\n\/\/ ...\n\nthis.visibleCount = Math.ceil(window.clientHeight \/ height)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e height = \x3cspan class=\x22hljs-number\x22\x3e60\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bufferSize = \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.visibleCount = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.ceil(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.clientHeight \/ height)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后，计算 \x3ccode\x3estartIndex\x3c\/code\x3e 和 \x3ccode\x3eendIndex\x3c\/code\x3e，并先初始化初次需要渲染的数据：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...\n\nupdateVisibleData (scrollTop) {\n  const visibleData = this.data.slice(this.startIndex, this.endIndex)\n  const endOffset = (this.data.length - this.endIndex) * height\n    \n  this.setState({\n    startOffset: 0,\n    endOffset,\n    visibleData\n  })\n}\n\ncomponentDidMount () {\n  \/\/ 计算可渲染的元素个数\n  this.visibleCount = Math.ceil(window.innerHeight \/ height) \x2b bufferSize\n  this.endIndex = this.startIndex \x2b this.visibleCount\n  this.updateVisibleData()\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\nupdateVisibleData (scrollTop) {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e visibleData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data.slice(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startIndex, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.endIndex)\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e endOffset = (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data.length - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.endIndex) * height\n    \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n    \x3cspan class=\x22hljs-attr\x22\x3estartOffset\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n    endOffset,\n    visibleData\n  })\n}\n\ncomponentDidMount () {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计算可渲染的元素个数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.visibleCount = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.ceil(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.innerHeight \/ height) \x2b bufferSize\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.endIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startIndex \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.visibleCount\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.updateVisibleData()\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上文所说，\x3ccode\x3eendOffset\x3c\/code\x3e 是计算 \x3ccode\x3eendIndex\x3c\/code\x3e 对应的数据相对于可滚动区域底部的偏移位置。在本 demo 中，可滚动区域的高度就是 1000 \x3cem\x3e 60，因而 \x3ccode\x3eendIndex\x3c\/code\x3e 对应的数据相距底部的偏移就是 (1000 - endIndex) \x3c\/em\x3e 60。\x3c\/p\x3e\n\x3cp\x3e由于是初始化初次需要渲染的数据，因而 \x3ccode\x3estartOffset\x3c\/code\x3e 的初始值是 0。\x3c\/p\x3e\n\x3cp\x3e根据上述代码，可以得知，要计算可见区域需要渲染的数据，只要计算出 \x3ccode\x3estartIndex\x3c\/code\x3e 就行，因为 \x3ccode\x3evisibleCount\x3c\/code\x3e 是一个定值，\x3ccode\x3ebufferSize\x3c\/code\x3e 是一个缓冲值，用来增加一定的缓存区域，让正常滑动速度的时候不会显得那么突兀。而 \x3ccode\x3eendIndex\x3c\/code\x3e 的值就等于 \x3ccode\x3estartIndex\x3c\/code\x3e 加上 \x3ccode\x3evisibleCount\x3c\/code\x3e；同时，当用户滚动改变可见区域的数据时，还需要计算 \x3ccode\x3estartOffset\x3c\/code\x3e 的值，以保证新的数据会出现在用户浏览器的视口中：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016734603\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016734603\x22 alt=\x22startOffset\x22 title=\x22startOffset\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果不计算 \x3ccode\x3estartOffset\x3c\/code\x3e 的值，那本应该渲染在可视区域内的元素会渲染到可视区域之外。从上图可以看到，\x3ccode\x3estartOffset\x3c\/code\x3e 的值就是元素8的上边框 \x3cstrong\x3e(可视区域内最上面一个元素)\x3c\/strong\x3e 到元素1的上边框的偏移量。元素8称为 \x3cstrong\x3e锚点元素，即可视区域内的第一个元素。\x3c\/strong\x3e 因而，我们需要定义一个变量来缓存锚点元素的一些位置信息，同时也要缓存已渲染的元素的位置信息：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...\n\/\/ 缓存已渲染元素的位置信息\nthis.cache = []\n\/\/ 缓存锚点元素的位置信息\nthis.anchorItem = {\n  index: 0, \/\/ 锚点元素的索引值\n  top: 0, \/\/ 锚点元素的顶部距离第一个元素的顶部的偏移量(即 startOffset)\n  bottom: 0 \/\/ 锚点元素的底部距离第一个元素的顶部的偏移量\n}\n\/\/ ...\n\ncachePosition (node, index) {\n  const rect = node.getBoundingClientRect()\n  const top = rect.top \x2b window.pageYOffset\n  \n  this.cache.push({\n    index,\n    top,\n    bottom: top \x2b height\n  })\n}\n\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 缓存已渲染元素的位置信息\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cache = []\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 缓存锚点元素的位置信息\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.anchorItem = {\n  \x3cspan class=\x22hljs-attr\x22\x3eindex\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 锚点元素的索引值\x3c\/span\x3e\n  top: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 锚点元素的顶部距离第一个元素的顶部的偏移量(即 startOffset)\x3c\/span\x3e\n  bottom: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 锚点元素的底部距离第一个元素的顶部的偏移量\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\ncachePosition (node, index) {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e rect = node.getBoundingClientRect()\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e top = rect.top \x2b \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.pageYOffset\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cache.push({\n    index,\n    top,\n    \x3cspan class=\x22hljs-attr\x22\x3ebottom\x3c\/span\x3e: top \x2b height\n  })\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e方法 \x3ccode\x3ecachePosition\x3c\/code\x3e 会在每个列表项组件渲染完后(\x3ccode\x3ecomponentDidMount\x3c\/code\x3e)进行调用，\x3ccode\x3enode\x3c\/code\x3e 是对应的列表项节点元素，\x3ccode\x3eindex\x3c\/code\x3e 是节点的索引值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Item.jsx\n\n\/\/ ...\ncomponentDidMount () {\n  this.props.cachePosition(this.node, this.props.index)\n}\n\nrender () {\n  \/* eslint-disable-next-line *\/\n  const {index} = this.props\n\n  return (\n    \x3cdiv className=\x27list-item\x27 ref={node =\x3e { this.node = node \x22}}\x22\x3e\n      \x3cp\x3e#${index} eligendi voluptatem quisquam\x3c\/p\x3e\n      \x3cp\x3eModi autem fugiat maiores. Doloremque est sed quis qui nobis. Accusamus dolorem aspernatur sed rem.\x3c\/p\x3e\n    \x3c\/div\x3e\n  )\n}\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Item.jsx\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\ncomponentDidMount () {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.cachePosition(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.node, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.index)\n}\n\nrender () {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* eslint-disable-next-line *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {index} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27list-item\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{node\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { this.node = node \x22}}\x22\x26gt;\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e#${index} eligendi voluptatem quisquam\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eModi autem fugiat maiores. Doloremque est sed quis qui nobis. Accusamus dolorem aspernatur sed rem.\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  )\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e缓存了锚点元素和已渲染元素的位置信息之后，接下来就可以处理用户的滚动行为了。以用户向下滚动(\x3ccode\x3escrollTop\x3c\/code\x3e 值增大的方向)为例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...\n\/\/ 计算 startIndex 和 endIndex\nupdateBoundaryIndex (scrollTop) {\n  scrollTop = scrollTop || 0\n  \/\/用户正常滚动下，根据 scrollTop 找到新的锚点元素位置\n  const anchorItem = this.cache.find(item =\x3e item.bottom \x3e= scrollTop)\n\n  this.anchorItem = {\n    ...anchorItem\n  }\n\n  this.startIndex = this.anchorItem.index\n  this.endIndex = this.startIndex \x2b this.visibleCount\n}\n\n\/\/ 滚动事件处理函数\nhandleScroll (e) {\n  if (!this.doc) {\n    \/\/ 兼容 iOS Safari\/Webview\n    this.doc = window.document.body.scrollTop ? window.document.body : window.document.documentElement\n  }\n\n  const scrollTop = this.doc.scrollTop\n  if (scrollTop \x3e this.scrollTop) {\n    if (scrollTop \x3e this.anchorItem.bottom) {\n      this.updateBoundaryIndex(scrollTop)\n      this.updateVisibleData()\n    }\n  } else if (scrollTop \x3c this.scrollTop) {\n    \/\/ 向上滚动(`scrollTop` 值减小的方向)\n  }\n\n  this.scrollTop = scrollTop\n}\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计算 startIndex 和 endIndex\x3c\/span\x3e\nupdateBoundaryIndex (scrollTop) {\n  scrollTop = scrollTop || \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/用户正常滚动下，根据 scrollTop 找到新的锚点元素位置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e anchorItem = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cache.find(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e =\x26gt;\x3c\/span\x3e item.bottom \x26gt;= scrollTop)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.anchorItem = {\n    ...anchorItem\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.anchorItem.index\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.endIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startIndex \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.visibleCount\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 滚动事件处理函数\x3c\/span\x3e\nhandleScroll (e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.doc) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 兼容 iOS Safari\/Webview\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.doc = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.document.body.scrollTop ? \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.document.body : \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.document.documentElement\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e scrollTop = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.doc.scrollTop\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (scrollTop \x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollTop) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (scrollTop \x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.anchorItem.bottom) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.updateBoundaryIndex(scrollTop)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.updateVisibleData()\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (scrollTop \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollTop) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 向上滚动(`scrollTop` 值减小的方向)\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.scrollTop = scrollTop\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在滚动事件处理函数中，会去更新 \x3ccode\x3estartIndex\x3c\/code\x3e、\x3ccode\x3eendIndex\x3c\/code\x3e 以及新的锚点元素的位置信息(即更新 \x3ccode\x3estartOffset\x3c\/code\x3e)，然后就可以动态的去更新可视区域的渲染数据了：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016734604?w=1172\x26amp;h=599\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016734604?w=1172\x26amp;h=599\x22 alt=\x22demo.gif\x22 title=\x22demo.gif\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e完整的代码在可以戳：\x3ca href=\x22https:\/\/github.com\/dwqs\/react-demos\/tree\/master\/src\/general\/virtual-list\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e固定高度的虚拟列表实现\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e列表项是动态高度的\x3c\/h3\x3e\n\x3cp\x3e这种情形下，实现的思路和列表项固高大同小异。而小异之处就在于缓存列表项的位置信息时，怎么拿到列表项的精确高度？首先要更改 \x3ccode\x3ecachePosition\x3c\/code\x3e 的部分逻辑：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...\ncachePosition (node, index) {\n  const rect = node.getBoundingClientRect()\n  const top = rect.top \x2b window.pageYOffset\n\n  this.cache.push({\n    index,\n    top,\n    bottom: top \x2b rect.height \/\/ 将 height 更为 rect.height\n  })\n}\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\ncachePosition (node, index) {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e rect = node.getBoundingClientRect()\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e top = rect.top \x2b \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.pageYOffset\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cache.push({\n    index,\n    top,\n    \x3cspan class=\x22hljs-attr\x22\x3ebottom\x3c\/span\x3e: top \x2b rect.height \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将 height 更为 rect.height\x3c\/span\x3e\n  })\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于列表项的高度不固定，那要怎么计算 \x3ccode\x3evisibleCount\x3c\/code\x3e 呢？我们先\x3cstrong\x3e考虑每个列表项只是渲染一些纯文本\x3c\/strong\x3e。在实际项目中，有的列表项可能只有一行文本，有的列表项可能有多行文本，此时，我们要基于项目的实际情况，给列表项一个\x3cstrong\x3e预估的高度\x3c\/strong\x3e：\x3ccode\x3eestimatedItemHeight\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e比如，有一个长列表要渲染用户的文章摘要，并规定摘要显示不超过三行，那么我们取列表的前 10 个列表项的高度平均值作为预估高度。当然，为了预估高度更精确，我们是可以扩大取样样本的。\x3c\/p\x3e\n\x3cp\x3e既然有了预估高度，那么将原先代码中的 \x3ccode\x3eheight\x3c\/code\x3e 替换成 \x3ccode\x3eestimatedItemHeight\x3c\/code\x3e，就可以计算出 \x3ccode\x3evisibleCount\x3c\/code\x3e 了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...\nconst estimatedItemHeight = 80\n\n\/\/ ...\n\n\/\/ 计算可渲染的元素个数\nthis.visibleCount = Math.ceil(window.innerHeight \/ estimatedItemHeight) \x2b bufferSize\n\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e estimatedItemHeight = \x3cspan class=\x22hljs-number\x22\x3e80\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计算可渲染的元素个数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.visibleCount = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.ceil(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.innerHeight \/ estimatedItemHeight) \x2b bufferSize\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们通过 \x3ca href=\x22https:\/\/github.com\/marak\/Faker.js\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3efaker.js\x3c\/a\x3e 来创建一些随机数据，并赋值给 \x3ccode\x3edata\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...\nfunction fakerData () {\n  const a = []\n  for (let i = 0; i \x3c 1000; i\x2b\x2b) {\n    a.push({\n      id: i,\n      words: faker.lorem.words(),\n      paragraphs: faker.lorem.sentences()\n    })\n  }\n\n  return a\n}\n\/\/ ...\n\nthis.data = fakerData()\n\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efakerData\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a = []\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e; i\x2b\x2b) {\n    a.push({\n      \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: i,\n      \x3cspan class=\x22hljs-attr\x22\x3ewords\x3c\/span\x3e: faker.lorem.words(),\n      \x3cspan class=\x22hljs-attr\x22\x3eparagraphs\x3c\/span\x3e: faker.lorem.sentences()\n    })\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = fakerData()\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e修改一下列表项的 \x3ccode\x3erender\x3c\/code\x3e 逻辑，其它不变：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Item.jsx\n\n\/\/ ...\n\nrender () {\n  \/* eslint-disable-next-line *\/\n  const {index, item} = this.props\n\n  return (\n    \x3cdiv className=\x27list-item\x27 style=\x22{{\x22 height: \x27auto\x27 \x22}}\x22 ref={node =\x3e { this.node = node \x22}}\x22\x3e\n      \x3cp\x3e#${index} {item.words}\x3c\/p\x3e\n      \x3cp\x3e{item.paragraphs}\x3c\/p\x3e\n    \x3c\/div\x3e\n  )\n}\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Item.jsx\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\nrender () {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* eslint-disable-next-line *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {index, item} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27list-item\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22{{\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eheight:\x3c\/span\x3e \x27\x3cspan class=\x22hljs-attr\x22\x3eauto\x3c\/span\x3e\x27 \x22}}\x22 \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{node\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { this.node = node \x22}}\x22\x26gt;\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e#${index} {item.words}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e{item.paragraphs}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  )\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时，列表项的高度已经是动态的了，根据渲染的实际情况，我们给的预估高度是 80：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016734605\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016734605\x22 alt=\x22demo2.gif\x22 title=\x22demo2.gif\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e完整的代码在可以戳：\x3ca href=\x22https:\/\/github.com\/dwqs\/react-demos\/tree\/master\/src\/general\/dynamic-virtual-list\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e动态高度的虚拟列表实现\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e那如果列表项渲染的不是纯文本呢？比如渲染的是图文，那在 Item 组件的 \x3ccode\x3ecomponentDidMount\x3c\/code\x3e 去调用 \x3ccode\x3ecachePosition\x3c\/code\x3e 方法时，能拿到对应节点的正确高度吗？在渲染图文的情况下，因为图片会发起网络请求，此时并不能保证在列表项组件挂载(执行  \x3ccode\x3ecomponentDidMount\x3c\/code\x3e)的时候图片渲染好了，那此时对应节点的高度就是不准确的，因而在用户滚动改变可见区域渲染的数据时，就可能出现元素相互重叠的情况：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016734606?w=1194\x26amp;h=866\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016734606?w=1194\x26amp;h=866\x22 alt=\x22error\x22 title=\x22error\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在这种情况下，如果我们能监听 Item 组件节点的大小变化就能获取其正确的高度了。ResizeObserver 或许就可以满足我们的需求，其提供了监听 DOM 元素大小变化的能力，但在撰写本文时，仅 Chrome 67 及以上版本支持，其它主流浏览器均为提供支持。以下是我搜集的一些资料，供你参考(自备梯子)：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/developers.google.com\/web\/updates\/2016\/10\/resizeobserver\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eResizeObserver: It’s Like document.onresize for Elements\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/WICG\/ResizeObserver\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eResizeObserver\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/caniuse.com\/#feat=resizeobserver\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecaniuse#resizeobserver\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e在本文中，首先对虚拟列表进行了简单的定义，然后从长列表的角度分析了为什么需要虚拟列表，最后就列表项固高和不固高两个场景下以一个简单的 demo 详细讲述了虚拟列表的实现思路。\x3c\/p\x3e\n\x3cp\x3e在列表项是动态高度的场景下，分析了渲染纯文本和图文混合的场景。前者给出了一个具体的 demo，针对后者对于怎么监听元素大小的变化提供了参考的 ResizeObserver 方案。基于 ResizeObserver 的方案呢，我也实现了一个支持渲染图文混合(当然也支持纯文本)的虚拟列表组件 \x3ca href=\x22https:\/\/github.com\/dwqs\/react-virtual-list\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-virtual-list\x3c\/a\x3e，供你参考。\x3c\/p\x3e\n\x3cp\x3e当然，这并不是唯一一种实现虚拟列表的方案。在组件 \x3ca href=\x22https:\/\/github.com\/dwqs\/react-virtual-list\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-virtual-list\x3c\/a\x3e 的实现过程中，也阅读了不同虚拟列表组件的源码，如: react-tiny-virtual-list、react-window、react-virtualized 等，后续的系列文章我会从源码的角度逐一分析。\x3c\/p\x3e\n\x3cp\x3e原文：\x3ca href=\x22https:\/\/github.com\/dwqs\/blog\/issues\/70\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/dwqs\/blog\/...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e参考\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/developers.google.com\/web\/updates\/2016\/07\/infinite-scroller\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eComplexities of an Infinite Scroller\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/itsze.ro\/blog\/2017\/04\/09\/infinite-list-and-react.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eInfinite List and React\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/26022258\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e聊聊前端开发中的长列表\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/34585166\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e再谈前端虚拟列表的实现\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>浅说虚拟列表的实现原理</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016734597">https://segmentfault.com/a/1190000016734597</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mczzajylm8g/" target="_blank">https://alili.tech/archive/mczzajylm8g/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>