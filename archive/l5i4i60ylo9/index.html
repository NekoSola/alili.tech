<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【译】相对完整的Gulp4升级指南"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【译】相对完整的Gulp4升级指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/l5i4i60ylo9/",
				"appid": "1613049289050283", 
				"title": "【译】相对完整的Gulp4升级指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-09T02:30:59"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/nzd9ti8yb0h/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/cdp8lnjwcp/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fl5i4i60ylo9%2f&text=%e3%80%90%e8%af%91%e3%80%91%e7%9b%b8%e5%af%b9%e5%ae%8c%e6%95%b4%e7%9a%84Gulp4%e5%8d%87%e7%ba%a7%e6%8c%87%e5%8d%97"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fl5i4i60ylo9%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fl5i4i60ylo9%2f&text=%e3%80%90%e8%af%91%e3%80%91%e7%9b%b8%e5%af%b9%e5%ae%8c%e6%95%b4%e7%9a%84Gulp4%e5%8d%87%e7%ba%a7%e6%8c%87%e5%8d%97"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fl5i4i60ylo9%2f&title=%e3%80%90%e8%af%91%e3%80%91%e7%9b%b8%e5%af%b9%e5%ae%8c%e6%95%b4%e7%9a%84Gulp4%e5%8d%87%e7%ba%a7%e6%8c%87%e5%8d%97"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fl5i4i60ylo9%2f&is_video=false&description=%e3%80%90%e8%af%91%e3%80%91%e7%9b%b8%e5%af%b9%e5%ae%8c%e6%95%b4%e7%9a%84Gulp4%e5%8d%87%e7%ba%a7%e6%8c%87%e5%8d%97"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90%e8%af%91%e3%80%91%e7%9b%b8%e5%af%b9%e5%ae%8c%e6%95%b4%e7%9a%84Gulp4%e5%8d%87%e7%ba%a7%e6%8c%87%e5%8d%97&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fl5i4i60ylo9%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fl5i4i60ylo9%2f&title=%e3%80%90%e8%af%91%e3%80%91%e7%9b%b8%e5%af%b9%e5%ae%8c%e6%95%b4%e7%9a%84Gulp4%e5%8d%87%e7%ba%a7%e6%8c%87%e5%8d%97"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl5i4i60ylo9%2f&title=%e3%80%90%e8%af%91%e3%80%91%e7%9b%b8%e5%af%b9%e5%ae%8c%e6%95%b4%e7%9a%84Gulp4%e5%8d%87%e7%ba%a7%e6%8c%87%e5%8d%97"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl5i4i60ylo9%2f&title=%e3%80%90%e8%af%91%e3%80%91%e7%9b%b8%e5%af%b9%e5%ae%8c%e6%95%b4%e7%9a%84Gulp4%e5%8d%87%e7%ba%a7%e6%8c%87%e5%8d%97"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl5i4i60ylo9%2f&title=%e3%80%90%e8%af%91%e3%80%91%e7%9b%b8%e5%af%b9%e5%ae%8c%e6%95%b4%e7%9a%84Gulp4%e5%8d%87%e7%ba%a7%e6%8c%87%e5%8d%97"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【译】相对完整的Gulp4升级指南</h1><div class="meta"><div class="postdate"><time datetime="2019-02-09" itemprop="datePublished">2019-02-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e原文链接：\x3ca href=\x22https:\/\/www.joezimjs.com\/javascript\/complete-guide-upgrading-gulp-4\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eThe Complete-Ish Guide to Upgrading to Gulp 4\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e虽然Gulp4始终在开发中，但是你要坚信在将来的某一天你一定可以等到它的正式版。嗯，某一天。所以现在我想先向你们介绍Gulp3.x和Gulp4之间的不同，同时希望能够帮助你将来能相对无痛的迁移到新的版本。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e安装\x3c\/h3\x3e\n\x3cp\x3e在你开始使用最新版的Gulp之前，你必须要先检查一下你Gulp的版本。通常，你只需要更新你的\x3ccode\x3epackage.json\x3c\/code\x3e中的版本号就行了，不过有时候你也有可能碰到一些额外的麻烦。最可能的原因是你分别在项目文件夹下和全局环境中都安装了Gulp（如果你读过了这篇文章\x3ca href=\x22https:\/\/www.joezimjs.com\/javascript\/no-more-global-npm-packages\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ethe practice of using npm scripts to access the locally installed version of CLI’s\x3c\/a\x3e，那就好办多了。虽然在这里它可能还是帮不了你太多）。因此，首先你要把你项目文件夹下的Gulp删除，如果你在全局环境中也安装了Gulp，最好也把它删了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nnpm uninstall gulp --save-dev\nnpm uninstall gulp -g\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sql\x22\x3e\x3ccode\x3e\nnpm \x3cspan class=\x22hljs-keyword\x22\x3euninstall\x3c\/span\x3e gulp \x3cspan class=\x22hljs-comment\x22\x3e--save-dev\x3c\/span\x3e\nnpm \x3cspan class=\x22hljs-keyword\x22\x3euninstall\x3c\/span\x3e gulp -g\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在你就可以在你的项目中安装Gulp4。由于它还没有正式发布，我们只能直接通过Github来安装它：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm install gulpjs\/gulp.git#4.0  --save-dev\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cmake\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-keyword\x22\x3einstall\x3c\/span\x3e gulpjs\/gulp.git\x3cspan class=\x22hljs-comment\x22\x3e#4.0  --save-dev\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当它提交到npm库之后，你就可以像平常一样使用\x3ccode\x3enpm install gulp --save-dev\x3c\/code\x3e了。并且当它发布正式版本后，我们也最好不要从Github上安装，改为直接从npm上进行安装。好了，现在我们还有另一个东西需要安装：命令行工具。跟现在的Grunt类似的，Gulp4把命令行工具从Gulp的核心代码中剥离了。Gulp3和Gulp4都能使用独立出来的命令行工具。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm install gulp-cli --save-dev\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs q\x22\x3e\x3ccode\x3enpm install gulp-cli --\x3cspan class=\x22hljs-built_in\x22\x3esave\x3c\/span\x3e-\x3cspan class=\x22hljs-built_in\x22\x3edev\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你不想在你的项目中使用npm scripts，你需要使用\x3ccode\x3e-g\x3c\/code\x3e替换\x3ccode\x3e-save-dev\x3c\/code\x3e来进行全局安装。现在你就可以像以前一样使用\x3ccode\x3egulp\x3c\/code\x3e命令了，但是你应该会得到一个错误信息，因为你需要更新你的\x3ccode\x3egulpfile.js\x3c\/code\x3e来兼容最新版的Gulp。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e任务重构\x3c\/h3\x3e\n\x3cp\x3e如果你原来的任务代码结构十分简单，任务之前没有相互的依赖。那很走运，你将不需要做任何修改！不过令人哀伤的是，大部分人都不得不做一些调整。Gulp4最大的一个改变就是\x3ccode\x3egulp.task\x3c\/code\x3e函数现在只支持两个参数，分别是任务名和运行任务的函数。举个例子，下面的任务代码可以很好的运行在Gulp3和Gulp4上面：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\ngulp.task(\x27clean\x27, function() {...})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e\ngulp.task(\x27clean\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是当你使用三个参数时该怎么办？我们要如何指定任务之间的依赖关系？这时新的\x3ccode\x3egulp.series\x3c\/code\x3e和\x3ccode\x3egulp.parallel\x3c\/code\x3e函数应该能帮助你解决难题。这两个函数都可以接受数个函数或任务名作为参数，经过组合后，返回一个新的函数。\x3ccode\x3egulp.series\x3c\/code\x3e会返回一个函数用来顺序执行它所接受的任务\/函数，而\x3ccode\x3egulp.parallel\x3c\/code\x3e返回的函数则会并行的运行它们。Gulp总算能够让我们自由的选择以串行或并行的方式来执行任务而不再需要其他的第三方依赖（比如常用的\x3ca href=\x22https:\/\/www.npmjs.com\/package\/run-sequence\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erun-sequence\x3c\/a\x3e），也不用再定义一堆让人看不懂的任务依赖。\x3c\/p\x3e\n\x3cp\x3e如果你以前是这么写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(\x27styles\x27, [\x27clean\x27], function() {\n    ...\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3egulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27styles\x27\x3c\/span\x3e, [\x3cspan class=\x22hljs-string\x22\x3e\x27clean\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    ...\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那你现在可以这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(\x27styles\x27, gulp.series(\x27clean\x27, function() {\n    ...\n}));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3egulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27styles\x27\x3c\/span\x3e, gulp.series(\x3cspan class=\x22hljs-string\x22\x3e\x27clean\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    ...\n}));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在改写的时候，不要忘了其实现在你处理主要任务的函数也是放在gulp.series里面调用，所以不要忘了在结尾加上括号。很多人经常犯这个错误。\x3c\/p\x3e\n\x3cp\x3e注意，由于\x3ccode\x3egulp.series\x3c\/code\x3e和\x3ccode\x3egulp.parallel\x3c\/code\x3e返回的是一个函数，所以他们是可以被嵌套调用的。如果您的任务往往有多个依赖任务，你会经常嵌套调用它们。比如这个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(\x27default\x27, [\x27scripts\x27, \x27styles\x27], function() {\n    ...\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3egulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e, [\x3cspan class=\x22hljs-string\x22\x3e\x27scripts\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27styles\x27\x3c\/span\x3e], \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    ...\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你可以改写成：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(\x27default\x27, gulp.series(gulp.parallel(\x27scripts\x27, \x27styles\x27), function() {\n    ...\n}));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3egulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e, gulp.series(gulp.parallel(\x3cspan class=\x22hljs-string\x22\x3e\x27scripts\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27styles\x27\x3c\/span\x3e), \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    ...\n}));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看过去，这样代码读起来非常吃力。不过考虑到这样会使你任务流程控制更加的灵活，这点牺牲也就无所谓了。当然我觉得你也可以自己封装一些helper\/alias函数来优化的你的代码，提高可读性，但我应该不会这么去做。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e依赖陷阱\x3c\/h3\x3e\n\x3cp\x3e在Gulp3中，假设你设定几个有相同依赖的任务，然后运行它们，Gulp会检测出这些将要运行的任务的依赖是一样的，然后只会运行一次依赖任务。然而现在我们不再显式的指定任务之间的依赖，而是通过series和parallel函数来组合任务，这样会导致那些本应该只运行一次的任务，变成多次运行。Gulp4是无法做出相应的区分的。所以我们要改变我们指定任务依赖的思路。\x3c\/p\x3e\n\x3cp\x3e让我们看一下这个Gulp3的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ default任务，需要依赖scripts和styles\ngulp.task(\x27default\x27, [\x27scripts\x27, \x27styles\x27], function() {...});\n\n\/\/ script折styles任务都依赖clean\ngulp.task(\x27styles\x27, [\x27clean\x27], function() {...});\ngulp.task(\x27scripts\x27, [\x27clean\x27], function() {...});\n\n\/\/ clean任务用来清空目录\ngulp.task(\x27clean\x27, function() {...});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e\/\/ default任务，需要依赖scripts和styles\ngulp.task(\x27default\x27, [\x27scripts\x27, \x27styles\x27], function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\n\n\/\/ script折styles任务都依赖clean\ngulp.task(\x27styles\x27, [\x27clean\x27], function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\ngulp.task(\x27scripts\x27, [\x27clean\x27], function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\n\n\/\/ clean任务用来清空目录\ngulp.task(\x27clean\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们注意到\x3ccode\x3estyles\x3c\/code\x3e和\x3ccode\x3escripts\x3c\/code\x3e任务都依赖\x3ccode\x3eclean\x3c\/code\x3e任务。当你运行\x3ccode\x3edefault\x3c\/code\x3e任务时，Gulp3会率先运行\x3ccode\x3estyles\x3c\/code\x3e和\x3ccode\x3escripts\x3c\/code\x3e任务，又因为检测到这两个任务都有各自的依赖，所以需要优先运行它们的依赖任务，这时Gulp注意到这两个任务都依赖于\x3ccode\x3eclean\x3c\/code\x3e，于是Gulp3将确保在回到\x3ccode\x3estyles\x3c\/code\x3e和\x3ccode\x3escripts\x3c\/code\x3e任务之前，\x3ccode\x3eclean\x3c\/code\x3e任务会被执行且执行一次。这很有用！但遗憾的是，我们在新版本中将没办法运用这个特性。如果你在迁移到Gulp4的过程中只像下面的例子一样做了简单的改变，\x3ccode\x3eclean\x3c\/code\x3e任务将会被执行两次：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(\x27clean\x27, function() {...});\ngulp.task(\x27styles\x27, gulp.series(\x27clean\x27, function() {...}));\ngulp.task(\x27scripts\x27, gulp.series(\x27clean\x27, function() {...}));\n\ngulp.task(\x27default\x27, gulp.parallel(\x27scripts\x27, \x27styles\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3egulp.task(\x27clean\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\ngulp.task(\x27styles\x27, gulp.series(\x27clean\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e));\ngulp.task(\x27scripts\x27, gulp.series(\x27clean\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e));\n\ngulp.task(\x27default\x27, gulp.parallel(\x27scripts\x27, \x27styles\x27));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是因为\x3ccode\x3eparallel\x3c\/code\x3e和\x3ccode\x3eseries\x3c\/code\x3e不是用来解决依赖的；他们只是用来把多个任务合并成一个。所以我们需要把共同依赖的任务抽离出来，然后用一个更大的串行任务来包裹它们，以此来模拟任务依赖关系：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e友情提示：\x3c\/em\x3e\x3c\/strong\x3e你最好不要在定义那些小任务之前就用它们来组合你的\x3ccode\x3edefault\x3c\/code\x3e任务。因为在你调用\x3ccode\x3egulp.series(\x22taskName\x22)\x3c\/code\x3e之前，你\x3cstrong\x3e\x3cem\x3e必须\x3c\/em\x3e\x3c\/strong\x3e已经定义好了一个名为\x3ccode\x3e\x22taskName\x22\x3c\/code\x3e的任务。所以一般在Gulp4中，我们会在代码的最后才定义\x3ccode\x3edefault\x3c\/code\x3e，而在Gulp3中你可以把它放在任何地方。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 任务直接不再有依赖\ngulp.task(\x27styles\x27, function() {...});\ngulp.task(\x27scripts\x27, function() {...});\ngulp.task(\x27clean\x27, function() {...});\n\n\/\/ default任务，需要依赖scripts和styles\ngulp.task(\x27default\x27, gulp.series(\x27clean\x27, gulp.parallel(\x27scripts\x27, \x27styles\x27)));\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e\/\/ 任务直接不再有依赖\ngulp.task(\x27styles\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\ngulp.task(\x27scripts\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\ngulp.task(\x27clean\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\n\n\/\/ default任务，需要依赖scripts和styles\ngulp.task(\x27default\x27, gulp.series(\x27clean\x27, gulp.parallel(\x27scripts\x27, \x27styles\x27)));\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果照这么写，当你单独运行\x3ccode\x3estyles\x3c\/code\x3e和\x3ccode\x3escripts\x3c\/code\x3e任务时，\x3ccode\x3eclean\x3c\/code\x3e任务就不会优先自动执行。不过这问题也不大，在之前单独运行\x3ccode\x3eclean\x3c\/code\x3e任务就可以了，一样能把scripts和styles的文件夹清空。又或者你可以重新定义一下你的任务，随你，我也不确定怎样会更好。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e异步任务支持\x3c\/h3\x3e\n\x3cp\x3e如果你执行的是同步任务，在Gulp3中不需要写任何其他代码，但是在Gulp4中就不能如此轻松了：现在也你必须运行done回调（这可能是我最早发现的一个变化）。然后如果你执行的是异步任务，你则有三个选择来确保Gulp能够检测到你的任务真的完成了，方法如下：\x3c\/p\x3e\n\x3ch4\x3e1) 回调\x3c\/h4\x3e\n\x3cp\x3e你可以在你的任务函数的参数中提供一个回调函数并且在你的任务完成后调用它：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var del = require(\x27del\x27);\n\ngulp.task(\x27clean\x27, function(done) {\n    del([\x27.build\/\x27], done);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e del = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27del\x27\x3c\/span\x3e);\n\ngulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27clean\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edone\x3c\/span\x3e) \x3c\/span\x3e{\n    del([\x3cspan class=\x22hljs-string\x22\x3e\x27.build\/\x27\x3c\/span\x3e], done);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e2) 流\x3c\/h4\x3e\n\x3cp\x3e你也可以返回一个流，通常通过\x3ccode\x3egulp.src\x3c\/code\x3e或\x3ca href=\x22https:\/\/www.npmjs.com\/package\/vinyl-source-stream\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evinyl-source-stream\x3c\/a\x3e这个库来创建。这一般也是最常用的方式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(\x27somename\x27, function() {\n    return gulp.src(\x27client\/**\/*.js\x27)\n        .pipe(minify())\n        .pipe(gulp.dest(\x27build\x27));\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3egulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27somename\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e gulp.src(\x3cspan class=\x22hljs-string\x22\x3e\x27client\/**\/*.js\x27\x3c\/span\x3e)\n        .pipe(minify())\n        .pipe(gulp.dest(\x3cspan class=\x22hljs-string\x22\x3e\x27build\x27\x3c\/span\x3e));\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e3) Promise\x3c\/h4\x3e\n\x3cp\x3ePromise这个技术早已声名鹊起而且在Node中已经有了完整的实现，所以这也会是一个很有用的方式。你只需要返回一个promise对象，Gulp就能知道任务在什么时候完成。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var promisedDel = require(\x27promised-del\x27);\n\ngulp.task(\x27clean\x27, function() {\n    return promisedDel([\x27.build\/\x27]);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e promisedDel = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27promised-del\x27\x3c\/span\x3e);\n\ngulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27clean\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e promisedDel([\x3cspan class=\x22hljs-string\x22\x3e\x27.build\/\x27\x3c\/span\x3e]);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e其他的异步任务支持\x3c\/h3\x3e\n\x3cp\x3e感谢Gulp现在引入了\x3ca href=\x22https:\/\/www.npmjs.com\/package\/async-done\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3easync-done\x3c\/a\x3e库，在最新的版本中我们有更多的方式来确认异步任务的完成。\x3c\/p\x3e\n\x3ch4\x3e4)子进程\x3c\/h4\x3e\n\x3cp\x3e你可以在你的任务中创建一些子进程并返回！比如，你可以把你的npm scripts放到Gulp中执行，这样你就不需要为你的package.json中加载了百万条命令而烦恼。你也可以通过这样的封装摆脱那些随时可能过时的gulp插件。尽管这看上去像一个反模式，不过你还是有很多可以优化它们的方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var spawn = require(\x27child_process\x27).spawn;\n\ngulp.task(\x27clean\x27, function() {\n  return spawn(\x27rm\x27, [\x27-rf\x27, path.join(__dirname, \x27build\x27)]);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e spawn = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27child_process\x27\x3c\/span\x3e).spawn;\n\ngulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27clean\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e spawn(\x3cspan class=\x22hljs-string\x22\x3e\x27rm\x27\x3c\/span\x3e, [\x3cspan class=\x22hljs-string\x22\x3e\x27-rf\x27\x3c\/span\x3e, path.join(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x27build\x27\x3c\/span\x3e)]);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e5)RxJS observable\x3c\/h4\x3e\n\x3cp\x3e我没用过RxJS，它好像挺小众的。不过对于那些RxJS的死忠粉丝，他们会很高兴可以返回一个observable对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Observable = require(\x27rx\x27).Observable;\n\ngulp.task(\x27sometask\x27, function() {\n    return Observable.return(42);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Observable = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27rx\x27\x3c\/span\x3e).Observable;\n\ngulp.task(\x3cspan class=\x22hljs-string\x22\x3e\x27sometask\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Observable.\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e监听\x3c\/h3\x3e\n\x3cp\x3e处理文件系统的监听和响应的API也有了一点进步。之前的API中，在我们传入一个glob通配符和可选参数后，我们可以再指定一个任务数组或者一个回调函数用来处理事件数据。可是现在，任务队列都是由serise或者parallel函数合并而成，这样你就无法用一个回调来区分这些任务，所以我们取消了这种简单监听回调的方式。取而代之的是，\x3ccode\x3egulp.watch\x3c\/code\x3e将像之前一样会返回一个的“观察”对象，不过你可以对它添加各种事件监听：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 旧版\ngulp.watch(\x27js\/**\/*.js\x27, function(event) {\n    console.log(\x27File \x27 \x2b event.path \x2b \x27 was \x27 \x2b event.type \x2b \x27, running tasks...\x27);\n});\n\n\/\/ 新版:\nvar watcher = gulp.watch(\x27js\/**\/*.js\x27 \/* 你可以在这里传一些参数或者函数 *\/);\nwatcher.on(\x27all\x27, function(event, path, stats) {\n  console.log(\x27File \x27 \x2b path \x2b \x27 was \x27 \x2b event \x2b \x27, running tasks...\x27);\n});\n\n\/\/ 单个事件的监听\nwatcher.on(\x27change\x27, function(path, stats) {\n  console.log(\x27File \x27 \x2b path \x2b \x27 was changed, running tasks...\x27);\n});\n\nwatcher.on(\x27add\x27, function(path) {\n  console.log(\x27File \x27 \x2b path \x2b \x27 was added, running tasks...\x27);\n});\n\nwatcher.on(\x27unlink\x27, function(path) {\n  console.log(\x27File \x27 \x2b path \x2b \x27 was removed, running tasks...\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 旧版\x3c\/span\x3e\ngulp.watch(\x3cspan class=\x22hljs-string\x22\x3e\x27js\/**\/*.js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27File \x27\x3c\/span\x3e \x2b event.path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 was \x27\x3c\/span\x3e \x2b event.type \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27, running tasks...\x27\x3c\/span\x3e);\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新版:\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e watcher = gulp.watch(\x3cspan class=\x22hljs-string\x22\x3e\x27js\/**\/*.js\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* 你可以在这里传一些参数或者函数 *\/\x3c\/span\x3e);\nwatcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x27all\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent, path, stats\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27File \x27\x3c\/span\x3e \x2b path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 was \x27\x3c\/span\x3e \x2b event \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27, running tasks...\x27\x3c\/span\x3e);\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 单个事件的监听\x3c\/span\x3e\nwatcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x27change\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epath, stats\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27File \x27\x3c\/span\x3e \x2b path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 was changed, running tasks...\x27\x3c\/span\x3e);\n});\n\nwatcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x27add\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epath\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27File \x27\x3c\/span\x3e \x2b path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 was added, running tasks...\x27\x3c\/span\x3e);\n});\n\nwatcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x27unlink\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epath\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27File \x27\x3c\/span\x3e \x2b path \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 was removed, running tasks...\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e正如所看到的，在\x3ccode\x3eall\x3c\/code\x3e和\x3ccode\x3echange\x3c\/code\x3e的事件处理中，你还可以接受一个stats对象。stats对象只在他们可用的时候出现（我也不确定他们什么时候可用什么时候不可用），不过你可以设置\x3ccode\x3ealwaysStat\x3c\/code\x3e选项的值为\x3ccode\x3etrue\x3c\/code\x3e来让它始终出现。Gulp使用了\x3ca href=\x22https:\/\/github.com\/paulmillr\/chokidar\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echokidar\x3c\/a\x3e库来实现这些东西，阅读chokidar的文档能让你了解的更多，尽管chokidar并不支持在事件回调中指定第三个参数。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e使用函数\x3c\/h3\x3e\n\x3cp\x3e由于现在每个任务基本上就是一个函数，不需要任何依赖或其他的什么，实际上他们也仅仅是需要一个任务运行器来确认异步任务何时结束，我们可以把函数定义从\x3ccode\x3egulp.task\x3c\/code\x3e中独立出来，而不仅仅作为一个简单回调函数传给\x3ccode\x3egulp.task\x3c\/code\x3e。举个例子，这个代码之前我们在“依赖陷阱”那个章节的结论：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(\x27styles\x27, function() {...});\ngulp.task(\x27scripts\x27, function() {...});\ngulp.task(\x27clean\x27, function() {...});\n\ngulp.task(\x27default\x27, gulp.series(\x27clean\x27, gulp.parallel(\x27scripts\x27, \x27styles\x27)));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3egulp.task(\x27styles\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\ngulp.task(\x27scripts\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\ngulp.task(\x27clean\x27, function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e);\n\ngulp.task(\x27default\x27, gulp.series(\x27clean\x27, gulp.parallel(\x27scripts\x27, \x27styles\x27)));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我把它变成：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 只需要在`series` 和 `parallel` 中间引用函数名就能组成一个新任务\ngulp.task(\x27default\x27, gulp.series(clean, gulp.parallel(scripts, styles)));\n\n\/\/ 把单个任务变成一个函数\nfunction styles() {...}\nfunction scripts() {...}\nfunction clean() {...}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e\/\/ 只需要在`series` 和 `parallel` 中间引用函数名就能组成一个新任务\ngulp.task(\x27default\x27, gulp.series(clean, gulp.parallel(scripts, styles)));\n\n\/\/ 把单个任务变成一个函数\nfunction styles() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\nfunction scripts() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\nfunction clean() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里有几点要注意的地方：\x3cbr\x3e1.由于js是有函数定义提升的，函数的定义可以放在你定义default任务之后，不像之前说的，如果你要用一些小任务组成一个新任务的时候，你就必须要先定义那些小任务。这样就使得你可以在一开始就定义好实际要运行的任务，这样别人阅读起来也更方便一些，以免别人还要在翻阅了一堆其他任务代码后，才能发现藏在最后的实际要运行的那些。\x3cbr\x3e2.\x3ccode\x3estyles\x3c\/code\x3e, \x3ccode\x3escripts\x3c\/code\x3e, 和 \x3ccode\x3eclean\x3c\/code\x3e 现在都相当于“私有”任务，他们无法通过gulp命令行来运行。\x3cbr\x3e3.这样就没有那么多匿名函数了。\x3cbr\x3e4.也没有那么多被引号包裹住的“任务”名了，这样意味着你可以通过你的代码编辑器\/IDE帮你检查拼写错误，而不用在运行Gulp的时候才能发现错误。\x3cbr\x3e5.即使把“任务”函数放在多个文件中定义，也能方便的把它们引用到同一个文件中，然后再通过\x3ccode\x3egulp.task\x3c\/code\x3e把它们变成实际可用的任务。\x3cbr\x3e6.这些任务都是可以独立测试的（如果你要测试）而不需要gulp。\x3c\/p\x3e\n\x3cp\x3e当然第2点也是可以修改的，如果你希望它们是可以被gulp命令行所执行的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(styles);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs abnf\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3egulp.task(styles)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样你就能新建了一个可以运行在命令行的“styles”任务。注意你可从来没有在代码中定义过它的名字。gulp.task可以很智能的把函数名转成任务名。当然，匿名函数是不行的：Gulp会抛出一个错误当你想要把匿名函数指定成一个任务，却没有给它起一个新名字。\x3c\/p\x3e\n\x3cp\x3e如果你想给函数起个别名，你可以在函数的\x3ccode\x3edisplayName\x3c\/code\x3e属性中指定它：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function styles(){...}\nstyles.displayName = \x26quot;pseudoStyles\x26quot;;\ngulp.task(styles);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3efunction styles()\x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\nstyles.displayName = \x3cspan class=\x22hljs-string\x22\x3e\x22pseudoStyles\x22\x3c\/span\x3e;\ngulp.task(styles);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在任务名将会从“styles”变成“pseudoStyles”。你也可以通过指定description属性来给你的任务添加描述。你可以通过gulp --tasks命令来查看这些描述：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function styles(){...}\nstyles.displayName = \x26quot;pseudoStyles\x26quot;;\nstyles.description = \x26quot;Does something with the stylesheets.\x26quot;\ngulp.task(styles);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3efunction styles()\x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\nstyles.displayName = \x3cspan class=\x22hljs-string\x22\x3e\x22pseudoStyles\x22\x3c\/span\x3e;\nstyles.description = \x3cspan class=\x22hljs-string\x22\x3e\x22Does something with the stylesheets.\x22\x3c\/span\x3e\ngulp.task(styles);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$ gulp --tasks\n[12:00:00] Tasks for ~\/project\/gulpfile.js\n[12:00:00] └── pseudoStyles  Does something with the stylesheets.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3e$ gulp \x3cspan class=\x22hljs-comment\x22\x3e--tasks\x3c\/span\x3e\n[\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e] Tasks \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ~\/project\/gulpfile.js\n[\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e] └── pseudoStyles  Does something \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e the stylesheets.\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你甚至可以给你其他已经注册的任务添加描述，比如\x3ccode\x3edefault\x3c\/code\x3e。首先你要运行\x3ccode\x3egulp.task(\x27taskName\x27)\x3c\/code\x3e来取人这个任务已经被定义过了，然后才给它添加描述：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(\x27default\x27, gulp.series(clean, gulp.parallel(scripts, styles)));\n\n\/\/ Use gulp.task to retrieve the task\nvar defaultTask = gulp.task(\x27default\x27);\n\/\/ give it a description\ndefaultTask.description = \x26quot;Does Default Stuff\x26quot;;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3egulp.\x3cspan class=\x22hljs-keyword\x22\x3etask\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e, gulp.series(clean, gulp.parallel(scripts, styles)));\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Use gulp.task to retrieve the task\x3c\/span\x3e\nvar defaultTask = gulp.\x3cspan class=\x22hljs-keyword\x22\x3etask\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ give it a description\x3c\/span\x3e\ndefaultTask.\x3cspan class=\x22hljs-keyword\x22\x3edescription\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x22Does Default Stuff\x22\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们也可以简化它，取消中间值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(\x27default\x27, gulp.series(clean, gulp.parallel(scripts, styles)));\ngulp.task(\x27default\x27).description = \x26quot;Does Default Stuff\x26quot;;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3egulp.\x3cspan class=\x22hljs-keyword\x22\x3etask\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e, gulp.series(clean, gulp.parallel(scripts, styles)));\ngulp.\x3cspan class=\x22hljs-keyword\x22\x3etask\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e).\x3cspan class=\x22hljs-keyword\x22\x3edescription\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x22Does Default Stuff\x22\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对那些不熟悉你的项目的人来说，这些描述是相当有用的。所以我建议在任何情况下都要添加它：有时它比注释还更有用。最后总结一下，这是我推荐的Gulp4的最佳实践：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22gulp.task(\x27default\x27, gulp.series(clean, gulp.parallel(scripts, styles)));\ngulp.task(\x27default\x27).description = \x26quot;This is the default task and it does certain things\x26quot;;\n\nfunction styles() {...}\nfunction scripts() {...}\nfunction clean() {...}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3egulp.task(\x27default\x27, gulp.series(clean, gulp.parallel(scripts, styles)));\ngulp.task(\x27default\x27).description = \x3cspan class=\x22hljs-string\x22\x3e\x22This is the default task and it does certain things\x22\x3c\/span\x3e;\n\nfunction styles() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\nfunction scripts() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\nfunction clean() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你运行\x3ccode\x3egulp --tasks\x3c\/code\x3e，你将会看到：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$ gulp --tasks\n[12:00:00] Tasks for ~\\localhost\\gulp4test\\gulpfile.js\n[12:00:00] └─┬ default  This is the default task and it does certain things\n[12:00:00]   └─┬ \x3cseries\x3e\n[12:00:00]     ├── clean\n[12:00:00]     └─┬ \x3cparallel\x3e\n[12:00:00]       ├── scripts\n[12:00:00]       └── styles\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scss\x22\x3e\x3ccode\x3e$ gulp --tasks\n\x3cspan class=\x22hljs-selector-attr\x22\x3e[12:00:00]\x3c\/span\x3e Tasks for ~\\localhost\\gulp4test\\gulpfile\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-attr\x22\x3e[12:00:00]\x3c\/span\x3e └─┬ default  This is the default task and it does certain things\n\x3cspan class=\x22hljs-selector-attr\x22\x3e[12:00:00]\x3c\/span\x3e   └─┬ \x26lt;series\x26gt;\n\x3cspan class=\x22hljs-selector-attr\x22\x3e[12:00:00]\x3c\/span\x3e     ├── clean\n\x3cspan class=\x22hljs-selector-attr\x22\x3e[12:00:00]\x3c\/span\x3e     └─┬ \x26lt;parallel\x26gt;\n\x3cspan class=\x22hljs-selector-attr\x22\x3e[12:00:00]\x3c\/span\x3e       ├── scripts\n\x3cspan class=\x22hljs-selector-attr\x22\x3e[12:00:00]\x3c\/span\x3e       └── styles\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你会发现这里不仅有你添加的描述，你还能看到完整的运行队列树。我也很乐意听到你对最佳实践有其他看法，不过在阐述结论前最好先跟你的团队讨论一下。\x3c\/p\x3e\n\x3cp\x3e不管怎么样，我还是很高兴看到Gulp4有很多有用的改进，但是它们也给迁移带来了不少痛苦。我希望这份指南能帮助你顺利迁移到Gulp4当它正式发布后（可能过几天……也可能……）。上帝保佑~\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【译】相对完整的Gulp4升级指南</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000005357048">https://segmentfault.com/a/1190000005357048</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/l5i4i60ylo9/" target="_blank">https://alili.tech/archive/l5i4i60ylo9/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>