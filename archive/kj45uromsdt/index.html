<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从零开始的 React 组件开发之路 (一)：表格篇"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从零开始的 React 组件开发之路 (一)：表格篇 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/kj45uromsdt/",
				"appid": "1613049289050283", 
				"title": "从零开始的 React 组件开发之路 (一)：表格篇 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-07T02:30:15"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/tiudy29d7mf/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/dsyh9jpnjx4/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fkj45uromsdt%2f&text=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84%20React%20%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e4%b9%8b%e8%b7%af%20%28%e4%b8%80%29%ef%bc%9a%e8%a1%a8%e6%a0%bc%e7%af%87"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fkj45uromsdt%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fkj45uromsdt%2f&text=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84%20React%20%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e4%b9%8b%e8%b7%af%20%28%e4%b8%80%29%ef%bc%9a%e8%a1%a8%e6%a0%bc%e7%af%87"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fkj45uromsdt%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84%20React%20%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e4%b9%8b%e8%b7%af%20%28%e4%b8%80%29%ef%bc%9a%e8%a1%a8%e6%a0%bc%e7%af%87"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fkj45uromsdt%2f&is_video=false&description=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84%20React%20%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e4%b9%8b%e8%b7%af%20%28%e4%b8%80%29%ef%bc%9a%e8%a1%a8%e6%a0%bc%e7%af%87"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84%20React%20%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e4%b9%8b%e8%b7%af%20%28%e4%b8%80%29%ef%bc%9a%e8%a1%a8%e6%a0%bc%e7%af%87&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fkj45uromsdt%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fkj45uromsdt%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84%20React%20%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e4%b9%8b%e8%b7%af%20%28%e4%b8%80%29%ef%bc%9a%e8%a1%a8%e6%a0%bc%e7%af%87"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkj45uromsdt%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84%20React%20%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e4%b9%8b%e8%b7%af%20%28%e4%b8%80%29%ef%bc%9a%e8%a1%a8%e6%a0%bc%e7%af%87"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkj45uromsdt%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84%20React%20%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e4%b9%8b%e8%b7%af%20%28%e4%b8%80%29%ef%bc%9a%e8%a1%a8%e6%a0%bc%e7%af%87"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fkj45uromsdt%2f&title=%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84%20React%20%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e4%b9%8b%e8%b7%af%20%28%e4%b8%80%29%ef%bc%9a%e8%a1%a8%e6%a0%bc%e7%af%87"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从零开始的 React 组件开发之路 (一)：表格篇</h1><div class="meta"><div class="postdate"><time datetime="2019-02-07" itemprop="datePublished">2019-02-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3eReact 下的表格狂想曲\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e0. 前言\x3c\/h2\x3e\n\x3cp\x3e欢迎大家阅读「从零开始的 React 组件开发之路」系列第一篇，表格篇。本系列的特色是从 需求分析、API 设计和代码设计 三个递进的过程中，由简到繁地开发一个 React 组件，并在讲解过程中穿插一些 React 组件开发的技巧和心得。  \x3c\/p\x3e\n\x3cp\x3e为什么从表格开始呢？在企业系统中，表格是最常见但功能需求最丰富的组件之一，同时也是基于 React 数据驱动的思想受益最多的组件之一，十分具有代表性。这篇文章也是近期南京谷歌开发者大会前端专场的分享总结。UXCore table 组件 \x3ca href=\x22http:\/\/uxco.re\/components\/table\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDemo\x3c\/a\x3e 也可以和本文行文思路相契合，可做参考。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006770470?w=907\x26amp;h=552\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006770470?w=907\x26amp;h=552\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e1. 一个简单 React 表格的构造\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e1.1 需求分析\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e有表头，每行的展示方式相同，只是数据上有所不同\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e每一列可能有不同的对齐方式，可能有不同的展示类型，比如金额，比如手机号码等\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e1.2 API 设计\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e因为每一列的展示类型不同，因此列配置应该作为一个 Prop，由于有多列应该是一个数组\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e数据源应该作为基础配置之一，应该作为一个 prop，由于有多行也应该是一个数组\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e现在的样子：\x26lt;Table columns={[]} data={[]} \/\x26gt;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e基本思路是通过遍历列配置来生成每一行\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3edata 中的每一个元素应该是一行的数据，是一个 hash 对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    city: \x27北京\x27,\n    name: \x27小李\x27\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3ecity\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27北京\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27小李\x27\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3ecolumns 中的每一个元素是一列的配置，也是一个 hash 对象，至少应该包括如下几部分：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    title: \x27表头\x27,\n    dataKey: \x27city\x27, \/\/ 该列使用行中的哪个 key 进行显示\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27表头\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edataKey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27city\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 该列使用行中的哪个 key 进行显示\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e易用性与通用性的平衡\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e易用性与通用性互相制衡，但并不是绝对矛盾。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e何为易用？使用尽量少的配置来完成最典型的场景。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e何为通用？提供尽量多的定制接口已适应各种不同场景。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在 API 设计上尽量开放保证通用性\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在默认值上提炼最典型的场景提高易用性。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e从易用性角度出发\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    align: \x27left\x27, \/\/ 默认左对齐\n    type: \x27money\/action\x27, \/\/ 提供 \x27money\x27, \x27card\x27, \x27cnmobile\x27 等常用格式化形式\n    delimiter: \x27,\x27, \/\/ 格式化时的分隔符，默认是空格\n    actions: { \/\/ 表格中常见的操作列，不以数据进行渲染，只包含动作，hash 对象使配置最简化\n      \x26quot;编辑\x26quot;: function() {doEdit();}\n    }, \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3ealign\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27left\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认左对齐\x3c\/span\x3e\n    type: \x3cspan class=\x22hljs-string\x22\x3e\x27money\/action\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 提供 \x27money\x27, \x27card\x27, \x27cnmobile\x27 等常用格式化形式\x3c\/span\x3e\n    delimiter: \x3cspan class=\x22hljs-string\x22\x3e\x27,\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 格式化时的分隔符，默认是空格\x3c\/span\x3e\n    actions: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 表格中常见的操作列，不以数据进行渲染，只包含动作，hash 对象使配置最简化\x3c\/span\x3e\n      \x3cspan class=\x22hljs-string\x22\x3e\x22编辑\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{doEdit();}\n    }, \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e从通用性角度出发\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    actions: [ \/\/ 相对繁琐，但定制能力更强\n      {\n          title: \x27编辑\x27,\n          callback: function() {doEdit();},\n          render: function(rowData) {\n              \/\/ 根据当前行数据，决定是否渲染，及渲染成定制的样子\n          }\n      }\n    ],\n    render: function(cellData, rowData) {\n        \/\/ 根据当前行数据，完全由用户决定如何渲染\n        return \x3cspan\x3e{`${rowData.city} - ${rowData.name}`}\x3c\/span\x3e\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3eactions\x3c\/span\x3e: [ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 相对繁琐，但定制能力更强\x3c\/span\x3e\n      {\n          \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27编辑\x27\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-attr\x22\x3ecallback\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{doEdit();},\n          \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erowData\x3c\/span\x3e) \x3c\/span\x3e{\n              \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据当前行数据，决定是否渲染，及渲染成定制的样子\x3c\/span\x3e\n          }\n      }\n    ],\n    \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecellData, rowData\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据当前行数据，完全由用户决定如何渲染\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e{`${rowData.city} - ${rowData.name}`}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3e提供定制化渲染的两种方式：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e渲染函数 (更推荐)\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    render: function(rowData) {\n        return \x3cCustomComp url={rowData.url} \/\x3e\n    },\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erowData\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCustomComp\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{rowData.url}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    },\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e渲染组件\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    renderComp: \x3cCustomComp \/\x3e, \/\/ 内部接收 rowData 作为参数\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n    \x3cspan class=\x22hljs-attr\x22\x3erenderComp\x3c\/span\x3e: \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCustomComp\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, \/\/ 内部接收 rowData 作为参数\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3e推荐渲染函数的原因：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e函数在做属性比较时，更简单\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e约定更少，渲染组件的方式需要配合 \x3ccode\x3eTable\x3c\/code\x3e 预留比如 \x3ccode\x3erowData\x3c\/code\x3e 一类的接口，不够灵活。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e1.3 代码设计\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006004249\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006004249\x22 alt=\x22Table 分层\x22 title=\x22Table 分层\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e图：Table 的分层设计\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006004251\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006004251\x22 alt=\x22table 简单架构\x22 title=\x22table 简单架构\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e图：最初的 Table 结构，详细的分层为后续的功能扩展做好准备。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e2. 加入更多的内置功能\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3e目前的表格可以满足我们的最简单常用的场景，但仍然有很多经常需要使用的功能没有支持，如列排序，分页，搜索过滤、常用动作条、行选择和行筛选等。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e2.1 需求分析\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e列排序：升序\/降序\/默认顺序 Head\/Cell 相关\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e分页：当表格需要展示的条数很多时，分页展示固定的条数 Table\/Pagination 相关，这里假设已有 Pagination 组件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e搜索过滤：Table 相关\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e常用操作：Table 相关\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e行选择：选中某些行，Row\/Cell 相关\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e行筛选：手动展示或者隐藏一些行，不属于任何一列，因此是 Table 级\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e2.2 API 设计\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e根据上面对于功能的需求分析，我们很容易定位 API 的位置，完成相应的扩展。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ table 配置，需求对应的模块对应了他的配置在整个配置中的位置\n{\n    columns: [ \/\/ HEAD\/ROW 相关\n        {\n            order: true, \/\/ 是否展示排序按钮\n            hidden: false, \/\/ 是否隐藏，行筛选需要\n        }\n    ],\n    onOrder: function (activeColumn, order) { \/\/ 排序时的回调\n        doOrder(activeColumn, order)\n    }, \n    actionBar: { \/\/ 常用操作条\n        \x26quot;打印\x26quot;: function() {doPrint()}, \n    },\n    showSeach: true, \/\/ 是否显示搜索过滤，为什么不直接用下面的，这里也是设计上的一个优化点\n    onSearch: function(keyword) { doSearch(keyword) }, \/\/ 搜索时的回调\n    showPager: true, \/\/ 是否显示分页\n    onPagerChange: function(current, pageSize) {}, \/\/ 分页改变时的回调\n    rowSelection: { \/\/ 行选择相关\n        onSelect: function(isSelected, currentRow, selectedRows) { \n            doSelect() \n        }\n    }\n}\n\/\/ data 结构\n{\n    data: [{\n        city: \x27xxx\x27,\n        name: \x27xxx\x27,\n        __selected__: true, \/\/ 行选择相关，用以标记该行是否被选中，用前后的 __ 来做特殊标记，另一方面也尽可能避免与用户的字段重复\n    }],\n    currentPage: 1, \/\/ 当前页数\n    totalCount: 50, \/\/ 总条数\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ table 配置，需求对应的模块对应了他的配置在整个配置中的位置\x3c\/span\x3e\n{\n    \x3cspan class=\x22hljs-attr\x22\x3ecolumns\x3c\/span\x3e: [ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ HEAD\/ROW 相关\x3c\/span\x3e\n        {\n            \x3cspan class=\x22hljs-attr\x22\x3eorder\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否展示排序按钮\x3c\/span\x3e\n            hidden: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否隐藏，行筛选需要\x3c\/span\x3e\n        }\n    ],\n    \x3cspan class=\x22hljs-attr\x22\x3eonOrder\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eactiveColumn, order\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 排序时的回调\x3c\/span\x3e\n        doOrder(activeColumn, order)\n    }, \n    \x3cspan class=\x22hljs-attr\x22\x3eactionBar\x3c\/span\x3e: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 常用操作条\x3c\/span\x3e\n        \x3cspan class=\x22hljs-string\x22\x3e\x22打印\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{doPrint()}, \n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eshowSeach\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否显示搜索过滤，为什么不直接用下面的，这里也是设计上的一个优化点\x3c\/span\x3e\n    onSearch: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ekeyword\x3c\/span\x3e) \x3c\/span\x3e{ doSearch(keyword) }, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 搜索时的回调\x3c\/span\x3e\n    showPager: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否显示分页\x3c\/span\x3e\n    onPagerChange: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecurrent, pageSize\x3c\/span\x3e) \x3c\/span\x3e{}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 分页改变时的回调\x3c\/span\x3e\n    rowSelection: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 行选择相关\x3c\/span\x3e\n        onSelect: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eisSelected, currentRow, selectedRows\x3c\/span\x3e) \x3c\/span\x3e{ \n            doSelect() \n        }\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ data 结构\x3c\/span\x3e\n{\n    \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: [{\n        \x3cspan class=\x22hljs-attr\x22\x3ecity\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27xxx\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27xxx\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3e__selected__\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 行选择相关，用以标记该行是否被选中，用前后的 __ 来做特殊标记，另一方面也尽可能避免与用户的字段重复\x3c\/span\x3e\n    }],\n    \x3cspan class=\x22hljs-attr\x22\x3ecurrentPage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前页数\x3c\/span\x3e\n    totalCount: \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 总条数\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e2.3 代码设计\x3c\/h3\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e结构图\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006004253\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006004253\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e图：扩展后的 Table 结构\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e内部数据的处理\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e目前组件的数据流向还比较简单，我们似乎可以全部通过 props 来控制状态，制作一个 stateless 的组件。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e何时该用 state？何时该用 props？\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3eUI=fn(state, props)\x3c\/strong\x3e, 人们常说 React 组件是一个状态机，但我们应该清楚的是他是由 state 和 props 构成的双状态机;\x3c\/p\x3e\n\x3cp\x3eprops 和 state 的改变都会触发组件的重新渲染，那么我们使用它们的时机分别是什么呢？由于 state 是组件自身维护的，并不与他的父级组件进行沟通，进而也无法与他的兄弟组件进行沟通，因此我们应该尽量只在页面的根节点组件或者复杂组件的根节点组件使用 state，而在其他情况下尽量只使用 props，这可以增强整个 React 项目的可预知性和可控性。\x3c\/p\x3e\n\x3cp\x3e但凡事不是绝对的，全都使用 Props 固然可以使组件可维护性变强，但全部交给用户来操作会使用户的使用成本大大提高，利用 state，我们可以让组件自己维护一些状态，从而减轻用户使用的负担。\x3c\/p\x3e\n\x3cp\x3e我们举个简单的例子\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\/* 受控模式 *\/}\n\x3cinput value=\x26quot;a\x26quot; onChange={ function() {doChange()} } \/\x3e\n{\/* 非受控模式 *\/}\n\x3cinput onChange={ function() {doChange()} } \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/* 受控模式 *\/\x3c\/span\x3e}\n\x26lt;input value=\x3cspan class=\x22hljs-string\x22\x3e\x22a\x22\x3c\/span\x3e onChange={ \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{doChange()} } \/\x26gt;\n{\x3cspan class=\x22hljs-comment\x22\x3e\/* 非受控模式 *\/\x3c\/span\x3e}\n\x26lt;input onChange={ \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{doChange()} } \/\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3evalue 配置时，input 的值由 value 控制，value 没有配置时，input 的值由自己控制，如果把 \x26lt;input \/\x26gt; 看做一个组件，那么此时可以认为 input 此时有一个 state 是 value。显然，无 value 状态下的配置更少，降低了使用的成本，我们在做组件时也可以参考这种模式。\x3c\/p\x3e\n\x3cp\x3e例如在我们希望为用户提供 \x3ccode\x3e行选择\x3c\/code\x3e 的功能时，用户通常是不希望自己去控制行的变化的，而只是关心行的变化时应该拿取的数据，此时我们就可以将 data 这个 prop 变成 state。有一点需要注意的是，用户的 prop\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Table extends React.Component {\n    constructor(props) {\n        super(props);\n        this.data = deepcopy(props.data);\n        this.state = {\n            data: this.data,\n        };\n    }\n    \n    \/**\n     * 在 data 发生改变时，更改对应的 state 值。\n     *\/\n    componentWillReceiveProps(nextProps, nextState) {\n        if (!deepEqual(nextProps.data, this.data) {\n            this.data = deepcopy(nextProps.data);\n            this.setState({\n                data: this.data,\n            });\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTable\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = deepcopy(props.data);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n            \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data,\n        };\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * 在 data 发生改变时，更改对应的 state 值。\n     *\/\x3c\/span\x3e\n    componentWillReceiveProps(nextProps, nextState) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!deepEqual(nextProps.data, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = deepcopy(nextProps.data);\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n                \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data,\n            });\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里涉及的一个很重要的点，就是如何处理一个复杂类型数据的 prop 作为 state。因为 JS 对象传地址的特性，如果我们直接对比 \x3ccode\x3enextProps.data\x3c\/code\x3e 和 \x3ccode\x3ethis.props.data\x3c\/code\x3e 有些情况下会永远相等(当用户直接修改 data 的情况下)，所以我们需要对这个 prop 做一个备份。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e生命周期的使用时机\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007277146?w=853\x26amp;h=954\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007277146?w=853\x26amp;h=954\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e图：React 的生命周期\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3econstructor: 尽量简洁，只做最基本的 state 初始化\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ewillMount: 一些内部使用变量的初始化\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3erender: 触发非常频繁，尽量只做渲染相关的事情。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3edidMount: 一些不影响初始化的操作应该在这里完成，比如根据浏览器不同进行操作，获取数据，监听 document 事件等（server render）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ewillUnmount: 销毁操作，销毁计时器，销毁自己的事件监听等。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ewillReceiveProps: 当有 prop 做 state 时，监听 prop 的变化去改变 state，在这个生命周期里 setState 不会触发两次渲染。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eshouldComponentUpdate: 手动判断组件是否应该更新，避免因为页面更新造成的无谓更新，组件的重要优化点之一。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ewillUpdate: 在 state 变化后如果需要修改一些变量，可以在这里执行。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3edidUpdate: 与 didMount 类似，进行一些不影响到 render 的操作，update 相关的生命周期里最好不要做 setState 操作，否则容易造成死循环。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e父子级组件间的通信\x3c\/h3\x3e\n\x3cp\x3e父级向子级通信不用多说，使用 prop 进行传递，那么子级向父级通信呢？有人会说，靠回调啊~ onChange等等，本质上是没有错误的，但当组件比较复杂，存在多级结构时，如果每一级都去处理他的子级的回调的话，不仅写起来非常麻烦，而且很多时候是没有意义的。\x3c\/p\x3e\n\x3cp\x3e我们采取的办法是，只在顶级组件也就是 Table 这一层控制所有的 state，其他的各个子层都是完全由 prop 来控制，这样一来，我们只需要 Table 去操作数据，那么我们逐级向下传递一个属于 Table 的回调函数，完成所有子级都只向 Table 做“汇报”，进行跨级通信。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006004257\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006004257\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e图：父子级间的通信\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e3. 自行获取数据\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e3.1 需求分析\x3c\/h3\x3e\n\x3cp\x3e作为一个尽可能为用户提高效率的组件，除了手动传入 data 外，我们也应该有自行获取数据的能力，用户只需要配置 url 和相应的参数就可以完成表格的配置，为此我们可能需要以下参数：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e数据源，返回的数据格式应和我们之前定义的 data 数据结构一致。 (易用)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e随请求一起发出去的参数。(通用)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在发请求前的回调，可以在这里调整发送的参数。(通用)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e请求回来后的回调，可以在这里调整数据结构以满足对 data 的要求。(通用)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e同时要考虑到内置功能的适配。(易用)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e3.2 API 设计\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ table 配置，需求对应的模块对应了他的配置在整个配置中的位置\n{\n    url: \x26quot;\/\/fetchurl.com\/data\x26quot;, \/\/ 数据源，只支持 json 和 jsonp\n    fetchParams: { \/\/ 额外的一些参数\n        token: \x26quot;xxxabxc_sa\x26quot;\n    },\n    beforeFetch: function(data, from) { \/\/ data 为要发送的参数，from 参数用来区分发起 fetch 的来源(分页，排序，搜索还是其他位置)\n        return data; \/\/ 返回值为真正发送的参数\n    },\n    afterFetch: function(result) { \/\/ result 为请求回来的数据\n        return process(result); \/\/ 返回值为真正交给 table 进行展示的数据。\n    },\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ table 配置，需求对应的模块对应了他的配置在整个配置中的位置\x3c\/span\x3e\n{\n    \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22\/\/fetchurl.com\/data\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据源，只支持 json 和 jsonp\x3c\/span\x3e\n    fetchParams: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 额外的一些参数\x3c\/span\x3e\n        token: \x3cspan class=\x22hljs-string\x22\x3e\x22xxxabxc_sa\x22\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3ebeforeFetch\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata, from\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ data 为要发送的参数，from 参数用来区分发起 fetch 的来源(分页，排序，搜索还是其他位置)\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e data; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回值为真正发送的参数\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eafterFetch\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ result 为请求回来的数据\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e process(result); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回值为真正交给 table 进行展示的数据。\x3c\/span\x3e\n    },\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3e3.3 代码设计\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e基于前面良好的通信模式，url 的扩展变得非常简单，只需要在所有的回调中加入是否配置 url 的判断即可。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Table extends React.Component {\n    constructor(props) {\n        super(props);\n        this.data = deepcopy(props.data);\n        this.fetchParams = deepcopy(props.fetchParams);\n        this.state = {\n            data: this.data,\n        };\n    }\n    \n    \/**\n     * 获取数据的方法\n     *\/\n    fetchData(props, from) {\n        props = props || this.props;\n        const otherParams = process(this.state);\n        ajax(props.url, this.fetchParams, otherParams, from);\n    }\n    \n    \/**\n     * 搜索时的回调\n     *\/\n    handleSearch(key) {\n        if (this.props.url) {\n            this.setState({\n                searchKey: key,\n            }, () =\x3e {\n                this.fetchData();\n            });\n        } else {\n            this.props.onSearch(key);\n        }\n        \n    }\n    \n    componentDidMount() {\n        if (this.props.url) {\n            this.fetchData();\n        }\n    }\n\n    componentWillReceiveProps(nextProps, nextState) {\n        let newState = {};\n        if (!deepEqual(nextProps.data, this.data) {\n            this.data = deepcopy(nextProps.data);\n            newState[\x27data\x27] = this.data; \n        }\n        if (!deepEqual(nextProps.fetchParams, this.fetchParams)) {\n            this.fetchParams = deepcopy(nextProps.fetchParams);\n            this.fetchData();\n        }\n        if (nextProps.url !== this.props.url) {\n            this.fetchData(nextProps);\n        }\n        if (Object.keys(newState) !== 0) {\n            this.setState(newState);\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTable\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = deepcopy(props.data);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fetchParams = deepcopy(props.fetchParams);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n            \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data,\n        };\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * 获取数据的方法\n     *\/\x3c\/span\x3e\n    fetchData(props, \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e) {\n        props = props || \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e otherParams = process(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state);\n        ajax(props.url, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fetchParams, otherParams, \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e);\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * 搜索时的回调\n     *\/\x3c\/span\x3e\n    handleSearch(key) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.url) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n                \x3cspan class=\x22hljs-attr\x22\x3esearchKey\x3c\/span\x3e: key,\n            }, () =\x26gt; {\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fetchData();\n            });\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.onSearch(key);\n        }\n        \n    }\n    \n    componentDidMount() {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.url) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fetchData();\n        }\n    }\n\n    componentWillReceiveProps(nextProps, nextState) {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newState = {};\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!deepEqual(nextProps.data, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = deepcopy(nextProps.data);\n            newState[\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e] = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data; \n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!deepEqual(nextProps.fetchParams, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fetchParams)) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fetchParams = deepcopy(nextProps.fetchParams);\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fetchData();\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextProps.url !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.url) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fetchData(nextProps);\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(newState) !== \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(newState);\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader19\x22\x3e4. 行内编辑\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader20\x22\x3e4.1 需求分析\x3c\/h3\x3e\n\x3cp\x3e通过双击或者点击编辑按钮，实现行内可编辑状态的切换。如果只是变成普通的文本框那就太 low 了，有追求的我们希望每个列根据数据类型可以有不同的编辑形式。既然是可编辑的，那么关于表单的一套东西都适用，他要可以验证，可以重置，也可以联动。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader21\x22\x3e4.2 API 设计\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ table 配置，需求对应的模块对应了他的配置在整个配置中的位置，显然行内编辑是和列相关的\n{\n    columns: [ \/\/ HEAD\/ROW 相关\n        {   \n            dataKey: \x27cityName\x27, \/\/ 展示时操作的变量\n            editKey: \x27cityValue\x27, \/\/ 编辑时操作的变量\n            customField: SelectField, \/\/ 编辑状态的类型\n            config: {}, \/\/ 编辑状态的一些配置\n            renderChildren: function() {\n                return [\n                {id: \x27bj\x27, name: \x27北京\x27},\n                {id: \x27hz\x27, name: \x27杭州\x27}].map((item) =\x3e {\n                    return \x3cOption key={item.id}\x3e{item.name}\x3c\/Option\x3e\n                });\n            },\n            rules: function(value) { \/\/ 校验相关\n                return true;\n            }\n        }\n    ],\n    onChange: function(result) {\n        doSth(result); \/\/ result 包括 {data: 表格的所有数据, changedData: 变动行的数据, dataKey: xxx, editKey: xxx, pass: 正在编辑的域是否通过校验}\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ table 配置，需求对应的模块对应了他的配置在整个配置中的位置，显然行内编辑是和列相关的\x3c\/span\x3e\n{\n    \x3cspan class=\x22hljs-attr\x22\x3ecolumns\x3c\/span\x3e: [ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ HEAD\/ROW 相关\x3c\/span\x3e\n        {   \n            \x3cspan class=\x22hljs-attr\x22\x3edataKey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27cityName\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 展示时操作的变量\x3c\/span\x3e\n            editKey: \x3cspan class=\x22hljs-string\x22\x3e\x27cityValue\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编辑时操作的变量\x3c\/span\x3e\n            customField: SelectField, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编辑状态的类型\x3c\/span\x3e\n            config: {}, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编辑状态的一些配置\x3c\/span\x3e\n            renderChildren: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e [\n                {\x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27bj\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27北京\x27\x3c\/span\x3e},\n                {\x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27hz\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27杭州\x27\x3c\/span\x3e}].map(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eOption\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{item.id}\x3c\/span\x3e\x26gt;\x3c\/span\x3e{item.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eOption\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n                });\n            },\n            \x3cspan class=\x22hljs-attr\x22\x3erules\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 校验相关\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n            }\n        }\n    ],\n    \x3cspan class=\x22hljs-attr\x22\x3eonChange\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e) \x3c\/span\x3e{\n        doSth(result); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ result 包括 {data: 表格的所有数据, changedData: 变动行的数据, dataKey: xxx, editKey: xxx, pass: 正在编辑的域是否通过校验}\x3c\/span\x3e\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ data 结构\n{\n    data: [{\n        cityName: \x27xxx\x27,\n        cityValue: \x27yyy\x27,\n        name: \x27xxx\x27,\n        __selected__: true, \n        __mode__: \x26quot;edit\x26quot;, \/\/ 用来区分当前行的状态\n    }],\n    currentPage: 1, \/\/ 当前页数\n    totalCount: 50, \/\/ 总条数\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ data 结构\x3c\/span\x3e\n{\n    \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: [{\n        \x3cspan class=\x22hljs-attr\x22\x3ecityName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27xxx\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ecityValue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27yyy\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27xxx\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3e__selected__\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \n        \x3cspan class=\x22hljs-attr\x22\x3e__mode__\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22edit\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用来区分当前行的状态\x3c\/span\x3e\n    }],\n    \x3cspan class=\x22hljs-attr\x22\x3ecurrentPage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前页数\x3c\/span\x3e\n    totalCount: \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 总条数\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader22\x22\x3e4.3 代码设计\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006004259\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006004259\x22 alt=\x22table edit mode\x22 title=\x22table edit mode\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e图：行内编辑模式下的表格架构\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e所有的 CellField 继承一个基类 Field，这个基类提供通用的与 Table 通信，校验的方式，具体的 Field 只负责交互部分的实现。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e下面是这部分设计的具体代码实现，碍于篇幅，不在文章中直接贴出。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/uxcore\/uxcore-table\/blob\/master\/src\/Cell\/CellField.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/uxcore\/uxc...\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/uxcore\/uxcore-table\/blob\/master\/src\/Cell\/SelectField.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/uxcore\/uxc...\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader23\x22\x3e5. 总结\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3e这篇文章以复杂表格组件的开发为切入点，讨论了以下内容：\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e组件设计的通用流程\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件分层架构与 API 的对应设计\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件设计中易用性与通用性的权衡\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eState 和 Props 的正确使用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e生命周期的实战应用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e父子级间组件通信\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e碍于整体篇幅，有一些和这个组件相关的点未详细讨论，我们会在本系列的后续文章中详细说明。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e数据的 不可变性（immutability）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eshouldComponentUpdate 和 pure render\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e树形表格 和 数据的递归处理\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在目前架构上进行折叠面板的扩展\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader24\x22\x3e最后\x3c\/h2\x3e\n\x3cp\x3e惯例地来宣传一下团队开源的 React PC 组件库 \x3ca href=\x22https:\/\/github.com\/uxcore\/uxcore\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUXCore\x3c\/a\x3e ，上面提到的点，在我们的\x3ca href=\x22https:\/\/github.com\/uxcore\/uxcore-tools\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e组件开发工具\x3c\/a\x3e中都有体现，欢迎大家一起讨论，也欢迎在我们的 \x3ca href=\x22https:\/\/segmentfault.com\/t\/uxcore\x22\x3eSegmentFault 专题\x3c\/a\x3e下进行提问讨论。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006768158?w=1000\x26amp;h=500\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006768158?w=1000\x26amp;h=500\x22 alt=\x22uxcore\x22 title=\x22uxcore\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>从零开始的 React 组件开发之路 (一)：表格篇</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006004245">https://segmentfault.com/a/1190000006004245</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/kj45uromsdt/" target="_blank">https://alili.tech/archive/kj45uromsdt/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>