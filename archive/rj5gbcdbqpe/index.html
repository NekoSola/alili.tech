<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="前端面试绝对会考的JS问题！【已经开源】"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>前端面试绝对会考的JS问题！【已经开源】 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/rj5gbcdbqpe/",
				"appid": "1613049289050283", 
				"title": "前端面试绝对会考的JS问题！【已经开源】 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-15T02:30:44"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/c34420j4015/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/yxohjyl6zxe/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2frj5gbcdbqpe%2f&text=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%bb%9d%e5%af%b9%e4%bc%9a%e8%80%83%e7%9a%84JS%e9%97%ae%e9%a2%98%ef%bc%81%e3%80%90%e5%b7%b2%e7%bb%8f%e5%bc%80%e6%ba%90%e3%80%91"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2frj5gbcdbqpe%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2frj5gbcdbqpe%2f&text=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%bb%9d%e5%af%b9%e4%bc%9a%e8%80%83%e7%9a%84JS%e9%97%ae%e9%a2%98%ef%bc%81%e3%80%90%e5%b7%b2%e7%bb%8f%e5%bc%80%e6%ba%90%e3%80%91"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2frj5gbcdbqpe%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%bb%9d%e5%af%b9%e4%bc%9a%e8%80%83%e7%9a%84JS%e9%97%ae%e9%a2%98%ef%bc%81%e3%80%90%e5%b7%b2%e7%bb%8f%e5%bc%80%e6%ba%90%e3%80%91"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2frj5gbcdbqpe%2f&is_video=false&description=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%bb%9d%e5%af%b9%e4%bc%9a%e8%80%83%e7%9a%84JS%e9%97%ae%e9%a2%98%ef%bc%81%e3%80%90%e5%b7%b2%e7%bb%8f%e5%bc%80%e6%ba%90%e3%80%91"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%bb%9d%e5%af%b9%e4%bc%9a%e8%80%83%e7%9a%84JS%e9%97%ae%e9%a2%98%ef%bc%81%e3%80%90%e5%b7%b2%e7%bb%8f%e5%bc%80%e6%ba%90%e3%80%91&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2frj5gbcdbqpe%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2frj5gbcdbqpe%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%bb%9d%e5%af%b9%e4%bc%9a%e8%80%83%e7%9a%84JS%e9%97%ae%e9%a2%98%ef%bc%81%e3%80%90%e5%b7%b2%e7%bb%8f%e5%bc%80%e6%ba%90%e3%80%91"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frj5gbcdbqpe%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%bb%9d%e5%af%b9%e4%bc%9a%e8%80%83%e7%9a%84JS%e9%97%ae%e9%a2%98%ef%bc%81%e3%80%90%e5%b7%b2%e7%bb%8f%e5%bc%80%e6%ba%90%e3%80%91"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frj5gbcdbqpe%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%bb%9d%e5%af%b9%e4%bc%9a%e8%80%83%e7%9a%84JS%e9%97%ae%e9%a2%98%ef%bc%81%e3%80%90%e5%b7%b2%e7%bb%8f%e5%bc%80%e6%ba%90%e3%80%91"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frj5gbcdbqpe%2f&title=%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%bb%9d%e5%af%b9%e4%bc%9a%e8%80%83%e7%9a%84JS%e9%97%ae%e9%a2%98%ef%bc%81%e3%80%90%e5%b7%b2%e7%bb%8f%e5%bc%80%e6%ba%90%e3%80%91"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">前端面试绝对会考的JS问题！【已经开源】</h1><div class="meta"><div class="postdate"><time datetime="2019-02-15" itemprop="datePublished">2019-02-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3e写在前面\x3c\/h3\x3e\n\x3cp\x3e【前端指南】前端面试库已经开源，正在完善之中\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e[x] \x3ca href=\x22https:\/\/github.com\/nanhupatar\/FEGuide\/blob\/master\/CSS%E9%97%AE%E9%A2%98\/css.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecss问题\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3e[x] \x3ca href=\x22https:\/\/github.com\/nanhupatar\/FEGuide\/blob\/master\/HTML%E9%97%AE%E9%A2%98\/html.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehtml问题\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3e[x] \x3ca href=\x22https:\/\/github.com\/nanhupatar\/FEGuide\/blob\/master\/javascript%E9%97%AE%E9%A2%98\/javascript.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejavascript问题\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3egithub地址   \x3ca href=\x22https:\/\/github.com\/nanhupatar\/FEGuide\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/nanhupatar...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000016717265?w=430\x26amp;h=430\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016717265?w=430\x26amp;h=430\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eJavaScript 的组成\x3c\/h3\x3e\n\x3cp\x3eJavaScript 由以下三部分组成：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eECMAScript（核心）：JavaScript 语言基础\x3c\/li\x3e\n\x3cli\x3eDOM（文档对象模型）：规定了访问 HTML 和 XML 的接口\x3c\/li\x3e\n\x3cli\x3eBOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eJS 的基本数据类型和引用数据类型\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e基本数据类型：undefined、null、boolean、number、string、symbol\x3c\/li\x3e\n\x3cli\x3e引用数据类型：object、array、function\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e检测浏览器版本版本有哪些方式？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e根据 navigator.userAgent \/\/ UA.toLowerCase().indexOf(\x27chrome\x27)\x3c\/li\x3e\n\x3cli\x3e根据 window 对象的成员 \/\/ \x27ActiveXObject\x27 in window\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e介绍 JS 有哪些内置对象？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e数据封装类对象：Object、Array、Boolean、Number、String\x3c\/li\x3e\n\x3cli\x3e其他对象：Function、Arguments、Math、Date、RegExp、Error\x3c\/li\x3e\n\x3cli\x3eES6 新增对象：Symbol、Map、Set、Promises、Proxy、Reflect\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e说几条写 JavaScript 的基本规范？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e代码缩进，建议使用“四个空格”缩进\x3c\/li\x3e\n\x3cli\x3e代码段使用花括号{}包裹\x3c\/li\x3e\n\x3cli\x3e语句结束使用分号;\x3c\/li\x3e\n\x3cli\x3e变量和函数在使用前进行声明\x3c\/li\x3e\n\x3cli\x3e以大写字母开头命名构造函数，全大写命名常量\x3c\/li\x3e\n\x3cli\x3e规范定义 JSON 对象，补全双引号\x3c\/li\x3e\n\x3cli\x3e用{}和[]声明对象和数组\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e如何编写高性能的 JavaScript？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e遵循严格模式：\x22use strict\x22;\x3c\/li\x3e\n\x3cli\x3e将 js 脚本放在页面底部，加快渲染页面\x3c\/li\x3e\n\x3cli\x3e将 js 脚本将脚本成组打包，减少请求\x3c\/li\x3e\n\x3cli\x3e使用非阻塞方式下载 js 脚本\x3c\/li\x3e\n\x3cli\x3e尽量使用局部变量来保存全局变量\x3c\/li\x3e\n\x3cli\x3e尽量减少使用闭包\x3c\/li\x3e\n\x3cli\x3e使用 window 对象属性方法时，省略 window\x3c\/li\x3e\n\x3cli\x3e尽量减少对象成员嵌套\x3c\/li\x3e\n\x3cli\x3e缓存 DOM 节点的访问\x3c\/li\x3e\n\x3cli\x3e通过避免使用 eval() 和 Function() 构造器\x3c\/li\x3e\n\x3cli\x3e给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数\x3c\/li\x3e\n\x3cli\x3e尽量使用直接量创建对象和数组\x3c\/li\x3e\n\x3cli\x3e最小化重绘(repaint)和回流(reflow)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eDOM 元素 e 的 e.getAttribute(propName)和 e.propName 有什么区别和联系\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3ee.getAttribute()，是标准 DOM 操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性\x3c\/li\x3e\n\x3cli\x3ee.propName 通常是在 HTML 文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如 a 标签生成 HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用 getAttribute 进行访问\x3c\/li\x3e\n\x3cli\x3ee.getAttribute()返回值是源文件中设置的值，类型是字符串或者 null（有的实现返回\x22\x22）\x3c\/li\x3e\n\x3cli\x3ee.propName 返回值可能是字符串、布尔值、对象、undefined 等\x3c\/li\x3e\n\x3cli\x3e大部分 attribute 与 property 是一一对应关系，修改其中一个会影响另一个，如 id，title 等属性\x3c\/li\x3e\n\x3cli\x3e一些布尔属性\x3ccode\x3e\x26lt;input hidden\/\x26gt;\x3c\/code\x3e的检测设置需要 hasAttribute 和 removeAttribute 来完成，或者设置对应 property\x3c\/li\x3e\n\x3cli\x3e像\x3ccode\x3e\x26lt;a href=\x22..\/index.html\x22\x26gt;link\x26lt;\/a\x26gt;\x3c\/code\x3e中 href 属性，转换成 property 的时候需要通过转换得到完整 URL\x3c\/li\x3e\n\x3cli\x3e一些 attribute 和 property 不是一一对应如：form 控件中\x3ccode\x3e\x26lt;input value=\x22hello\x22\/\x26gt;\x3c\/code\x3e对应的是 defaultValue，修改或设置 value property 修改的是控件当前值，setAttribute 修改 value 属性不会改变 value property\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3eoffsetWidth\/offsetHeight,clientWidth\/clientHeight 与 scrollWidth\/scrollHeight 的区别\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3eoffsetWidth\/offsetHeight 返回值包含 content \x2b padding \x2b border，效果与 e.getBoundingClientRect()相同\x3c\/li\x3e\n\x3cli\x3eclientWidth\/clientHeight 返回值只包含 content \x2b padding，如果有滚动条，也不包含滚动条\x3c\/li\x3e\n\x3cli\x3escrollWidth\/scrollHeight 返回值包含 content \x2b padding \x2b 溢出内容的尺寸\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e描述浏览器的渲染过程，DOM 树和渲染树的区别？\x3c\/h3\x3e\n\x3cp\x3e浏览器的渲染过程：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e解析 HTML 构建 DOM(DOM 树)，并行请求 css\/image\/js\x3c\/li\x3e\n\x3cli\x3eCSS 文件下载完成，开始构建 CSSOM(CSS 树)\x3c\/li\x3e\n\x3cli\x3eCSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)\x3c\/li\x3e\n\x3cli\x3e布局(Layout)：计算出每个节点在屏幕中的位置\x3c\/li\x3e\n\x3cli\x3e显示(Painting)：通过显卡把页面画到屏幕上\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eDOM 树 和 渲染树 的区别：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eDOM 树与 HTML 标签一一对应，包括 head 和隐藏元素\x3c\/li\x3e\n\x3cli\x3e渲染树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的 css 属性\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e重绘和回流（重排）的区别和关系？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘\x3c\/li\x3e\n\x3cli\x3e回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏\/状态状态）发生改变时，产生重绘回流\x3c\/li\x3e\n\x3cli\x3e注意：JS 获取 Layout 属性值（如：offsetLeft、scrollTop、getComputedStyle 等）也会引起回流。因为浏览器需要通过回流计算最新值\x3c\/li\x3e\n\x3cli\x3e回流必将引起重绘，而重绘不一定会引起回流\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e如何最小化重绘(repaint)和回流(reflow)？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e需要要对元素进行复杂的操作时，可以先隐藏(display:\x22none\x22)，操作完成后再显示\x3c\/li\x3e\n\x3cli\x3e需要创建多个 DOM 节点时，使用 DocumentFragment 创建完后一次性的加入 document\x3c\/li\x3e\n\x3cli\x3e缓存 Layout 属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流\x3c\/li\x3e\n\x3cli\x3e尽量避免用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流）\x3c\/li\x3e\n\x3cli\x3e避免使用 css 表达式(expression)，因为每次调用都会重新计算值（包括加载页面）\x3c\/li\x3e\n\x3cli\x3e尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color\x3cbr\x3e批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3escript 的位置是否会影响首屏显示时间？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script 的位置不影响首屏显示的开始时间。\x3c\/li\x3e\n\x3cli\x3e浏览器解析 HTML 是自上而下的线性过程，script 作为 HTML 的一部分同样遵循这个原则\x3c\/li\x3e\n\x3cli\x3e因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e解释 JavaScript 中的作用域与变量声明提升？\x3c\/h3\x3e\n\x3cp\x3eJavaScript 作用域：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在 Java、C 等语言中，作用域为 for 语句、if 语句或{}内的一块区域，称为作用域；\x3c\/li\x3e\n\x3cli\x3e而在 JavaScript 中，作用域为 function(){}内的区域，称为函数作用域。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eJavaScript 变量声明提升：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在 JavaScript 中，函数声明与变量声明经常被 JavaScript 引擎隐式地提升到当前作用域的顶部。\x3c\/li\x3e\n\x3cli\x3e声明语句中的赋值部分并不会被提升，只有名称被提升\x3c\/li\x3e\n\x3cli\x3e函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明\x3c\/li\x3e\n\x3cli\x3e如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e介绍 JavaScript 的原型，原型链？有什么特点？\x3c\/h3\x3e\n\x3cp\x3e原型：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eJavaScript 的所有对象中都包含了一个 [proto] 内部属性，这个属性所对应的就是该对象的原型\x3c\/li\x3e\n\x3cli\x3eJavaScript 的函数对象，除了原型 [proto] 之外，还预置了 prototype 属性\x3c\/li\x3e\n\x3cli\x3e当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [proto]。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e原型链：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e当一个对象调用的属性\/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找\x3c\/li\x3e\n\x3cli\x3e如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性\/方法或 undefined 为止。从而形成了所谓的“原型链”\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e原型特点：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eJavaScript 对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3eJavaScript 有几种类型的值？，你能画一下他们的内存图吗\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e原始数据类型（Undefined，Null，Boolean，Number、String）-- 栈\x3c\/li\x3e\n\x3cli\x3e引用数据类型（对象、数组和函数）-- 堆\x3c\/li\x3e\n\x3cli\x3e两种类型的区别是：存储位置不同：\x3c\/li\x3e\n\x3cli\x3e原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；\x3c\/li\x3e\n\x3cli\x3e引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；\x3c\/li\x3e\n\x3cli\x3e引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。\x3c\/li\x3e\n\x3cli\x3e当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3eJavaScript 如何实现一个类，怎么实例化这个类？\x3c\/h3\x3e\n\x3col\x3e\x3cli\x3e\n\x3cp\x3e构造函数法（this \x2b prototype） -- 用 new 关键字 生成实例对象\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e缺点：用到了 this 和 prototype，编写复杂，可读性差\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  function Mobile(name, price){\n     this.name = name;\n     this.price = price;\n   }\n   Mobile.prototype.sell = function(){\n      alert(this.name \x2b \x26quot;，售价 $\x26quot; \x2b this.price);\n   }\n   var iPhone7 = new Mobile(\x26quot;iPhone7\x26quot;, 1000);\n   iPhone7.sell();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMobile\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name, price)\x3c\/span\x3e\x3c\/span\x3e{\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.price = price;\n   }\n   Mobile.prototype.sell = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n      alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22，售价 $\x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.price);\n   }\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e iPhone7 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Mobile(\x3cspan class=\x22hljs-string\x22\x3e\x22iPhone7\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n   iPhone7.sell();\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e\n\x3cp\x3eObject.create 法 -- 用 Object.create() 生成实例对象\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var Person = {\n     firstname: \x26quot;Mark\x26quot;,\n     lastname: \x26quot;Yun\x26quot;,\n     age: 25,\n     introduce: function(){\n         alert(\x27I am \x27 \x2b Person.firstname \x2b \x27 \x27 \x2b Person.lastname);\n     }\n };\n\n var person = Object.create(Person);\n person.introduce();\n\n \/\/ Object.create 要求 IE9\x2b，低版本浏览器可以自行部署：\n if (!Object.create) {\n　   Object.create = function (o) {\n　　　 function F() {}\n　　　 F.prototype = o;\n　　　 return new F();\n　　};\n　}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Person = {\n     \x3cspan class=\x22hljs-attr\x22\x3efirstname\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Mark\x22\x3c\/span\x3e,\n     \x3cspan class=\x22hljs-attr\x22\x3elastname\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Yun\x22\x3c\/span\x3e,\n     \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e25\x3c\/span\x3e,\n     \x3cspan class=\x22hljs-attr\x22\x3eintroduce\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n         alert(\x3cspan class=\x22hljs-string\x22\x3e\x27I am \x27\x3c\/span\x3e \x2b Person.firstname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e \x2b Person.lastname);\n     }\n };\n\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(Person);\n person.introduce();\n\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Object.create 要求 IE9\x2b，低版本浏览器可以自行部署：\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create) {\n　   \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eo\x3c\/span\x3e) \x3c\/span\x3e{\n　　　 \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eF\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n　　　 F.prototype = o;\n　　　 \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e F();\n　　};\n　}\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e\n\x3cp\x3e极简主义法（消除 this 和 prototype） -- 调用 createNew() 得到实例对象\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e优点：容易理解，结构清晰优雅，符合传统的\x22面向对象编程\x22的构造\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var Cat = {\n   age: 3, \/\/ 共享数据 -- 定义在类对象内，createNew() 外\n   createNew: function () {\n     var cat = {};\n     \/\/ var cat = Animal.createNew(); \/\/ 继承 Animal 类\n     cat.name = \x26quot;小咪\x26quot;;\n     var sound = \x26quot;喵喵喵\x26quot;; \/\/ 私有属性--定义在 createNew() 内，输出对象外\n     cat.makeSound = function () {\n       alert(sound);  \/\/ 暴露私有属性\n     };\n     cat.changeAge = function(num){\n       Cat.age = num; \/\/ 修改共享数据\n     };\n     return cat; \/\/ 输出对象\n   }\n };\n\n var cat = Cat.createNew();\n cat.makeSound();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eCat\x3c\/span\x3e = {\n   age: 3, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 共享数据 -- 定义在类对象内，createNew() 外\x3c\/span\x3e\n   createNew: function () {\n     \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ecat\x3c\/span\x3e = {};\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ var cat = Animal.createNew(); \/\/ 继承 Animal 类\x3c\/span\x3e\n     \x3cspan class=\x22hljs-keyword\x22\x3ecat\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x22小咪\x22\x3c\/span\x3e;\n     \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sound = \x3cspan class=\x22hljs-string\x22\x3e\x22喵喵喵\x22\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 私有属性--定义在 createNew() 内，输出对象外\x3c\/span\x3e\n     \x3cspan class=\x22hljs-keyword\x22\x3ecat\x3c\/span\x3e.makeSound = function () {\n       alert(sound);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 暴露私有属性\x3c\/span\x3e\n     };\n     \x3cspan class=\x22hljs-keyword\x22\x3ecat\x3c\/span\x3e.changeAge = function(num){\n       \x3cspan class=\x22hljs-keyword\x22\x3eCat\x3c\/span\x3e.age = num; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改共享数据\x3c\/span\x3e\n     };\n     \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ecat\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出对象\x3c\/span\x3e\n   }\n };\n\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ecat\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3eCat\x3c\/span\x3e.createNew();\n \x3cspan class=\x22hljs-keyword\x22\x3ecat\x3c\/span\x3e.makeSound();\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3eES6 语法糖 class -- 用 new 关键字 生成实例对象\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     class Point {\n       constructor(x, y) {\n         this.x = x;\n         this.y = y;\n       }\n       toString() {\n         return \x27(\x27 \x2b this.x \x2b \x27, \x27 \x2b this.y \x2b \x27)\x27;\n       }\n     }\n\n  var point = new Point(2, 3);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e     \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePoint\x3c\/span\x3e \x3c\/span\x3e{\n       \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(x, y) {\n         \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x = x;\n         \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.y = y;\n       }\n       toString() {\n         \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27(\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27, \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.y \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27)\x27\x3c\/span\x3e;\n       }\n     }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e point = new Point(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3eJavascript 如何实现继承？\x3c\/h3\x3e\n\x3col\x3e\x3cli\x3e构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Cat(name,color){\n 　Animal.apply(this, arguments);\n 　this.name = name;\n 　this.color = color;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,color\x3c\/span\x3e)\x3c\/span\x3e{\n 　Animal.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n 　\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n 　\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color = \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e实例继承：将子对象的 prototype 指向父对象的一个实例\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Cat.prototype = new Animal();\nCat.prototype.constructor = Cat;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eCat\x3c\/span\x3e.proto\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e = new \x3cspan class=\x22hljs-type\x22\x3eAnimal\x3c\/span\x3e();\n\x3cspan class=\x22hljs-type\x22\x3eCat\x3c\/span\x3e.proto\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.constructor = \x3cspan class=\x22hljs-type\x22\x3eCat\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function extend(Child, Parent) {\n　　　var p = Parent.prototype;\n　　　var c = Child.prototype;\n　　　for (var i in p) {\n　　　   c[i] = p[i];\n　　　}\n　　　c.uber = p;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextend\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(Child, Parent)\x3c\/span\x3e \x3c\/span\x3e{\n　　　\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p = Parent.prototype;\n　　　\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e c = Child.prototype;\n　　　\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e p) {\n　　　   c[i] = p[i];\n　　　}\n　　　c.uber = p;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e原型继承：将子对象的 prototype 指向父对象的 prototype\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function extend(Child, Parent) {\n    var F = function(){};\n    　F.prototype = Parent.prototype;\n    　Child.prototype = new F();\n    　Child.prototype.constructor = Child;\n    　Child.uber = Parent.prototype;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextend\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(Child, Parent)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e F = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{};\n    　F.prototype = \x3cspan class=\x22hljs-keyword\x22\x3eParent\x3c\/span\x3e.prototype;\n    　Child.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e F();\n    　Child.prototype.constructor = Child;\n    　Child.uber = \x3cspan class=\x22hljs-keyword\x22\x3eParent\x3c\/span\x3e.prototype;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3eES6 语法糖 extends：class ColorPoint extends Point {}\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ColorPoint extends Point {\n    constructor(x, y, color) {\n        super(x, y); \/\/ 调用父类的constructor(x, y)\n        this.color = color;\n    }\n    toString() {\n        return this.color \x2b \x27 \x27 \x2b super.toString(); \/\/ 调用父类的toString()\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eColorPoint\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePoint\x3c\/span\x3e \x3c\/span\x3e{\n    constructor(x, y, color) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(x, y); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用父类的constructor(x, y)\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color = color;\n    }\n    toString() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color \x2b \x27 \x27 \x2b \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e.toString(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用父类的toString()\x3c\/span\x3e\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3ejs 继承方式及其优缺点\x3c\/h3\x3e\n\x3cp\x3e原型链继承的缺点\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e借用构造函数（类式继承）\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链\x2b借用构造函数的模式，这种模式称为组合继承\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e组合式继承\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3ejavascript 创建对象的几种方式？\x3c\/h3\x3e\n\x3cp\x3ejavascript 创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用 JSON；但写法有很多种，也能混合使用\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e对象字面量的方式\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22person={firstname:\x26quot;Mark\x26quot;,lastname:\x26quot;Yun\x26quot;,age:25,eyecolor:\x26quot;black\x26quot;};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eperson={\x3cspan class=\x22hljs-string\x22\x3efirstname:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22Mark\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3elastname:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22Yun\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3eage:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e25\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3eeyecolor:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22black\x22\x3c\/span\x3e};\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e用 function 来模拟无参的构造函数\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 function Person(){}\n    var person=new Person();\/\/定义一个function，如果使用new\x26quot;实例化\x26quot;,该function可以看作是一个Class\n        person.name=\x26quot;Mark\x26quot;;\n        person.age=\x26quot;25\x26quot;;\n        person.work=function(){\n        alert(person.name\x2b\x26quot; hello...\x26quot;);\n    }\nperson.work();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{}\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person=\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\x3cspan class=\x22hljs-comment\x22\x3e\/\/定义一个function，如果使用new\x22实例化\x22,该function可以看作是一个Class\x3c\/span\x3e\n        person.name=\x3cspan class=\x22hljs-string\x22\x3e\x22Mark\x22\x3c\/span\x3e;\n        person.age=\x3cspan class=\x22hljs-string\x22\x3e\x2225\x22\x3c\/span\x3e;\n        person.work=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        alert(person.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x22 hello...\x22\x3c\/span\x3e);\n    }\nperson.work();\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性）\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Pet(name,age,hobby){\n    this.name=name;\/\/this作用域：当前对象\n    this.age=age;\n    this.hobby=hobby;\n    this.eat=function(){\n        alert(\x26quot;我叫\x26quot;\x2bthis.name\x2b\x26quot;,我喜欢\x26quot;\x2bthis.hobby\x2b\x26quot;,是个程序员\x26quot;);\n    }\n}\nvar maidou =new Pet(\x26quot;麦兜\x26quot;,25,\x26quot;coding\x26quot;);\/\/实例化、创建对象\nmaidou.eat();\/\/调用eat方法\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePet\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name,age,hobby)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=name;\x3cspan class=\x22hljs-comment\x22\x3e\/\/this作用域：当前对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age=age;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hobby=hobby;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.eat=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        alert(\x3cspan class=\x22hljs-string\x22\x3e\x22我叫\x22\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x22,我喜欢\x22\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hobby\x2b\x3cspan class=\x22hljs-string\x22\x3e\x22,是个程序员\x22\x3c\/span\x3e);\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e maidou =\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Pet(\x3cspan class=\x22hljs-string\x22\x3e\x22麦兜\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e25\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22coding\x22\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/实例化、创建对象\x3c\/span\x3e\nmaidou.eat();\x3cspan class=\x22hljs-comment\x22\x3e\/\/调用eat方法\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e用工厂方式来创建（内置对象）\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var wcDog =new Object();\n     wcDog.name=\x26quot;旺财\x26quot;;\n     wcDog.age=3;\nwcDog.work=function(){\n    alert(\x26quot;我是\x26quot;\x2bwcDog.name\x2b\x26quot;,汪汪汪......\x26quot;);\n}\nwcDog.work();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e wcDog =\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e();\n     wcDog.name=\x3cspan class=\x22hljs-string\x22\x3e\x22旺财\x22\x3c\/span\x3e;\n     wcDog.age=\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\nwcDog.work=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    alert(\x3cspan class=\x22hljs-string\x22\x3e\x22我是\x22\x3c\/span\x3e\x2bwcDog.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x22,汪汪汪......\x22\x3c\/span\x3e);\n}\nwcDog.work();\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e用原型方式来创建\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Dog(){\n\n    }\nDog.prototype.name=\x26quot;旺财\x26quot;;\nDog.prototype.eat=function(){\n    alert(this.name\x2b\x26quot;是个吃货\x26quot;);\n}\nvar wangcai =new Dog();\nwangcai.eat();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDog\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n\n    }\nDog.prototype.name=\x3cspan class=\x22hljs-string\x22\x3e\x22旺财\x22\x3c\/span\x3e;\nDog.prototype.eat=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    alert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x22是个吃货\x22\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e wangcai =\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dog();\nwangcai.eat();\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e用混合方式来创建\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Car(name,price){\n    this.name=name;\n    this.price=price;\n}\n    Car.prototype.sell=function(){\n    alert(\x26quot;我是\x26quot;\x2bthis.name\x2b\x26quot;，我现在卖\x26quot;\x2bthis.price\x2b\x26quot;万元\x26quot;);\n    }\nvar camry =new Car(\x26quot;凯美瑞\x26quot;,27);\ncamry.sell();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCar\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name,price)\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name=name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.price=price;\n}\n    Car.prototype.sell=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    alert(\x3cspan class=\x22hljs-string\x22\x3e\x22我是\x22\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x22，我现在卖\x22\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.price\x2b\x3cspan class=\x22hljs-string\x22\x3e\x22万元\x22\x3c\/span\x3e);\n    }\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e camry =\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Car(\x3cspan class=\x22hljs-string\x22\x3e\x22凯美瑞\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e);\ncamry.sell();\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader20\x22\x3eJavascript 作用链域?\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节\x3c\/li\x3e\n\x3cli\x3e如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader21\x22\x3e谈谈 this 对象的理解\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3ethis 总是指向函数的直接调用者\x3c\/li\x3e\n\x3cli\x3e如果有 new 关键字，this 指向 new 出来的实例对象\x3c\/li\x3e\n\x3cli\x3e在事件中，this 指向触发这个事件的对象\x3c\/li\x3e\n\x3cli\x3eIE 下 attachEvent 中的 this 总是指向全局对象 Window\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader22\x22\x3eeval 是做什么的？\x3c\/h3\x3e\n\x3cp\x3eeval 的功能是把对应的字符串解析成 JS 代码并运行\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e应该避免使用 eval，不安全，非常耗性能（先解析成 js 语句，再执行）\x3c\/li\x3e\n\x3cli\x3e由 JSON 字符串转换为 JSON 对象的时候可以用 eval(\x27(\x27\x2b str \x2b\x27)\x27);\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader23\x22\x3e什么是 Window 对象? 什么是 Document 对象?\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3eWindow 对象表示当前浏览器的窗口，是 JavaScript 的顶级对象。\x3c\/li\x3e\n\x3cli\x3e我们创建的所有对象、函数、变量都是 Window 对象的成员。\x3c\/li\x3e\n\x3cli\x3eWindow 对象的方法和属性是在全局范围内有效的。\x3c\/li\x3e\n\x3cli\x3eDocument 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）\x3c\/li\x3e\n\x3cli\x3eDocument 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问\x3c\/li\x3e\n\x3cli\x3eDocument 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader24\x22\x3e介绍 DOM 的发展\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3eDOM：文档对象模型（Document Object Model），定义了访问 HTML 和 XML 文档的标准，与编程语言及平台无关\x3c\/li\x3e\n\x3cli\x3eDOM0：提供了查询和操作 Web 文档的内容 API。未形成标准，实现混乱。如：document.forms[\x27login\x27]\x3c\/li\x3e\n\x3cli\x3eDOM1：W3C 提出标准化的 DOM，简化了对文档中任意部分的访问和操作。如：JavaScript 中的 Document 对象\x3c\/li\x3e\n\x3cli\x3eDOM2：原来 DOM 基础上扩充了鼠标事件等细分模块，增加了对 CSS 的支持。如：getComputedStyle(elem, pseudo)\x3c\/li\x3e\n\x3cli\x3eDOM3：增加了 XPath 模块和加载与保存（Load and Save）模块。如：XPathEvaluator\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader25\x22\x3e介绍 DOM0，DOM2，DOM3 事件处理方式区别\x3c\/h3\x3e\n\x3cp\x3eDOM0 级事件处理方式：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ebtn.onclick = func;\x3c\/li\x3e\n\x3cli\x3ebtn.onclick = null;\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eDOM2 级事件处理方式：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ebtn.addEventListener(\x27click\x27, func, false);\x3c\/li\x3e\n\x3cli\x3ebtn.removeEventListener(\x27click\x27, func, false);\x3c\/li\x3e\n\x3cli\x3ebtn.attachEvent(\x22onclick\x22, func);\x3c\/li\x3e\n\x3cli\x3ebtn.detachEvent(\x22onclick\x22, func);\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eDOM3 级事件处理方式：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eeventUtil.addListener(input, \x22textInput\x22, func);\x3c\/li\x3e\n\x3cli\x3eeventUtil 是自定义对象，textInput 是 DOM3 级事件\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader26\x22\x3e事件的三个阶段\x3c\/h3\x3e\n\x3cp\x3e捕获、目标、冒泡\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader27\x22\x3e介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？\x3c\/h3\x3e\n\x3cp\x3e按照 W3C 标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段\x3c\/p\x3e\n\x3cp\x3e事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e注意 1：前提是事件被确实触发\x3c\/li\x3e\n\x3cli\x3e注意 2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e事件执行顺序：判断的关键是否目标元素\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e非目标元素：根据 W3C 的标准执行：捕获-\x26gt;目标元素-\x26gt;冒泡（不依据事件绑定顺序）\x3c\/li\x3e\n\x3cli\x3e目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）\x3c\/li\x3e\n\x3cli\x3e最终顺序：父元素捕获-\x26gt;目标元素事件 1-\x26gt;目标元素事件 2-\x26gt;子元素捕获-\x26gt;子元素冒泡-\x26gt;父元素冒泡\x3c\/li\x3e\n\x3cli\x3e注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader28\x22\x3e在一个 DOM 上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e该 DOM 上的事件如果被触发，会执行两次（执行次数等于绑定次数）\x3c\/li\x3e\n\x3cli\x3e如果该 DOM 是目标元素，则按事件绑定顺序执行，不区分冒泡\/捕获\x3c\/li\x3e\n\x3cli\x3e如果该 DOM 是处于事件流中的非目标元素，则先执行捕获，后执行冒泡\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader29\x22\x3e事件的代理\/委托\x3c\/h3\x3e\n\x3cp\x3e事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件\x3c\/p\x3e\n\x3cp\x3e优点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e可以减少事件注册，节省大量内存占用\x3c\/li\x3e\n\x3cli\x3e可以将事件应用于动态添加的子元素上\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e缺点： 使用不当会造成事件在不应该触发时触发\x3c\/p\x3e\n\x3cp\x3e示例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22ulEl.addEventListener(\x27click\x27, function(e){\n    var target = event.target || event.srcElement;\n    if(!!target \x26amp;\x26amp; target.nodeName.toUpperCase() === \x26quot;LI\x26quot;){\n        console.log(target.innerHTML);\n    }\n}, false);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode\x3eulEl.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, function(e){\n    var \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e = event.\x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e || event.srcElement;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!!\x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e.nodeName.toUpperCase() === \x3cspan class=\x22hljs-string\x22\x3e\x22LI\x22\x3c\/span\x3e){\n        console.log(\x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e.innerHTML);\n    }\n}, \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader30\x22\x3eIE 与火狐的事件机制有什么区别？ 如何阻止冒泡？\x3c\/h3\x3e\n\x3cp\x3eIE 只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获。\x3c\/p\x3e\n\x3cp\x3e阻止冒泡：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e取消默认操作: w3c 的方法是 e.preventDefault()，IE 则是使用 e.returnValue = false;\x3c\/li\x3e\n\x3cli\x3ereturn false javascript 的 return false 只会阻止默认行为，而是用 jQuery 的话则既阻止默认行为又防止对象冒泡。\x3c\/li\x3e\n\x3cli\x3e阻止冒泡 w3c 的方法是 e.stopPropagation()，IE 则是使用 e.cancelBubble = true\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[js] view plaincopy\nfunction stopHandler(event)\n\n    window.event?window.event.cancelBubble=true:event.stopPropagation();\n\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e[js] \x3cspan class=\x22hljs-function\x22\x3eview plaincopy\nfunction \x3cspan class=\x22hljs-title\x22\x3estopHandler\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e\x3c\/span\x3e)\n\n    window.\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e?window.\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.cancelBubble\x3c\/span\x3e=\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e:\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.stopPropagation();\n\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e参考链接:\x3ca href=\x22http:\/\/wiki.jikexueyuan.com\/project\/brief-talk-js\/event-cancellation-and-prevent-bubbles.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e浅谈 javascript 事件取消和阻止冒泡-开源中国 2015\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader31\x22\x3eIE 的事件处理和 W3C 的事件处理有哪些区别？(必考)\x3c\/h3\x3e\n\x3cp\x3e绑定事件\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eW3C: targetEl.addEventListener(\x27click\x27, handler, false);\x3c\/li\x3e\n\x3cli\x3eIE: targetEl.attachEvent(\x27onclick\x27, handler);\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e删除事件\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eW3C: targetEl.removeEventListener(\x27click\x27, handler, false);\x3c\/li\x3e\n\x3cli\x3eIE: targetEl.detachEvent(event, handler);\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e事件对象\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eW3C: var e = arguments.callee.caller.arguments[0]\x3c\/li\x3e\n\x3cli\x3eIE: window.event\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e事件目标\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eW3C: e.target\x3c\/li\x3e\n\x3cli\x3eIE: window.event.srcElement\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e阻止事件默认行为\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eW3C: e.preventDefault()\x3c\/li\x3e\n\x3cli\x3eIE: window.event.returnValue = false\x27\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e阻止事件传播\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eW3C: e.stopPropagation()\x3c\/li\x3e\n\x3cli\x3eIE: window.event.cancelBubble = true\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader32\x22\x3eW3C 事件的 target 与 currentTarget 的区别？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3etarget 只会出现在事件流的目标阶段\x3c\/li\x3e\n\x3cli\x3ecurrentTarget 可能出现在事件流的任何阶段\x3c\/li\x3e\n\x3cli\x3e当事件流处在目标阶段时，二者的指向相同\x3c\/li\x3e\n\x3cli\x3e当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader33\x22\x3e如何派发事件(dispatchEvent)？（如何进行事件广播？）\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3eW3C: 使用 dispatchEvent 方法\x3c\/li\x3e\n\x3cli\x3eIE: 使用 fireEvent 方法\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fireEvent = function(element, event){\n    if (document.createEventObject){\n        var mockEvent = document.createEventObject();\n        return element.fireEvent(\x27on\x27 \x2b event, mockEvent)\n    }else{\n        var mockEvent = document.createEvent(\x27HTMLEvents\x27);\n        mockEvent.initEvent(event, true, true);\n        return !element.dispatchEvent(mockEvent);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fireEvent = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eelement, event\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createEventObject){\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mockEvent = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createEventObject();\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e element.fireEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27on\x27\x3c\/span\x3e \x2b event, mockEvent)\n    }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mockEvent = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27HTMLEvents\x27\x3c\/span\x3e);\n        mockEvent.initEvent(event, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !element.dispatchEvent(mockEvent);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader34\x22\x3e什么是函数节流？介绍一下应用场景和原理？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）\x3c\/li\x3e\n\x3cli\x3e函数节流用于 onresize, onscroll 等短时间内会多次触发的事件\x3c\/li\x3e\n\x3cli\x3e函数节流的原理：使用定时器做时间节流。 当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。 如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器， 再 setTimeout 一个新的定时器重复以上流程。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e函数节流简单实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function throttle(method, context) {\n     clearTimeout(methor.tId);\n     method.tId = setTimeout(function(){\n         method.call(context);\n     }， 100); \/\/ 两次调用至少间隔 100ms\n}\n\/\/ 调用\nwindow.onresize = function(){\n    throttle(myFunc, window);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ethrottle\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emethod, context\x3c\/span\x3e) \x3c\/span\x3e{\n     clearTimeout(methor.tId);\n     method.tId = setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n         method.call(context);\n     }， \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 两次调用至少间隔 100ms\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onresize = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    throttle(myFunc, \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader35\x22\x3e区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY)\x3c\/li\x3e\n\x3cli\x3e页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY)\x3c\/li\x3e\n\x3cli\x3e屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader36\x22\x3e如何获得一个 DOM 元素的绝对位置？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3eelem.offsetLeft：返回元素相对于其定位父级左侧的距离\x3c\/li\x3e\n\x3cli\x3eelem.offsetTop：返回元素相对于其定位父级顶部的距离\x3c\/li\x3e\n\x3cli\x3eelem.getBoundingClientRect()：返回一个 DOMRect 对象，包含一组描述边框的只读属性，单位像素\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader37\x22\x3e分析 [\x271\x27, \x272\x27, \x273\x27].map(parseInt) 答案是多少？（常考）\x3c\/h3\x3e\n\x3cp\x3e答案:[1, NaN, NaN]\x3c\/p\x3e\n\x3cp\x3eparseInt(string, radix) 第 2 个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析\x3c\/p\x3e\n\x3cp\x3emap 每次为 parseInt 传 3 个参数(elem, index, array)，其中 index 为数组索引\x3c\/p\x3e\n\x3cp\x3e因此，map 遍历 [\x221\x22, \x222\x22, \x223\x22]，相应 parseInt 接收参数如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22parseInt(\x271\x27, 0);  \/\/ 1\nparseInt(\x272\x27, 1);  \/\/ NaN\nparseInt(\x273\x27, 2);  \/\/ NaN\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3eparseInt\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eparseInt\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ NaN\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eparseInt\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x273\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ NaN\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以，parseInt 参数 radix 不合法，导致返回值为 NaN\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader38\x22\x3enew 操作符具体干了什么？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型\x3c\/li\x3e\n\x3cli\x3e属性和方法被加入到 this 引用的对象中\x3c\/li\x3e\n\x3cli\x3e新创建的对象由 this 所引用，并且最后隐式的返回 this\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader39\x22\x3e用原生 JavaScript 的实现过什么功能吗？\x3c\/h3\x3e\n\x3cp\x3e封装选择器、调用第三方 API、设置和获取样式(自由回答)\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader40\x22\x3e解释一下这段代码的意思吗？\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  [].forEach.call($$(\x26quot;*\x26quot;), function(el){\n      el.style.outline = \x26quot;1px solid #\x26quot; \x2b (~~(Math.random()*(1\x3c\x3c24))).toString(16);\n  })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  [].forEach.call($$(\x3cspan class=\x22hljs-string\x22\x3e\x22*\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e)\x3c\/span\x3e{\n      el.style.outline = \x3cspan class=\x22hljs-string\x22\x3e\x221px solid #\x22\x3c\/span\x3e \x2b (~~(\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random()*(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x26lt;\x26lt;\x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e))).toString(\x3cspan class=\x22hljs-number\x22\x3e16\x3c\/span\x3e);\n  })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e解释：获取页面所有的元素，遍历这些元素，为它们添加 1 像素随机颜色的轮廓(outline)\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cspan class=\x22MathJax_Preview\x22\x3e\x3c\/span\x3e\x3cdiv class=\x22MathJax_Display\x22 style=\x22text-align: center;\x22\x3e\x3cspan class=\x22MathJax\x22 id=\x22MathJax-Element-1-Frame\x22 tabindex=\x220\x22 style=\x22\x22\x3e\x3cnobr\x3e\x3cspan class=\x22math\x22 id=\x22MathJax-Span-1\x22 role=\x22math\x22 style=\x22width: 2.817em; display: inline-block;\x22\x3e\x3cspan style=\x22display: inline-block; position: relative; width: 2.314em; height: 0px; font-size: 121%;\x22\x3e\x3cspan style=\x22position: absolute; clip: rect(1.631em, 1002.32em, 2.822em, -1000em); top: -2.479em; left: 0em;\x22\x3e\x3cspan class=\x22mrow\x22 id=\x22MathJax-Span-2\x22\x3e\x3cspan class=\x22mo\x22 id=\x22MathJax-Span-3\x22 style=\x22font-family: STIXGeneral-Regular;\x22\x3e(\x3c\/span\x3e\x3cspan class=\x22mi\x22 id=\x22MathJax-Span-4\x22 style=\x22font-family: STIXGeneral-Italic;\x22\x3es\x3c\/span\x3e\x3cspan class=\x22mi\x22 id=\x22MathJax-Span-5\x22 style=\x22font-family: STIXGeneral-Italic;\x22\x3ee\x3c\/span\x3e\x3cspan class=\x22mi\x22 id=\x22MathJax-Span-6\x22 style=\x22font-family: STIXGeneral-Italic;\x22\x3el\x3cspan style=\x22display: inline-block; overflow: hidden; height: 1px; width: 0.001em;\x22\x3e\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22mo\x22 id=\x22MathJax-Span-7\x22 style=\x22font-family: STIXGeneral-Regular;\x22\x3e)\x3c\/span\x3e\x3cspan class=\x22texatom\x22 id=\x22MathJax-Span-8\x22\x3e\x3cspan class=\x22mrow\x22 id=\x22MathJax-Span-9\x22\x3e\x3cspan class=\x22mo\x22 id=\x22MathJax-Span-10\x22 style=\x22font-family: STIXGeneral-Regular;\x22\x3e\/\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22texatom\x22 id=\x22MathJax-Span-11\x22\x3e\x3cspan class=\x22mrow\x22 id=\x22MathJax-Span-12\x22\x3e\x3cspan class=\x22mo\x22 id=\x22MathJax-Span-13\x22 style=\x22font-family: STIXGeneral-Regular;\x22\x3e\/\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3cspan style=\x22display: inline-block; width: 0px; height: 2.479em;\x22\x3e\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3cspan style=\x22display: inline-block; overflow: hidden; vertical-align: -0.281em; border-left: 0px solid; width: 0px; height: 1.174em;\x22\x3e\x3c\/span\x3e\x3c\/span\x3e\x3c\/nobr\x3e\x3c\/span\x3e\x3c\/div\x3e\x3cscript type=\x22math\/tex; mode=display\x22 id=\x22MathJax-Element-1\x22\x3e(sel) \/\/ \x3c\/script\x3e函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel)\x3c\/li\x3e\n\x3cli\x3e[].forEach.call(NodeLists) \/\/ 使用 call 函数将数组遍历函数 forEach 应到节点元素列表\x3c\/li\x3e\n\x3cli\x3eel.style.outline = \x221px solid #333\x22 \/\/ 样式 outline 位于盒模型之外，不影响元素布局位置\x3c\/li\x3e\n\x3cli\x3e(1\x26lt;\x26lt;24) \/\/ parseInt(\x22ffffff\x22, 16) == 16777215 == 2^24 - 1 \/\/ 1\x26lt;\x26lt;24 == 2^24 == 16777216\x3c\/li\x3e\n\x3cli\x3eMath.random()*(1\x26lt;\x26lt;24) \/\/ 表示一个位于 0 到 16777216 之间的随机浮点数\x3c\/li\x3e\n\x3cli\x3e\n\x3cdel\x3eMath.random()*(1\x26lt;\x26lt;24) \/\/ \x3c\/del\x3e 作用相当于 parseInt 取整\x3c\/li\x3e\n\x3cli\x3e(~~(Math.random()*(1\x26lt;\x26lt;24))).toString(16) \/\/ 转换为一个十六进制-\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader41\x22\x3eJavaScript 实现异步编程的方法？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e回调函数\x3c\/li\x3e\n\x3cli\x3e事件监听\x3c\/li\x3e\n\x3cli\x3e发布\/订阅\x3c\/li\x3e\n\x3cli\x3ePromises 对象\x3c\/li\x3e\n\x3cli\x3eAsync 函数[ES7]\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader42\x22\x3eweb 开发中会话跟踪的方法有哪些\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3ecookie\x3c\/li\x3e\n\x3cli\x3esession\x3c\/li\x3e\n\x3cli\x3eurl 重写\x3c\/li\x3e\n\x3cli\x3e隐藏 input\x3c\/li\x3e\n\x3cli\x3eip 地址\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader43\x22\x3e什么是闭包（closure），为什么要用它？\x3c\/h3\x3e\n\x3cp\x3e闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域\x3c\/p\x3e\n\x3cp\x3e闭包的特性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e函数内再嵌套函数\x3c\/li\x3e\n\x3cli\x3e内部函数可以引用外层的参数和变量\x3c\/li\x3e\n\x3cli\x3e参数和变量不会被垃圾回收机制回收\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader44\x22\x3ejavascript 代码中的\x22use strict\x22;是什么意思 ? 使用它区别是什么？\x3c\/h3\x3e\n\x3cp\x3euse strict 是一种 ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使 JS 编码更加规范化的模式,消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader45\x22\x3e如何判断一个对象是否属于某个类？\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 使用instanceof （待完善）\n   if(a instanceof Person){\n       alert(\x27yes\x27);\n   }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gcode\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用instanceof （待完善）\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e(a instanceof Person)\x3c\/span\x3e{\n       alert\x3cspan class=\x22hljs-comment\x22\x3e(\x27yes\x27)\x3c\/span\x3e;\n   }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader46\x22\x3ejs 延迟加载的方式有哪些？\x3c\/h3\x3e\n\x3cp\x3edefer 和 async、动态创建 DOM 方式（用得最多）、按需异步载入 js\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader47\x22\x3edefer 和 async\x3c\/h3\x3e\n\x3cp\x3edefer 并行加载 js 文件，会按照页面上 script 标签的顺序执行 async 并行加载 js 文件，下载完成立即执行，不会按照页面上 script 标签的顺序执行\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader48\x22\x3eAjax 是什么? 如何创建一个 Ajax？\x3c\/h3\x3e\n\x3cp\x3eajax 的全称：Asynchronous Javascript And XML\x3c\/p\x3e\n\x3cp\x3e异步传输\x2bjs\x2bxml\x3c\/p\x3e\n\x3cp\x3e所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e创建 XMLHttpRequest 对象,也就是创建一个异步调用对象\x3c\/li\x3e\n\x3cli\x3e建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息\x3c\/li\x3e\n\x3cli\x3e设置响应 HTTP 请求状态变化的函数\x3c\/li\x3e\n\x3cli\x3e发送 HTTP 请求\x3c\/li\x3e\n\x3cli\x3e获取异步调用返回的数据\x3c\/li\x3e\n\x3cli\x3e用 JavaScript 和 DOM 实现局部刷新\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader49\x22\x3e同步和异步的区别?\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作\x3c\/li\x3e\n\x3cli\x3e异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader50\x22\x3edocumen.write 和 innerHTML 的区别\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3edocument.write 只能重绘整个页面\x3c\/li\x3e\n\x3cli\x3einnerHTML 可以重绘页面的一部分\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader51\x22\x3eDOM 操作——怎样添加、移除、移动、复制、创建和查找节点?\x3c\/h3\x3e\n\x3cp\x3e创建新节点\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ecreateDocumentFragment() \/\/创建一个 DOM 片段\x3c\/li\x3e\n\x3cli\x3ecreateElement() \/\/创建一个具体的元素\x3c\/li\x3e\n\x3cli\x3ecreateTextNode() \/\/创建一个文本节点\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e添加、移除、替换、插入\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eappendChild()\x3c\/li\x3e\n\x3cli\x3eremoveChild()\x3c\/li\x3e\n\x3cli\x3ereplaceChild()\x3c\/li\x3e\n\x3cli\x3einsertBefore() \/\/在已有的子节点前插入一个新的子节点\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e查找\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3egetElementsByTagName() \/\/通过标签名称\x3c\/li\x3e\n\x3cli\x3egetElementsByName() \/\/ 通过元素的 Name 属性的值(IE 容错能力较强，会得到一个数组，其中包括 id 等于 name 值的) * getElementById() \/\/通过元素 Id，唯一性\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader52\x22\x3e那些操作会造成内存泄漏？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\x3c\/li\x3e\n\x3cli\x3e垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收\x3c\/li\x3e\n\x3cli\x3esetTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏\x3c\/li\x3e\n\x3cli\x3e闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader53\x22\x3e渐进增强和优雅降级\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\x3c\/li\x3e\n\x3cli\x3e优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader54\x22\x3eJavascript 垃圾回收方法\x3c\/h3\x3e\n\x3cp\x3e标记清除（mark and sweep）\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”\x3c\/li\x3e\n\x3cli\x3e垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e引用计数(reference counting)\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e参考链接 \x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Memory_Management\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e内存管理-MDN\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader55\x22\x3e用过哪些设计模式？\x3c\/h3\x3e\n\x3col\x3e\x3cli\x3e工厂模式：\x3c\/li\x3e\x3c\/ol\x3e\n\x3cul\x3e\n\x3cli\x3e主要好处就是可以消除对象间的耦合，通过使用工程方法而不是 new 关键字。将所有实例化的代码集中在一个位置防止代码重复\x3c\/li\x3e\n\x3cli\x3e工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createObject(name,age,profession){\/\/集中实例化的函数var obj = new Object();\n    obj.name = name;\n    obj.age = age;\n    obj.profession = profession;\n    obj.move = function () {\n        return this.name \x2b \x27 at \x27 \x2b this.age \x2b \x27 engaged in \x27 \x2b this.profession;\n    };\n    return obj;\n}\nvar test1 = createObject(\x27trigkit4\x27,22,\x27programmer\x27);\/\/第一个实例var test2 = createObject(\x27mike\x27,25,\x27engineer\x27);\/\/第二个实例\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateObject\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name,age,profession)\x3c\/span\x3e\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/\/集中实例化的函数var obj = new Object();\x3c\/span\x3e\n    obj.name = name;\n    obj.age = age;\n    obj.profession = profession;\n    obj.move = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 at \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 engaged in \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.profession;\n    };\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e obj;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e test1 = createObject(\x3cspan class=\x22hljs-string\x22\x3e\x27trigkit4\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27programmer\x27\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/第一个实例var test2 = createObject(\x27mike\x27,25,\x27engineer\x27);\/\/第二个实例\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e构造函数模式\x3c\/li\x3e\x3c\/ol\x3e\n\x3cul\x3e\n\x3cli\x3e使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于\x3c\/li\x3e\n\x3cli\x3e构造函数方法没有显示的创建对象 (new Object());\x3c\/li\x3e\n\x3cli\x3e直接将属性和方法赋值给 this 对象;\x3c\/li\x3e\n\x3cli\x3e没有 renturn 语句\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader56\x22\x3e说说你对闭包的理解\x3c\/h3\x3e\n\x3cp\x3e使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在 js 中，函数即闭包，只有函数才会产生作用域的概念\x3c\/p\x3e\n\x3cp\x3e闭包有三个特性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e函数嵌套函数\x3c\/li\x3e\n\x3cli\x3e函数内部可以引用外部的参数和变量\x3c\/li\x3e\n\x3cli\x3e参数和变量不会被垃圾回收机制回收\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader57\x22\x3e请解释一下 JavaScript 的同源策略\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e概念:同源策略是客户端脚本（尤其是 Javascript）的重要的安全度量标准。它最早出自 Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议\x3c\/li\x3e\n\x3cli\x3e指一段脚本只能读取来自同一来源的窗口和文档的属性\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader58\x22\x3e为什么要有同源限制？\x3c\/h3\x3e\n\x3cp\x3e我们举例说明：比如一个黑客程序，他利用 Iframe 把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过 Javascript 读取到你的表单中 input 中的内容，这样用户名，密码就轻松到手了。]\x3c\/p\x3e\n\x3cp\x3e缺点: 现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader59\x22\x3e实现一个函数 clone，可以对 JavaScript 中的 5 种主要的数据类型（包括 Number、String、Object、Array、Boolean）进行值复制（常考）\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function deepClone(obj) {\n    if (!isObject(obj)) {\n        throw new Error(\x27obj 不是一个对象！\x27)\n    }\n\n    let isArray = Array.isArray(obj)\n    let cloneObj = isArray ? [] : {}\n    for (let key in obj) {\n        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n    }\n\n    return cloneObj\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edeepClone\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isObject(obj)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27obj 不是一个对象！\x27\x3c\/span\x3e)\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e isArray = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(obj)\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cloneObj = isArray ? [] : {}\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e obj) {\n        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cloneObj\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意：for...in 法不支持拷贝 func、date、reg 和 err\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 代理法\nfunction deepClone(obj) {\n    if (!isObject(obj)) {\n        throw new Error(\x27obj 不是一个对象！\x27)\n    }\n\n    let isArray = Array.isArray(obj)\n    let cloneObj = isArray ? [...obj] : { ...obj }\n    Reflect.ownKeys(cloneObj).forEach(key =\x3e {\n        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n    })\n\n    return cloneObj\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 代理法\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edeepClone\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isObject(obj)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27obj 不是一个对象！\x27\x3c\/span\x3e)\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e isArray = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(obj)\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cloneObj = isArray ? [...obj] : { ...obj }\n    \x3cspan class=\x22hljs-built_in\x22\x3eReflect\x3c\/span\x3e.ownKeys(cloneObj).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n    })\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cloneObj\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader60\x22\x3e说说严格模式的限制\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e严格模式主要有以下限制：\x3c\/li\x3e\n\x3cli\x3e变量必须声明后再使用\x3c\/li\x3e\n\x3cli\x3e函数的参数不能有同名属性，否则报错\x3c\/li\x3e\n\x3cli\x3e不能使用 with 语句\x3c\/li\x3e\n\x3cli\x3e不能对只读属性赋值，否则报错\x3c\/li\x3e\n\x3cli\x3e不能使用前缀 0 表示八进制数，否则报错\x3c\/li\x3e\n\x3cli\x3e不能删除不可删除的属性，否则报错\x3c\/li\x3e\n\x3cli\x3e不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]\x3c\/li\x3e\n\x3cli\x3eeval 不会在它的外层作用域引入变量\x3c\/li\x3e\n\x3cli\x3eeval 和 arguments 不能被重新赋值\x3c\/li\x3e\n\x3cli\x3earguments 不会自动反映函数参数的变化\x3c\/li\x3e\n\x3cli\x3e不能使用 arguments.callee\x3c\/li\x3e\n\x3cli\x3e不能使用 arguments.caller\x3c\/li\x3e\n\x3cli\x3e禁止 this 指向全局对象\x3c\/li\x3e\n\x3cli\x3e不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈\x3c\/li\x3e\n\x3cli\x3e增加了保留字（比如 protected、static 和 interface）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader61\x22\x3e如何删除一个 cookie\x3c\/h3\x3e\n\x3cp\x3e将时间设为当前时间往前一点\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var date = new Date();\ndate.setDate(date.getDate() - 1);\/\/真正的删除\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3edate\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e();\n\x3cspan class=\x22hljs-built_in\x22\x3edate\x3c\/span\x3e.setDate(\x3cspan class=\x22hljs-built_in\x22\x3edate\x3c\/span\x3e.getDate() - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/真正的删除\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3esetDate()方法用于设置一个月的某一天\x3c\/p\x3e\n\x3cp\x3eexpires 的设置\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  document.cookie = \x27user=\x27\x2b encodeURIComponent(\x27name\x27)  \x2b \x27;expires = \x27 \x2b new Date(0)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e  \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.cookie = \x3cspan class=\x22hljs-string\x22\x3e\x27user=\x27\x3c\/span\x3e\x2b \x3cspan class=\x22hljs-built_in\x22\x3eencodeURIComponent\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e)  \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27;expires = \x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader62\x22\x3e编写一个方法 求一个字符串的字节长度\x3c\/h3\x3e\n\x3cp\x3e假设：一个英文字符占用一个字节，一个中文字符占用两个字节\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function GetBytes(str){\n\n        var len = str.length;\n\n        var bytes = len;\n\n        for(var i=0; i\x3clen; i\x2b\x2b){\n\n            if (str.charCodeAt(i) \x3e 255) bytes\x2b\x2b;\n\n        }\n\n        return bytes;\n\n    }\n\nalert(GetBytes(\x26quot;你好,as\x26quot;));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGetBytes\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(str)\x3c\/span\x3e\x3c\/span\x3e{\n\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = str.length;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bytes = len;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;len; i\x2b\x2b){\n\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (str.charCodeAt(i) \x26gt; \x3cspan class=\x22hljs-number\x22\x3e255\x3c\/span\x3e) bytes\x2b\x2b;\n\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bytes;\n\n    }\n\nalert(GetBytes(\x3cspan class=\x22hljs-string\x22\x3e\x22你好,as\x22\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader63\x22\x3e请解释什么是事件代理\x3c\/h3\x3e\n\x3cp\x3e事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。使用事件代理的好处是可以提高性能\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader64\x22\x3eattribute 和 property 的区别是什么？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3eattribute 是 dom 元素在文档中作为 html 标签拥有的属性；\x3c\/li\x3e\n\x3cli\x3eproperty 就是 dom 元素在 js 中作为对象拥有的属性。\x3c\/li\x3e\n\x3cli\x3e对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的\x3c\/li\x3e\n\x3cli\x3e但是对于自定义的属性来说，他们是不同步的\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader65\x22\x3e页面编码和被请求的资源编码如果不一致如何处理？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e后端响应头设置 charset\x3c\/li\x3e\n\x3cli\x3e前端页面\x3ccode\x3e\x26lt;meta\x26gt;\x3c\/code\x3e设置 charset\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader66\x22\x3e把 \x3ccode\x3e\x26lt;script\x26gt;\x3c\/code\x3e 放在 \x3ccode\x3e\x26lt;\/body\x26gt;\x3c\/code\x3e 之前和之后有什么区别？浏览器会如何解析它们？\x3c\/h3\x3e\n\x3cp\x3e按照 HTML 标准，在\x26lt;\/body\x26gt;结束后出现\x3ccode\x3e\x26lt;script\x26gt;\x3c\/code\x3e或任何元素的开始标签，都是解析错误\x3cbr\x3e虽然不符合 HTML 标准，但浏览器会自动容错，使实际效果与写在\x3ccode\x3e\x26lt;\/body\x26gt;\x3c\/code\x3e之前没有区别\x3cbr\x3e浏览器的容错机制会忽略\x3ccode\x3e\x26lt;script\x26gt;\x3c\/code\x3e之前的\x26lt;\/body\x26gt;，视作\x3ccode\x3e\x26lt;script\x26gt;\x3c\/code\x3e仍在 body 体内。省略\x3ccode\x3e\x26lt;\/body\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;\/html\x26gt;\x3c\/code\x3e闭合标签符合 HTML 标准，服务器可以利用这一标准\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader67\x22\x3e异步加载 JS 的方式有哪些？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e设置\x3ccode\x3e\x26lt;script\x26gt;\x3c\/code\x3e属性 async=\x22async\x22 （一旦脚本可用，则会异步执行）\x3c\/li\x3e\n\x3cli\x3e动态创建 script DOM：document.createElement(\x27script\x27);\x3c\/li\x3e\n\x3cli\x3eXmlHttpRequest 脚本注入\x3c\/li\x3e\n\x3cli\x3e异步加载库 LABjs\x3c\/li\x3e\n\x3cli\x3e模块加载器 Sea.js\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader68\x22\x3eJavaScript 中，调用函数有哪几种方式？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e方法调用模式 Foo.foo(arg1, arg2);\x3c\/li\x3e\n\x3cli\x3e函数调用模式 foo(arg1, arg2);\x3c\/li\x3e\n\x3cli\x3e构造器调用模式 (new Foo())(arg1, arg2);\x3c\/li\x3e\n\x3cli\x3ecall\/applay 调用模式 Foo.foo.call(that, arg1, arg2);\x3c\/li\x3e\n\x3cli\x3ebind 调用模式 Foo.foo.bind(that)(arg1, arg2)();\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader69\x22\x3e简单实现 Function.bind 函数？\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  if (!Function.prototype.bind) {\n    Function.prototype.bind = function(that) {\n      var func = this, args = arguments;\n      return function() {\n        return func.apply(that, Array.prototype.slice.call(args, 1));\n      }\n    }\n  }\n  \/\/ 只支持 bind 阶段的默认参数：\n  func.bind(that, arg1, arg2)();\n\n  \/\/ 不支持以下调用阶段传入的参数：\n  func.bind(that)(arg1, arg2);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs swift\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-type\x22\x3eFunction\x3c\/span\x3e.prototype.bind) {\n    \x3cspan class=\x22hljs-type\x22\x3eFunction\x3c\/span\x3e.prototype.bind = function(that) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-title\x22\x3eargs\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3earguments\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-title\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eapply\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(that, Array.prototype.slice.call\x3cspan class=\x22hljs-params\x22\x3e(args, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e);\n      }\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只支持 bind 阶段的默认参数：\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ebind\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(that, arg1, arg2)\x3c\/span\x3e\x3c\/span\x3e();\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不支持以下调用阶段传入的参数：\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ebind\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(that)\x3c\/span\x3e\x3c\/span\x3e(arg1, arg2);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader70\x22\x3e列举一下 JavaScript 数组和对象有哪些原生方法\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e数组：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3earr.concat(arr1, arr2, arrn);\x3c\/li\x3e\n\x3cli\x3earr.join(\x22,\x22);\x3c\/li\x3e\n\x3cli\x3earr.sort(func);\x3c\/li\x3e\n\x3cli\x3earr.pop();\x3c\/li\x3e\n\x3cli\x3earr.push(e1, e2, en);\x3c\/li\x3e\n\x3cli\x3earr.shift();\x3c\/li\x3e\n\x3cli\x3eunshift(e1, e2, en);\x3c\/li\x3e\n\x3cli\x3earr.reverse();\x3c\/li\x3e\n\x3cli\x3earr.slice(start, end);\x3c\/li\x3e\n\x3cli\x3earr.splice(index, count, e1, e2, en);\x3c\/li\x3e\n\x3cli\x3earr.indexOf(el);\x3c\/li\x3e\n\x3cli\x3earr.includes(el); \/\/ ES6\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e对象：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eobject.hasOwnProperty(prop);\x3c\/li\x3e\n\x3cli\x3eobject.propertyIsEnumerable(prop);\x3c\/li\x3e\n\x3cli\x3eobject.valueOf();\x3c\/li\x3e\n\x3cli\x3eobject.toString();\x3c\/li\x3e\n\x3cli\x3eobject.toLocaleString();\x3c\/li\x3e\n\x3cli\x3eClass.prototype.isPropertyOf(object);\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader71\x22\x3eArray.splice() 与 Array.splice() 的区别？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3eslice -- “读取”数组指定的元素，不会对原数组进行修改\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e语法：arr.slice(start, end)\x3c\/li\x3e\n\x3cli\x3estart 指定选取开始位置（含）\x3c\/li\x3e\n\x3cli\x3eend 指定选取结束位置（不含）\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3esplice\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e“操作”数组指定的元素，会修改原数组，返回被删除的元素\x3c\/li\x3e\n\x3cli\x3e语法：arr.splice(index, count, [insert Elements])\x3c\/li\x3e\n\x3cli\x3eindex 是操作的起始位置\x3c\/li\x3e\n\x3cli\x3ecount = 0 插入元素，count \x26gt; 0 删除元素\x3c\/li\x3e\n\x3cli\x3e[insert Elements] 向数组新插入的元素\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader72\x22\x3eJavaScript 对象生命周期的理解？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e当创建一个对象时，JavaScript 会自动为该对象分配适当的内存\x3c\/li\x3e\n\x3cli\x3e垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量\x3c\/li\x3e\n\x3cli\x3e如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader73\x22\x3e哪些操作会造成内存泄漏？\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3eJavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收\x3c\/li\x3e\n\x3cli\x3e未使用 var 声明的全局变量\x3c\/li\x3e\n\x3cli\x3e闭包函数(Closures)\x3c\/li\x3e\n\x3cli\x3e循环引用(两个对象相互引用)\x3c\/li\x3e\n\x3cli\x3e控制台日志(console.log)\x3c\/li\x3e\n\x3cli\x3e移除存在绑定事件的 DOM 元素(IE)\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>前端面试绝对会考的JS问题！【已经开源】</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016712465">https://segmentfault.com/a/1190000016712465</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/rj5gbcdbqpe/" target="_blank">https://alili.tech/archive/rj5gbcdbqpe/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>